
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Game
 * 
 */
export type Game = $Result.DefaultSelection<Prisma.$GamePayload>
/**
 * Model Image
 * 
 */
export type Image = $Result.DefaultSelection<Prisma.$ImagePayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model ReviewComment
 * 
 */
export type ReviewComment = $Result.DefaultSelection<Prisma.$ReviewCommentPayload>
/**
 * Model GameUser
 * 
 */
export type GameUser = $Result.DefaultSelection<Prisma.$GameUserPayload>
/**
 * Model GameStatus
 * 
 */
export type GameStatus = $Result.DefaultSelection<Prisma.$GameStatusPayload>
/**
 * Model UserTag
 * 
 */
export type UserTag = $Result.DefaultSelection<Prisma.$UserTagPayload>
/**
 * Model GameTag
 * 
 */
export type GameTag = $Result.DefaultSelection<Prisma.$GameTagPayload>
/**
 * Model ReviewUserTag
 * 
 */
export type ReviewUserTag = $Result.DefaultSelection<Prisma.$ReviewUserTagPayload>
/**
 * Model Developer
 * 
 */
export type Developer = $Result.DefaultSelection<Prisma.$DeveloperPayload>
/**
 * Model Publisher
 * 
 */
export type Publisher = $Result.DefaultSelection<Prisma.$PublisherPayload>
/**
 * Model GameImage
 * 
 */
export type GameImage = $Result.DefaultSelection<Prisma.$GameImagePayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model AchievementUnlock
 * 
 */
export type AchievementUnlock = $Result.DefaultSelection<Prisma.$AchievementUnlockPayload>
/**
 * Model EmailChange
 * 
 */
export type EmailChange = $Result.DefaultSelection<Prisma.$EmailChangePayload>
/**
 * Model EmailVerification
 * 
 */
export type EmailVerification = $Result.DefaultSelection<Prisma.$EmailVerificationPayload>
/**
 * Model PasswordReset
 * 
 */
export type PasswordReset = $Result.DefaultSelection<Prisma.$PasswordResetPayload>
/**
 * Model Friendship
 * 
 */
export type Friendship = $Result.DefaultSelection<Prisma.$FriendshipPayload>
/**
 * Model UserGroup
 * 
 */
export type UserGroup = $Result.DefaultSelection<Prisma.$UserGroupPayload>
/**
 * Model Genre
 * 
 */
export type Genre = $Result.DefaultSelection<Prisma.$GenrePayload>
/**
 * Model Platform
 * 
 */
export type Platform = $Result.DefaultSelection<Prisma.$PlatformPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ProgressStatus: {
  WISHLIST: 'WISHLIST',
  PLAYING: 'PLAYING',
  COMPLETED: 'COMPLETED',
  ON_HOLD: 'ON_HOLD',
  DROPPED: 'DROPPED',
  REPLAYING: 'REPLAYING'
};

export type ProgressStatus = (typeof ProgressStatus)[keyof typeof ProgressStatus]


export const GameStatusType: {
  UPCOMING: 'UPCOMING',
  TRENDING: 'TRENDING',
  TOP: 'TOP',
  CLASSIC: 'CLASSIC',
  NEW_RELEASE: 'NEW_RELEASE'
};

export type GameStatusType = (typeof GameStatusType)[keyof typeof GameStatusType]


export const FriendshipStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  BLOCKED: 'BLOCKED'
};

export type FriendshipStatus = (typeof FriendshipStatus)[keyof typeof FriendshipStatus]

}

export type ProgressStatus = $Enums.ProgressStatus

export const ProgressStatus: typeof $Enums.ProgressStatus

export type GameStatusType = $Enums.GameStatusType

export const GameStatusType: typeof $Enums.GameStatusType

export type FriendshipStatus = $Enums.FriendshipStatus

export const FriendshipStatus: typeof $Enums.FriendshipStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.game`: Exposes CRUD operations for the **Game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.game.findMany()
    * ```
    */
  get game(): Prisma.GameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.image`: Exposes CRUD operations for the **Image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.image.findMany()
    * ```
    */
  get image(): Prisma.ImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewComment`: Exposes CRUD operations for the **ReviewComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewComments
    * const reviewComments = await prisma.reviewComment.findMany()
    * ```
    */
  get reviewComment(): Prisma.ReviewCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameUser`: Exposes CRUD operations for the **GameUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameUsers
    * const gameUsers = await prisma.gameUser.findMany()
    * ```
    */
  get gameUser(): Prisma.GameUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameStatus`: Exposes CRUD operations for the **GameStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameStatuses
    * const gameStatuses = await prisma.gameStatus.findMany()
    * ```
    */
  get gameStatus(): Prisma.GameStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userTag`: Exposes CRUD operations for the **UserTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTags
    * const userTags = await prisma.userTag.findMany()
    * ```
    */
  get userTag(): Prisma.UserTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameTag`: Exposes CRUD operations for the **GameTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameTags
    * const gameTags = await prisma.gameTag.findMany()
    * ```
    */
  get gameTag(): Prisma.GameTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewUserTag`: Exposes CRUD operations for the **ReviewUserTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewUserTags
    * const reviewUserTags = await prisma.reviewUserTag.findMany()
    * ```
    */
  get reviewUserTag(): Prisma.ReviewUserTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.developer`: Exposes CRUD operations for the **Developer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Developers
    * const developers = await prisma.developer.findMany()
    * ```
    */
  get developer(): Prisma.DeveloperDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.publisher`: Exposes CRUD operations for the **Publisher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publishers
    * const publishers = await prisma.publisher.findMany()
    * ```
    */
  get publisher(): Prisma.PublisherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameImage`: Exposes CRUD operations for the **GameImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameImages
    * const gameImages = await prisma.gameImage.findMany()
    * ```
    */
  get gameImage(): Prisma.GameImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.achievementUnlock`: Exposes CRUD operations for the **AchievementUnlock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AchievementUnlocks
    * const achievementUnlocks = await prisma.achievementUnlock.findMany()
    * ```
    */
  get achievementUnlock(): Prisma.AchievementUnlockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailChange`: Exposes CRUD operations for the **EmailChange** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailChanges
    * const emailChanges = await prisma.emailChange.findMany()
    * ```
    */
  get emailChange(): Prisma.EmailChangeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailVerification`: Exposes CRUD operations for the **EmailVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailVerifications
    * const emailVerifications = await prisma.emailVerification.findMany()
    * ```
    */
  get emailVerification(): Prisma.EmailVerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordReset`: Exposes CRUD operations for the **PasswordReset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResets
    * const passwordResets = await prisma.passwordReset.findMany()
    * ```
    */
  get passwordReset(): Prisma.PasswordResetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.friendship`: Exposes CRUD operations for the **Friendship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Friendships
    * const friendships = await prisma.friendship.findMany()
    * ```
    */
  get friendship(): Prisma.FriendshipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userGroup`: Exposes CRUD operations for the **UserGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserGroups
    * const userGroups = await prisma.userGroup.findMany()
    * ```
    */
  get userGroup(): Prisma.UserGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.genre`: Exposes CRUD operations for the **Genre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genres
    * const genres = await prisma.genre.findMany()
    * ```
    */
  get genre(): Prisma.GenreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.platform`: Exposes CRUD operations for the **Platform** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Platforms
    * const platforms = await prisma.platform.findMany()
    * ```
    */
  get platform(): Prisma.PlatformDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Game: 'Game',
    Image: 'Image',
    Review: 'Review',
    ReviewComment: 'ReviewComment',
    GameUser: 'GameUser',
    GameStatus: 'GameStatus',
    UserTag: 'UserTag',
    GameTag: 'GameTag',
    ReviewUserTag: 'ReviewUserTag',
    Developer: 'Developer',
    Publisher: 'Publisher',
    GameImage: 'GameImage',
    Achievement: 'Achievement',
    AchievementUnlock: 'AchievementUnlock',
    EmailChange: 'EmailChange',
    EmailVerification: 'EmailVerification',
    PasswordReset: 'PasswordReset',
    Friendship: 'Friendship',
    UserGroup: 'UserGroup',
    Genre: 'Genre',
    Platform: 'Platform'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "game" | "image" | "review" | "reviewComment" | "gameUser" | "gameStatus" | "userTag" | "gameTag" | "reviewUserTag" | "developer" | "publisher" | "gameImage" | "achievement" | "achievementUnlock" | "emailChange" | "emailVerification" | "passwordReset" | "friendship" | "userGroup" | "genre" | "platform"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Game: {
        payload: Prisma.$GamePayload<ExtArgs>
        fields: Prisma.GameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findFirst: {
            args: Prisma.GameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findMany: {
            args: Prisma.GameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          create: {
            args: Prisma.GameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          createMany: {
            args: Prisma.GameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          delete: {
            args: Prisma.GameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          update: {
            args: Prisma.GameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          deleteMany: {
            args: Prisma.GameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          upsert: {
            args: Prisma.GameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          aggregate: {
            args: Prisma.GameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame>
          }
          groupBy: {
            args: Prisma.GameGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameCountArgs<ExtArgs>
            result: $Utils.Optional<GameCountAggregateOutputType> | number
          }
        }
      }
      Image: {
        payload: Prisma.$ImagePayload<ExtArgs>
        fields: Prisma.ImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findFirst: {
            args: Prisma.ImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findMany: {
            args: Prisma.ImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          create: {
            args: Prisma.ImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          createMany: {
            args: Prisma.ImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          delete: {
            args: Prisma.ImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          update: {
            args: Prisma.ImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          deleteMany: {
            args: Prisma.ImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          upsert: {
            args: Prisma.ImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          aggregate: {
            args: Prisma.ImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImage>
          }
          groupBy: {
            args: Prisma.ImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImageCountArgs<ExtArgs>
            result: $Utils.Optional<ImageCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      ReviewComment: {
        payload: Prisma.$ReviewCommentPayload<ExtArgs>
        fields: Prisma.ReviewCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewCommentPayload>
          }
          findFirst: {
            args: Prisma.ReviewCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewCommentPayload>
          }
          findMany: {
            args: Prisma.ReviewCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewCommentPayload>[]
          }
          create: {
            args: Prisma.ReviewCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewCommentPayload>
          }
          createMany: {
            args: Prisma.ReviewCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewCommentPayload>[]
          }
          delete: {
            args: Prisma.ReviewCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewCommentPayload>
          }
          update: {
            args: Prisma.ReviewCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewCommentPayload>
          }
          deleteMany: {
            args: Prisma.ReviewCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewCommentPayload>[]
          }
          upsert: {
            args: Prisma.ReviewCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewCommentPayload>
          }
          aggregate: {
            args: Prisma.ReviewCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewComment>
          }
          groupBy: {
            args: Prisma.ReviewCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCommentCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCommentCountAggregateOutputType> | number
          }
        }
      }
      GameUser: {
        payload: Prisma.$GameUserPayload<ExtArgs>
        fields: Prisma.GameUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload>
          }
          findFirst: {
            args: Prisma.GameUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload>
          }
          findMany: {
            args: Prisma.GameUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload>[]
          }
          create: {
            args: Prisma.GameUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload>
          }
          createMany: {
            args: Prisma.GameUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload>[]
          }
          delete: {
            args: Prisma.GameUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload>
          }
          update: {
            args: Prisma.GameUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload>
          }
          deleteMany: {
            args: Prisma.GameUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload>[]
          }
          upsert: {
            args: Prisma.GameUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload>
          }
          aggregate: {
            args: Prisma.GameUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameUser>
          }
          groupBy: {
            args: Prisma.GameUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameUserCountArgs<ExtArgs>
            result: $Utils.Optional<GameUserCountAggregateOutputType> | number
          }
        }
      }
      GameStatus: {
        payload: Prisma.$GameStatusPayload<ExtArgs>
        fields: Prisma.GameStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatusPayload>
          }
          findFirst: {
            args: Prisma.GameStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatusPayload>
          }
          findMany: {
            args: Prisma.GameStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatusPayload>[]
          }
          create: {
            args: Prisma.GameStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatusPayload>
          }
          createMany: {
            args: Prisma.GameStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatusPayload>[]
          }
          delete: {
            args: Prisma.GameStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatusPayload>
          }
          update: {
            args: Prisma.GameStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatusPayload>
          }
          deleteMany: {
            args: Prisma.GameStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatusPayload>[]
          }
          upsert: {
            args: Prisma.GameStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatusPayload>
          }
          aggregate: {
            args: Prisma.GameStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameStatus>
          }
          groupBy: {
            args: Prisma.GameStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameStatusCountArgs<ExtArgs>
            result: $Utils.Optional<GameStatusCountAggregateOutputType> | number
          }
        }
      }
      UserTag: {
        payload: Prisma.$UserTagPayload<ExtArgs>
        fields: Prisma.UserTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>
          }
          findFirst: {
            args: Prisma.UserTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>
          }
          findMany: {
            args: Prisma.UserTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>[]
          }
          create: {
            args: Prisma.UserTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>
          }
          createMany: {
            args: Prisma.UserTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>[]
          }
          delete: {
            args: Prisma.UserTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>
          }
          update: {
            args: Prisma.UserTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>
          }
          deleteMany: {
            args: Prisma.UserTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>[]
          }
          upsert: {
            args: Prisma.UserTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>
          }
          aggregate: {
            args: Prisma.UserTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTag>
          }
          groupBy: {
            args: Prisma.UserTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTagCountArgs<ExtArgs>
            result: $Utils.Optional<UserTagCountAggregateOutputType> | number
          }
        }
      }
      GameTag: {
        payload: Prisma.$GameTagPayload<ExtArgs>
        fields: Prisma.GameTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload>
          }
          findFirst: {
            args: Prisma.GameTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload>
          }
          findMany: {
            args: Prisma.GameTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload>[]
          }
          create: {
            args: Prisma.GameTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload>
          }
          createMany: {
            args: Prisma.GameTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload>[]
          }
          delete: {
            args: Prisma.GameTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload>
          }
          update: {
            args: Prisma.GameTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload>
          }
          deleteMany: {
            args: Prisma.GameTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload>[]
          }
          upsert: {
            args: Prisma.GameTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload>
          }
          aggregate: {
            args: Prisma.GameTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameTag>
          }
          groupBy: {
            args: Prisma.GameTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameTagCountArgs<ExtArgs>
            result: $Utils.Optional<GameTagCountAggregateOutputType> | number
          }
        }
      }
      ReviewUserTag: {
        payload: Prisma.$ReviewUserTagPayload<ExtArgs>
        fields: Prisma.ReviewUserTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewUserTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUserTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewUserTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUserTagPayload>
          }
          findFirst: {
            args: Prisma.ReviewUserTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUserTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewUserTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUserTagPayload>
          }
          findMany: {
            args: Prisma.ReviewUserTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUserTagPayload>[]
          }
          create: {
            args: Prisma.ReviewUserTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUserTagPayload>
          }
          createMany: {
            args: Prisma.ReviewUserTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewUserTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUserTagPayload>[]
          }
          delete: {
            args: Prisma.ReviewUserTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUserTagPayload>
          }
          update: {
            args: Prisma.ReviewUserTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUserTagPayload>
          }
          deleteMany: {
            args: Prisma.ReviewUserTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUserTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUserTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUserTagPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUserTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUserTagPayload>
          }
          aggregate: {
            args: Prisma.ReviewUserTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewUserTag>
          }
          groupBy: {
            args: Prisma.ReviewUserTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewUserTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewUserTagCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewUserTagCountAggregateOutputType> | number
          }
        }
      }
      Developer: {
        payload: Prisma.$DeveloperPayload<ExtArgs>
        fields: Prisma.DeveloperFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeveloperFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeveloperFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload>
          }
          findFirst: {
            args: Prisma.DeveloperFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeveloperFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload>
          }
          findMany: {
            args: Prisma.DeveloperFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload>[]
          }
          create: {
            args: Prisma.DeveloperCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload>
          }
          createMany: {
            args: Prisma.DeveloperCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeveloperCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload>[]
          }
          delete: {
            args: Prisma.DeveloperDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload>
          }
          update: {
            args: Prisma.DeveloperUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload>
          }
          deleteMany: {
            args: Prisma.DeveloperDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeveloperUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeveloperUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload>[]
          }
          upsert: {
            args: Prisma.DeveloperUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload>
          }
          aggregate: {
            args: Prisma.DeveloperAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeveloper>
          }
          groupBy: {
            args: Prisma.DeveloperGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeveloperGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeveloperCountArgs<ExtArgs>
            result: $Utils.Optional<DeveloperCountAggregateOutputType> | number
          }
        }
      }
      Publisher: {
        payload: Prisma.$PublisherPayload<ExtArgs>
        fields: Prisma.PublisherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PublisherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublisherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PublisherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublisherPayload>
          }
          findFirst: {
            args: Prisma.PublisherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublisherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PublisherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublisherPayload>
          }
          findMany: {
            args: Prisma.PublisherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublisherPayload>[]
          }
          create: {
            args: Prisma.PublisherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublisherPayload>
          }
          createMany: {
            args: Prisma.PublisherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PublisherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublisherPayload>[]
          }
          delete: {
            args: Prisma.PublisherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublisherPayload>
          }
          update: {
            args: Prisma.PublisherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublisherPayload>
          }
          deleteMany: {
            args: Prisma.PublisherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PublisherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PublisherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublisherPayload>[]
          }
          upsert: {
            args: Prisma.PublisherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublisherPayload>
          }
          aggregate: {
            args: Prisma.PublisherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePublisher>
          }
          groupBy: {
            args: Prisma.PublisherGroupByArgs<ExtArgs>
            result: $Utils.Optional<PublisherGroupByOutputType>[]
          }
          count: {
            args: Prisma.PublisherCountArgs<ExtArgs>
            result: $Utils.Optional<PublisherCountAggregateOutputType> | number
          }
        }
      }
      GameImage: {
        payload: Prisma.$GameImagePayload<ExtArgs>
        fields: Prisma.GameImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameImagePayload>
          }
          findFirst: {
            args: Prisma.GameImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameImagePayload>
          }
          findMany: {
            args: Prisma.GameImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameImagePayload>[]
          }
          create: {
            args: Prisma.GameImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameImagePayload>
          }
          createMany: {
            args: Prisma.GameImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameImagePayload>[]
          }
          delete: {
            args: Prisma.GameImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameImagePayload>
          }
          update: {
            args: Prisma.GameImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameImagePayload>
          }
          deleteMany: {
            args: Prisma.GameImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameImagePayload>[]
          }
          upsert: {
            args: Prisma.GameImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameImagePayload>
          }
          aggregate: {
            args: Prisma.GameImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameImage>
          }
          groupBy: {
            args: Prisma.GameImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameImageCountArgs<ExtArgs>
            result: $Utils.Optional<GameImageCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      AchievementUnlock: {
        payload: Prisma.$AchievementUnlockPayload<ExtArgs>
        fields: Prisma.AchievementUnlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementUnlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementUnlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload>
          }
          findFirst: {
            args: Prisma.AchievementUnlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementUnlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload>
          }
          findMany: {
            args: Prisma.AchievementUnlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload>[]
          }
          create: {
            args: Prisma.AchievementUnlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload>
          }
          createMany: {
            args: Prisma.AchievementUnlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementUnlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload>[]
          }
          delete: {
            args: Prisma.AchievementUnlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload>
          }
          update: {
            args: Prisma.AchievementUnlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload>
          }
          deleteMany: {
            args: Prisma.AchievementUnlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUnlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AchievementUnlockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload>[]
          }
          upsert: {
            args: Prisma.AchievementUnlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload>
          }
          aggregate: {
            args: Prisma.AchievementUnlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievementUnlock>
          }
          groupBy: {
            args: Prisma.AchievementUnlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementUnlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementUnlockCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementUnlockCountAggregateOutputType> | number
          }
        }
      }
      EmailChange: {
        payload: Prisma.$EmailChangePayload<ExtArgs>
        fields: Prisma.EmailChangeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailChangeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailChangeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangePayload>
          }
          findFirst: {
            args: Prisma.EmailChangeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailChangeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangePayload>
          }
          findMany: {
            args: Prisma.EmailChangeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangePayload>[]
          }
          create: {
            args: Prisma.EmailChangeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangePayload>
          }
          createMany: {
            args: Prisma.EmailChangeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailChangeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangePayload>[]
          }
          delete: {
            args: Prisma.EmailChangeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangePayload>
          }
          update: {
            args: Prisma.EmailChangeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangePayload>
          }
          deleteMany: {
            args: Prisma.EmailChangeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailChangeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailChangeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangePayload>[]
          }
          upsert: {
            args: Prisma.EmailChangeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangePayload>
          }
          aggregate: {
            args: Prisma.EmailChangeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailChange>
          }
          groupBy: {
            args: Prisma.EmailChangeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailChangeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailChangeCountArgs<ExtArgs>
            result: $Utils.Optional<EmailChangeCountAggregateOutputType> | number
          }
        }
      }
      EmailVerification: {
        payload: Prisma.$EmailVerificationPayload<ExtArgs>
        fields: Prisma.EmailVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
          }
          findFirst: {
            args: Prisma.EmailVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
          }
          findMany: {
            args: Prisma.EmailVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>[]
          }
          create: {
            args: Prisma.EmailVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
          }
          createMany: {
            args: Prisma.EmailVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>[]
          }
          delete: {
            args: Prisma.EmailVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
          }
          update: {
            args: Prisma.EmailVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
          }
          deleteMany: {
            args: Prisma.EmailVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailVerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>[]
          }
          upsert: {
            args: Prisma.EmailVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
          }
          aggregate: {
            args: Prisma.EmailVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailVerification>
          }
          groupBy: {
            args: Prisma.EmailVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<EmailVerificationCountAggregateOutputType> | number
          }
        }
      }
      PasswordReset: {
        payload: Prisma.$PasswordResetPayload<ExtArgs>
        fields: Prisma.PasswordResetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          findMany: {
            args: Prisma.PasswordResetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          create: {
            args: Prisma.PasswordResetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          createMany: {
            args: Prisma.PasswordResetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          update: {
            args: Prisma.PasswordResetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordReset>
          }
          groupBy: {
            args: Prisma.PasswordResetGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetCountAggregateOutputType> | number
          }
        }
      }
      Friendship: {
        payload: Prisma.$FriendshipPayload<ExtArgs>
        fields: Prisma.FriendshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FriendshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FriendshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          findFirst: {
            args: Prisma.FriendshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FriendshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          findMany: {
            args: Prisma.FriendshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>[]
          }
          create: {
            args: Prisma.FriendshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          createMany: {
            args: Prisma.FriendshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FriendshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>[]
          }
          delete: {
            args: Prisma.FriendshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          update: {
            args: Prisma.FriendshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          deleteMany: {
            args: Prisma.FriendshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FriendshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FriendshipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>[]
          }
          upsert: {
            args: Prisma.FriendshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          aggregate: {
            args: Prisma.FriendshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFriendship>
          }
          groupBy: {
            args: Prisma.FriendshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<FriendshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.FriendshipCountArgs<ExtArgs>
            result: $Utils.Optional<FriendshipCountAggregateOutputType> | number
          }
        }
      }
      UserGroup: {
        payload: Prisma.$UserGroupPayload<ExtArgs>
        fields: Prisma.UserGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          findFirst: {
            args: Prisma.UserGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          findMany: {
            args: Prisma.UserGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>[]
          }
          create: {
            args: Prisma.UserGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          createMany: {
            args: Prisma.UserGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>[]
          }
          delete: {
            args: Prisma.UserGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          update: {
            args: Prisma.UserGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          deleteMany: {
            args: Prisma.UserGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>[]
          }
          upsert: {
            args: Prisma.UserGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          aggregate: {
            args: Prisma.UserGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserGroup>
          }
          groupBy: {
            args: Prisma.UserGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserGroupCountArgs<ExtArgs>
            result: $Utils.Optional<UserGroupCountAggregateOutputType> | number
          }
        }
      }
      Genre: {
        payload: Prisma.$GenrePayload<ExtArgs>
        fields: Prisma.GenreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GenreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          findFirst: {
            args: Prisma.GenreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          findMany: {
            args: Prisma.GenreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          create: {
            args: Prisma.GenreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          createMany: {
            args: Prisma.GenreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GenreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          delete: {
            args: Prisma.GenreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          update: {
            args: Prisma.GenreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          deleteMany: {
            args: Prisma.GenreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GenreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GenreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          upsert: {
            args: Prisma.GenreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          aggregate: {
            args: Prisma.GenreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGenre>
          }
          groupBy: {
            args: Prisma.GenreGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenreGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenreCountArgs<ExtArgs>
            result: $Utils.Optional<GenreCountAggregateOutputType> | number
          }
        }
      }
      Platform: {
        payload: Prisma.$PlatformPayload<ExtArgs>
        fields: Prisma.PlatformFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlatformFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlatformFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          findFirst: {
            args: Prisma.PlatformFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlatformFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          findMany: {
            args: Prisma.PlatformFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>[]
          }
          create: {
            args: Prisma.PlatformCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          createMany: {
            args: Prisma.PlatformCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlatformCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>[]
          }
          delete: {
            args: Prisma.PlatformDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          update: {
            args: Prisma.PlatformUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          deleteMany: {
            args: Prisma.PlatformDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlatformUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlatformUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>[]
          }
          upsert: {
            args: Prisma.PlatformUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          aggregate: {
            args: Prisma.PlatformAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlatform>
          }
          groupBy: {
            args: Prisma.PlatformGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlatformGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlatformCountArgs<ExtArgs>
            result: $Utils.Optional<PlatformCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    game?: GameOmit
    image?: ImageOmit
    review?: ReviewOmit
    reviewComment?: ReviewCommentOmit
    gameUser?: GameUserOmit
    gameStatus?: GameStatusOmit
    userTag?: UserTagOmit
    gameTag?: GameTagOmit
    reviewUserTag?: ReviewUserTagOmit
    developer?: DeveloperOmit
    publisher?: PublisherOmit
    gameImage?: GameImageOmit
    achievement?: AchievementOmit
    achievementUnlock?: AchievementUnlockOmit
    emailChange?: EmailChangeOmit
    emailVerification?: EmailVerificationOmit
    passwordReset?: PasswordResetOmit
    friendship?: FriendshipOmit
    userGroup?: UserGroupOmit
    genre?: GenreOmit
    platform?: PlatformOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    emailChanges: number
    emailVerifications: number
    passwordResets: number
    playedGames: number
    favourites: number
    sentFriendRequests: number
    receivedFriendRequests: number
    groups: number
    reviews: number
    reviewTags: number
    userTags: number
    gameStatuses: number
    achievements: number
    uploadedImages: number
    ReviewComment: number
    GameUser: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailChanges?: boolean | UserCountOutputTypeCountEmailChangesArgs
    emailVerifications?: boolean | UserCountOutputTypeCountEmailVerificationsArgs
    passwordResets?: boolean | UserCountOutputTypeCountPasswordResetsArgs
    playedGames?: boolean | UserCountOutputTypeCountPlayedGamesArgs
    favourites?: boolean | UserCountOutputTypeCountFavouritesArgs
    sentFriendRequests?: boolean | UserCountOutputTypeCountSentFriendRequestsArgs
    receivedFriendRequests?: boolean | UserCountOutputTypeCountReceivedFriendRequestsArgs
    groups?: boolean | UserCountOutputTypeCountGroupsArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    reviewTags?: boolean | UserCountOutputTypeCountReviewTagsArgs
    userTags?: boolean | UserCountOutputTypeCountUserTagsArgs
    gameStatuses?: boolean | UserCountOutputTypeCountGameStatusesArgs
    achievements?: boolean | UserCountOutputTypeCountAchievementsArgs
    uploadedImages?: boolean | UserCountOutputTypeCountUploadedImagesArgs
    ReviewComment?: boolean | UserCountOutputTypeCountReviewCommentArgs
    GameUser?: boolean | UserCountOutputTypeCountGameUserArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailChangeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailVerificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailVerificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlayedGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavouritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentFriendRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedFriendRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGroupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewUserTagWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTagWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGameStatusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameStatusWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementUnlockWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGameUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameUserWhereInput
  }


  /**
   * Count Type GameCountOutputType
   */

  export type GameCountOutputType = {
    reviews: number
    users: number
    favouritedBy: number
    genres: number
    platforms: number
    tags: number
    statuses: number
    developers: number
    publishers: number
    images: number
    achievements: number
  }

  export type GameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | GameCountOutputTypeCountReviewsArgs
    users?: boolean | GameCountOutputTypeCountUsersArgs
    favouritedBy?: boolean | GameCountOutputTypeCountFavouritedByArgs
    genres?: boolean | GameCountOutputTypeCountGenresArgs
    platforms?: boolean | GameCountOutputTypeCountPlatformsArgs
    tags?: boolean | GameCountOutputTypeCountTagsArgs
    statuses?: boolean | GameCountOutputTypeCountStatusesArgs
    developers?: boolean | GameCountOutputTypeCountDevelopersArgs
    publishers?: boolean | GameCountOutputTypeCountPublishersArgs
    images?: boolean | GameCountOutputTypeCountImagesArgs
    achievements?: boolean | GameCountOutputTypeCountAchievementsArgs
  }

  // Custom InputTypes
  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCountOutputType
     */
    select?: GameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameUserWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountFavouritedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountGenresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenreWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountPlatformsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameTagWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountStatusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameStatusWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountDevelopersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeveloperWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountPublishersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublisherWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameImageWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
  }


  /**
   * Count Type ImageCountOutputType
   */

  export type ImageCountOutputType = {
    games: number
    User: number
  }

  export type ImageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | ImageCountOutputTypeCountGamesArgs
    User?: boolean | ImageCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageCountOutputType
     */
    select?: ImageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }

  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type ReviewCountOutputType
   */

  export type ReviewCountOutputType = {
    tags: number
    comments: number
  }

  export type ReviewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | ReviewCountOutputTypeCountTagsArgs
    comments?: boolean | ReviewCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewCountOutputType
     */
    select?: ReviewCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewUserTagWhereInput
  }

  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewCommentWhereInput
  }


  /**
   * Count Type GameStatusCountOutputType
   */

  export type GameStatusCountOutputType = {
    games: number
  }

  export type GameStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | GameStatusCountOutputTypeCountGamesArgs
  }

  // Custom InputTypes
  /**
   * GameStatusCountOutputType without action
   */
  export type GameStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatusCountOutputType
     */
    select?: GameStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameStatusCountOutputType without action
   */
  export type GameStatusCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }


  /**
   * Count Type UserTagCountOutputType
   */

  export type UserTagCountOutputType = {
    users: number
  }

  export type UserTagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserTagCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * UserTagCountOutputType without action
   */
  export type UserTagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTagCountOutputType
     */
    select?: UserTagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserTagCountOutputType without action
   */
  export type UserTagCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type GameTagCountOutputType
   */

  export type GameTagCountOutputType = {
    games: number
  }

  export type GameTagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | GameTagCountOutputTypeCountGamesArgs
  }

  // Custom InputTypes
  /**
   * GameTagCountOutputType without action
   */
  export type GameTagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTagCountOutputType
     */
    select?: GameTagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameTagCountOutputType without action
   */
  export type GameTagCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }


  /**
   * Count Type DeveloperCountOutputType
   */

  export type DeveloperCountOutputType = {
    games: number
  }

  export type DeveloperCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | DeveloperCountOutputTypeCountGamesArgs
  }

  // Custom InputTypes
  /**
   * DeveloperCountOutputType without action
   */
  export type DeveloperCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeveloperCountOutputType
     */
    select?: DeveloperCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeveloperCountOutputType without action
   */
  export type DeveloperCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }


  /**
   * Count Type PublisherCountOutputType
   */

  export type PublisherCountOutputType = {
    games: number
  }

  export type PublisherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | PublisherCountOutputTypeCountGamesArgs
  }

  // Custom InputTypes
  /**
   * PublisherCountOutputType without action
   */
  export type PublisherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublisherCountOutputType
     */
    select?: PublisherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PublisherCountOutputType without action
   */
  export type PublisherCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }


  /**
   * Count Type AchievementCountOutputType
   */

  export type AchievementCountOutputType = {
    unlocks: number
  }

  export type AchievementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unlocks?: boolean | AchievementCountOutputTypeCountUnlocksArgs
  }

  // Custom InputTypes
  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCountOutputType
     */
    select?: AchievementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeCountUnlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementUnlockWhereInput
  }


  /**
   * Count Type UserGroupCountOutputType
   */

  export type UserGroupCountOutputType = {
    users: number
  }

  export type UserGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserGroupCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * UserGroupCountOutputType without action
   */
  export type UserGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroupCountOutputType
     */
    select?: UserGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserGroupCountOutputType without action
   */
  export type UserGroupCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type GenreCountOutputType
   */

  export type GenreCountOutputType = {
    games: number
  }

  export type GenreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | GenreCountOutputTypeCountGamesArgs
  }

  // Custom InputTypes
  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreCountOutputType
     */
    select?: GenreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }


  /**
   * Count Type PlatformCountOutputType
   */

  export type PlatformCountOutputType = {
    games: number
  }

  export type PlatformCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | PlatformCountOutputTypeCountGamesArgs
  }

  // Custom InputTypes
  /**
   * PlatformCountOutputType without action
   */
  export type PlatformCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformCountOutputType
     */
    select?: PlatformCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlatformCountOutputType without action
   */
  export type PlatformCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    profilePictureId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    profilePictureId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    passwordHash: string | null
    googleId: string | null
    displayName: string | null
    profilePictureId: number | null
    emailVerified: boolean | null
    birthDate: Date | null
    registrationDate: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    passwordHash: string | null
    googleId: string | null
    displayName: string | null
    profilePictureId: number | null
    emailVerified: boolean | null
    birthDate: Date | null
    registrationDate: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    googleId: number
    displayName: number
    profilePictureId: number
    emailVerified: number
    birthDate: number
    registrationDate: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    profilePictureId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    profilePictureId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    googleId?: true
    displayName?: true
    profilePictureId?: true
    emailVerified?: true
    birthDate?: true
    registrationDate?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    googleId?: true
    displayName?: true
    profilePictureId?: true
    emailVerified?: true
    birthDate?: true
    registrationDate?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    googleId?: true
    displayName?: true
    profilePictureId?: true
    emailVerified?: true
    birthDate?: true
    registrationDate?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    passwordHash: string | null
    googleId: string | null
    displayName: string
    profilePictureId: number | null
    emailVerified: boolean
    birthDate: Date | null
    registrationDate: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    googleId?: boolean
    displayName?: boolean
    profilePictureId?: boolean
    emailVerified?: boolean
    birthDate?: boolean
    registrationDate?: boolean
    profilePicture?: boolean | User$profilePictureArgs<ExtArgs>
    emailChanges?: boolean | User$emailChangesArgs<ExtArgs>
    emailVerifications?: boolean | User$emailVerificationsArgs<ExtArgs>
    passwordResets?: boolean | User$passwordResetsArgs<ExtArgs>
    playedGames?: boolean | User$playedGamesArgs<ExtArgs>
    favourites?: boolean | User$favouritesArgs<ExtArgs>
    sentFriendRequests?: boolean | User$sentFriendRequestsArgs<ExtArgs>
    receivedFriendRequests?: boolean | User$receivedFriendRequestsArgs<ExtArgs>
    groups?: boolean | User$groupsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    reviewTags?: boolean | User$reviewTagsArgs<ExtArgs>
    userTags?: boolean | User$userTagsArgs<ExtArgs>
    gameStatuses?: boolean | User$gameStatusesArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    uploadedImages?: boolean | User$uploadedImagesArgs<ExtArgs>
    ReviewComment?: boolean | User$ReviewCommentArgs<ExtArgs>
    GameUser?: boolean | User$GameUserArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    googleId?: boolean
    displayName?: boolean
    profilePictureId?: boolean
    emailVerified?: boolean
    birthDate?: boolean
    registrationDate?: boolean
    profilePicture?: boolean | User$profilePictureArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    googleId?: boolean
    displayName?: boolean
    profilePictureId?: boolean
    emailVerified?: boolean
    birthDate?: boolean
    registrationDate?: boolean
    profilePicture?: boolean | User$profilePictureArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    googleId?: boolean
    displayName?: boolean
    profilePictureId?: boolean
    emailVerified?: boolean
    birthDate?: boolean
    registrationDate?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "googleId" | "displayName" | "profilePictureId" | "emailVerified" | "birthDate" | "registrationDate", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profilePicture?: boolean | User$profilePictureArgs<ExtArgs>
    emailChanges?: boolean | User$emailChangesArgs<ExtArgs>
    emailVerifications?: boolean | User$emailVerificationsArgs<ExtArgs>
    passwordResets?: boolean | User$passwordResetsArgs<ExtArgs>
    playedGames?: boolean | User$playedGamesArgs<ExtArgs>
    favourites?: boolean | User$favouritesArgs<ExtArgs>
    sentFriendRequests?: boolean | User$sentFriendRequestsArgs<ExtArgs>
    receivedFriendRequests?: boolean | User$receivedFriendRequestsArgs<ExtArgs>
    groups?: boolean | User$groupsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    reviewTags?: boolean | User$reviewTagsArgs<ExtArgs>
    userTags?: boolean | User$userTagsArgs<ExtArgs>
    gameStatuses?: boolean | User$gameStatusesArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    uploadedImages?: boolean | User$uploadedImagesArgs<ExtArgs>
    ReviewComment?: boolean | User$ReviewCommentArgs<ExtArgs>
    GameUser?: boolean | User$GameUserArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profilePicture?: boolean | User$profilePictureArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profilePicture?: boolean | User$profilePictureArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profilePicture: Prisma.$ImagePayload<ExtArgs> | null
      emailChanges: Prisma.$EmailChangePayload<ExtArgs>[]
      emailVerifications: Prisma.$EmailVerificationPayload<ExtArgs>[]
      passwordResets: Prisma.$PasswordResetPayload<ExtArgs>[]
      playedGames: Prisma.$GamePayload<ExtArgs>[]
      favourites: Prisma.$GamePayload<ExtArgs>[]
      sentFriendRequests: Prisma.$FriendshipPayload<ExtArgs>[]
      receivedFriendRequests: Prisma.$FriendshipPayload<ExtArgs>[]
      groups: Prisma.$UserGroupPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      reviewTags: Prisma.$ReviewUserTagPayload<ExtArgs>[]
      userTags: Prisma.$UserTagPayload<ExtArgs>[]
      gameStatuses: Prisma.$GameStatusPayload<ExtArgs>[]
      achievements: Prisma.$AchievementUnlockPayload<ExtArgs>[]
      uploadedImages: Prisma.$ImagePayload<ExtArgs>[]
      ReviewComment: Prisma.$ReviewCommentPayload<ExtArgs>[]
      GameUser: Prisma.$GameUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      passwordHash: string | null
      googleId: string | null
      displayName: string
      profilePictureId: number | null
      emailVerified: boolean
      birthDate: Date | null
      registrationDate: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profilePicture<T extends User$profilePictureArgs<ExtArgs> = {}>(args?: Subset<T, User$profilePictureArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    emailChanges<T extends User$emailChangesArgs<ExtArgs> = {}>(args?: Subset<T, User$emailChangesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailChangePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailVerifications<T extends User$emailVerificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$emailVerificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordResets<T extends User$passwordResetsArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playedGames<T extends User$playedGamesArgs<ExtArgs> = {}>(args?: Subset<T, User$playedGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favourites<T extends User$favouritesArgs<ExtArgs> = {}>(args?: Subset<T, User$favouritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentFriendRequests<T extends User$sentFriendRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$sentFriendRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedFriendRequests<T extends User$receivedFriendRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedFriendRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groups<T extends User$groupsArgs<ExtArgs> = {}>(args?: Subset<T, User$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewTags<T extends User$reviewTagsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewUserTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userTags<T extends User$userTagsArgs<ExtArgs> = {}>(args?: Subset<T, User$userTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gameStatuses<T extends User$gameStatusesArgs<ExtArgs> = {}>(args?: Subset<T, User$gameStatusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    achievements<T extends User$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, User$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedImages<T extends User$uploadedImagesArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ReviewComment<T extends User$ReviewCommentArgs<ExtArgs> = {}>(args?: Subset<T, User$ReviewCommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    GameUser<T extends User$GameUserArgs<ExtArgs> = {}>(args?: Subset<T, User$GameUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly profilePictureId: FieldRef<"User", 'Int'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly birthDate: FieldRef<"User", 'DateTime'>
    readonly registrationDate: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.profilePicture
   */
  export type User$profilePictureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
  }

  /**
   * User.emailChanges
   */
  export type User$emailChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChange
     */
    select?: EmailChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChange
     */
    omit?: EmailChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeInclude<ExtArgs> | null
    where?: EmailChangeWhereInput
    orderBy?: EmailChangeOrderByWithRelationInput | EmailChangeOrderByWithRelationInput[]
    cursor?: EmailChangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailChangeScalarFieldEnum | EmailChangeScalarFieldEnum[]
  }

  /**
   * User.emailVerifications
   */
  export type User$emailVerificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    where?: EmailVerificationWhereInput
    orderBy?: EmailVerificationOrderByWithRelationInput | EmailVerificationOrderByWithRelationInput[]
    cursor?: EmailVerificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailVerificationScalarFieldEnum | EmailVerificationScalarFieldEnum[]
  }

  /**
   * User.passwordResets
   */
  export type User$passwordResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    where?: PasswordResetWhereInput
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    cursor?: PasswordResetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * User.playedGames
   */
  export type User$playedGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * User.favourites
   */
  export type User$favouritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * User.sentFriendRequests
   */
  export type User$sentFriendRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    cursor?: FriendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * User.receivedFriendRequests
   */
  export type User$receivedFriendRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    cursor?: FriendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * User.groups
   */
  export type User$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    where?: UserGroupWhereInput
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    cursor?: UserGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserGroupScalarFieldEnum | UserGroupScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.reviewTags
   */
  export type User$reviewTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUserTag
     */
    select?: ReviewUserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUserTag
     */
    omit?: ReviewUserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUserTagInclude<ExtArgs> | null
    where?: ReviewUserTagWhereInput
    orderBy?: ReviewUserTagOrderByWithRelationInput | ReviewUserTagOrderByWithRelationInput[]
    cursor?: ReviewUserTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewUserTagScalarFieldEnum | ReviewUserTagScalarFieldEnum[]
  }

  /**
   * User.userTags
   */
  export type User$userTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    where?: UserTagWhereInput
    orderBy?: UserTagOrderByWithRelationInput | UserTagOrderByWithRelationInput[]
    cursor?: UserTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTagScalarFieldEnum | UserTagScalarFieldEnum[]
  }

  /**
   * User.gameStatuses
   */
  export type User$gameStatusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatus
     */
    select?: GameStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatus
     */
    omit?: GameStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatusInclude<ExtArgs> | null
    where?: GameStatusWhereInput
    orderBy?: GameStatusOrderByWithRelationInput | GameStatusOrderByWithRelationInput[]
    cursor?: GameStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameStatusScalarFieldEnum | GameStatusScalarFieldEnum[]
  }

  /**
   * User.achievements
   */
  export type User$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    where?: AchievementUnlockWhereInput
    orderBy?: AchievementUnlockOrderByWithRelationInput | AchievementUnlockOrderByWithRelationInput[]
    cursor?: AchievementUnlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchievementUnlockScalarFieldEnum | AchievementUnlockScalarFieldEnum[]
  }

  /**
   * User.uploadedImages
   */
  export type User$uploadedImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    cursor?: ImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * User.ReviewComment
   */
  export type User$ReviewCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewComment
     */
    omit?: ReviewCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    where?: ReviewCommentWhereInput
    orderBy?: ReviewCommentOrderByWithRelationInput | ReviewCommentOrderByWithRelationInput[]
    cursor?: ReviewCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewCommentScalarFieldEnum | ReviewCommentScalarFieldEnum[]
  }

  /**
   * User.GameUser
   */
  export type User$GameUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    where?: GameUserWhereInput
    orderBy?: GameUserOrderByWithRelationInput | GameUserOrderByWithRelationInput[]
    cursor?: GameUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameUserScalarFieldEnum | GameUserScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Game
   */

  export type AggregateGame = {
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  export type GameAvgAggregateOutputType = {
    id: number | null
    coverImageId: number | null
    userId: number | null
  }

  export type GameSumAggregateOutputType = {
    id: number | null
    coverImageId: number | null
    userId: number | null
  }

  export type GameMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    releaseDate: Date | null
    coverImageId: number | null
    userId: number | null
  }

  export type GameMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    releaseDate: Date | null
    coverImageId: number | null
    userId: number | null
  }

  export type GameCountAggregateOutputType = {
    id: number
    title: number
    description: number
    releaseDate: number
    coverImageId: number
    userId: number
    _all: number
  }


  export type GameAvgAggregateInputType = {
    id?: true
    coverImageId?: true
    userId?: true
  }

  export type GameSumAggregateInputType = {
    id?: true
    coverImageId?: true
    userId?: true
  }

  export type GameMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    releaseDate?: true
    coverImageId?: true
    userId?: true
  }

  export type GameMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    releaseDate?: true
    coverImageId?: true
    userId?: true
  }

  export type GameCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    releaseDate?: true
    coverImageId?: true
    userId?: true
    _all?: true
  }

  export type GameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Game to aggregate.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Games
    **/
    _count?: true | GameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameMaxAggregateInputType
  }

  export type GetGameAggregateType<T extends GameAggregateArgs> = {
        [P in keyof T & keyof AggregateGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame[P]>
      : GetScalarType<T[P], AggregateGame[P]>
  }




  export type GameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
    orderBy?: GameOrderByWithAggregationInput | GameOrderByWithAggregationInput[]
    by: GameScalarFieldEnum[] | GameScalarFieldEnum
    having?: GameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCountAggregateInputType | true
    _avg?: GameAvgAggregateInputType
    _sum?: GameSumAggregateInputType
    _min?: GameMinAggregateInputType
    _max?: GameMaxAggregateInputType
  }

  export type GameGroupByOutputType = {
    id: number
    title: string
    description: string | null
    releaseDate: Date | null
    coverImageId: number | null
    userId: number | null
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  type GetGameGroupByPayload<T extends GameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameGroupByOutputType[P]>
            : GetScalarType<T[P], GameGroupByOutputType[P]>
        }
      >
    >


  export type GameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    releaseDate?: boolean
    coverImageId?: boolean
    userId?: boolean
    coverImage?: boolean | Game$coverImageArgs<ExtArgs>
    reviews?: boolean | Game$reviewsArgs<ExtArgs>
    users?: boolean | Game$usersArgs<ExtArgs>
    favouritedBy?: boolean | Game$favouritedByArgs<ExtArgs>
    genres?: boolean | Game$genresArgs<ExtArgs>
    platforms?: boolean | Game$platformsArgs<ExtArgs>
    tags?: boolean | Game$tagsArgs<ExtArgs>
    statuses?: boolean | Game$statusesArgs<ExtArgs>
    developers?: boolean | Game$developersArgs<ExtArgs>
    publishers?: boolean | Game$publishersArgs<ExtArgs>
    images?: boolean | Game$imagesArgs<ExtArgs>
    achievements?: boolean | Game$achievementsArgs<ExtArgs>
    User?: boolean | Game$UserArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    releaseDate?: boolean
    coverImageId?: boolean
    userId?: boolean
    coverImage?: boolean | Game$coverImageArgs<ExtArgs>
    User?: boolean | Game$UserArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    releaseDate?: boolean
    coverImageId?: boolean
    userId?: boolean
    coverImage?: boolean | Game$coverImageArgs<ExtArgs>
    User?: boolean | Game$UserArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    releaseDate?: boolean
    coverImageId?: boolean
    userId?: boolean
  }

  export type GameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "releaseDate" | "coverImageId" | "userId", ExtArgs["result"]["game"]>
  export type GameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coverImage?: boolean | Game$coverImageArgs<ExtArgs>
    reviews?: boolean | Game$reviewsArgs<ExtArgs>
    users?: boolean | Game$usersArgs<ExtArgs>
    favouritedBy?: boolean | Game$favouritedByArgs<ExtArgs>
    genres?: boolean | Game$genresArgs<ExtArgs>
    platforms?: boolean | Game$platformsArgs<ExtArgs>
    tags?: boolean | Game$tagsArgs<ExtArgs>
    statuses?: boolean | Game$statusesArgs<ExtArgs>
    developers?: boolean | Game$developersArgs<ExtArgs>
    publishers?: boolean | Game$publishersArgs<ExtArgs>
    images?: boolean | Game$imagesArgs<ExtArgs>
    achievements?: boolean | Game$achievementsArgs<ExtArgs>
    User?: boolean | Game$UserArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coverImage?: boolean | Game$coverImageArgs<ExtArgs>
    User?: boolean | Game$UserArgs<ExtArgs>
  }
  export type GameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coverImage?: boolean | Game$coverImageArgs<ExtArgs>
    User?: boolean | Game$UserArgs<ExtArgs>
  }

  export type $GamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Game"
    objects: {
      coverImage: Prisma.$ImagePayload<ExtArgs> | null
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      users: Prisma.$GameUserPayload<ExtArgs>[]
      favouritedBy: Prisma.$UserPayload<ExtArgs>[]
      genres: Prisma.$GenrePayload<ExtArgs>[]
      platforms: Prisma.$PlatformPayload<ExtArgs>[]
      tags: Prisma.$GameTagPayload<ExtArgs>[]
      statuses: Prisma.$GameStatusPayload<ExtArgs>[]
      developers: Prisma.$DeveloperPayload<ExtArgs>[]
      publishers: Prisma.$PublisherPayload<ExtArgs>[]
      images: Prisma.$GameImagePayload<ExtArgs>[]
      achievements: Prisma.$AchievementPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      releaseDate: Date | null
      coverImageId: number | null
      userId: number | null
    }, ExtArgs["result"]["game"]>
    composites: {}
  }

  type GameGetPayload<S extends boolean | null | undefined | GameDefaultArgs> = $Result.GetResult<Prisma.$GamePayload, S>

  type GameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameCountAggregateInputType | true
    }

  export interface GameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Game'], meta: { name: 'Game' } }
    /**
     * Find zero or one Game that matches the filter.
     * @param {GameFindUniqueArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameFindUniqueArgs>(args: SelectSubset<T, GameFindUniqueArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Game that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameFindUniqueOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameFindUniqueOrThrowArgs>(args: SelectSubset<T, GameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameFindFirstArgs>(args?: SelectSubset<T, GameFindFirstArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameFindFirstOrThrowArgs>(args?: SelectSubset<T, GameFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.game.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameWithIdOnly = await prisma.game.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameFindManyArgs>(args?: SelectSubset<T, GameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Game.
     * @param {GameCreateArgs} args - Arguments to create a Game.
     * @example
     * // Create one Game
     * const Game = await prisma.game.create({
     *   data: {
     *     // ... data to create a Game
     *   }
     * })
     * 
     */
    create<T extends GameCreateArgs>(args: SelectSubset<T, GameCreateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Games.
     * @param {GameCreateManyArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameCreateManyArgs>(args?: SelectSubset<T, GameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Games and returns the data saved in the database.
     * @param {GameCreateManyAndReturnArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameCreateManyAndReturnArgs>(args?: SelectSubset<T, GameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Game.
     * @param {GameDeleteArgs} args - Arguments to delete one Game.
     * @example
     * // Delete one Game
     * const Game = await prisma.game.delete({
     *   where: {
     *     // ... filter to delete one Game
     *   }
     * })
     * 
     */
    delete<T extends GameDeleteArgs>(args: SelectSubset<T, GameDeleteArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Game.
     * @param {GameUpdateArgs} args - Arguments to update one Game.
     * @example
     * // Update one Game
     * const game = await prisma.game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameUpdateArgs>(args: SelectSubset<T, GameUpdateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Games.
     * @param {GameDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameDeleteManyArgs>(args?: SelectSubset<T, GameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameUpdateManyArgs>(args: SelectSubset<T, GameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games and returns the data updated in the database.
     * @param {GameUpdateManyAndReturnArgs} args - Arguments to update many Games.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameUpdateManyAndReturnArgs>(args: SelectSubset<T, GameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Game.
     * @param {GameUpsertArgs} args - Arguments to update or create a Game.
     * @example
     * // Update or create a Game
     * const game = await prisma.game.upsert({
     *   create: {
     *     // ... data to create a Game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game we want to update
     *   }
     * })
     */
    upsert<T extends GameUpsertArgs>(args: SelectSubset<T, GameUpsertArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.game.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends GameCountArgs>(
      args?: Subset<T, GameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAggregateArgs>(args: Subset<T, GameAggregateArgs>): Prisma.PrismaPromise<GetGameAggregateType<T>>

    /**
     * Group by Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameGroupByArgs['orderBy'] }
        : { orderBy?: GameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Game model
   */
  readonly fields: GameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coverImage<T extends Game$coverImageArgs<ExtArgs> = {}>(args?: Subset<T, Game$coverImageArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reviews<T extends Game$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Game$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Game$usersArgs<ExtArgs> = {}>(args?: Subset<T, Game$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favouritedBy<T extends Game$favouritedByArgs<ExtArgs> = {}>(args?: Subset<T, Game$favouritedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    genres<T extends Game$genresArgs<ExtArgs> = {}>(args?: Subset<T, Game$genresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    platforms<T extends Game$platformsArgs<ExtArgs> = {}>(args?: Subset<T, Game$platformsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Game$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Game$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    statuses<T extends Game$statusesArgs<ExtArgs> = {}>(args?: Subset<T, Game$statusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    developers<T extends Game$developersArgs<ExtArgs> = {}>(args?: Subset<T, Game$developersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    publishers<T extends Game$publishersArgs<ExtArgs> = {}>(args?: Subset<T, Game$publishersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublisherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    images<T extends Game$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Game$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    achievements<T extends Game$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, Game$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends Game$UserArgs<ExtArgs> = {}>(args?: Subset<T, Game$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Game model
   */
  interface GameFieldRefs {
    readonly id: FieldRef<"Game", 'Int'>
    readonly title: FieldRef<"Game", 'String'>
    readonly description: FieldRef<"Game", 'String'>
    readonly releaseDate: FieldRef<"Game", 'DateTime'>
    readonly coverImageId: FieldRef<"Game", 'Int'>
    readonly userId: FieldRef<"Game", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Game findUnique
   */
  export type GameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findUniqueOrThrow
   */
  export type GameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findFirst
   */
  export type GameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findFirstOrThrow
   */
  export type GameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findMany
   */
  export type GameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Games to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game create
   */
  export type GameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to create a Game.
     */
    data: XOR<GameCreateInput, GameUncheckedCreateInput>
  }

  /**
   * Game createMany
   */
  export type GameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Game createManyAndReturn
   */
  export type GameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Game update
   */
  export type GameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to update a Game.
     */
    data: XOR<GameUpdateInput, GameUncheckedUpdateInput>
    /**
     * Choose, which Game to update.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game updateMany
   */
  export type GameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to update.
     */
    limit?: number
  }

  /**
   * Game updateManyAndReturn
   */
  export type GameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Game upsert
   */
  export type GameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The filter to search for the Game to update in case it exists.
     */
    where: GameWhereUniqueInput
    /**
     * In case the Game found by the `where` argument doesn't exist, create a new Game with this data.
     */
    create: XOR<GameCreateInput, GameUncheckedCreateInput>
    /**
     * In case the Game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameUpdateInput, GameUncheckedUpdateInput>
  }

  /**
   * Game delete
   */
  export type GameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter which Game to delete.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game deleteMany
   */
  export type GameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Games to delete
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to delete.
     */
    limit?: number
  }

  /**
   * Game.coverImage
   */
  export type Game$coverImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
  }

  /**
   * Game.reviews
   */
  export type Game$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Game.users
   */
  export type Game$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    where?: GameUserWhereInput
    orderBy?: GameUserOrderByWithRelationInput | GameUserOrderByWithRelationInput[]
    cursor?: GameUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameUserScalarFieldEnum | GameUserScalarFieldEnum[]
  }

  /**
   * Game.favouritedBy
   */
  export type Game$favouritedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Game.genres
   */
  export type Game$genresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    where?: GenreWhereInput
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    cursor?: GenreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Game.platforms
   */
  export type Game$platformsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    where?: PlatformWhereInput
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    cursor?: PlatformWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlatformScalarFieldEnum | PlatformScalarFieldEnum[]
  }

  /**
   * Game.tags
   */
  export type Game$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
    where?: GameTagWhereInput
    orderBy?: GameTagOrderByWithRelationInput | GameTagOrderByWithRelationInput[]
    cursor?: GameTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameTagScalarFieldEnum | GameTagScalarFieldEnum[]
  }

  /**
   * Game.statuses
   */
  export type Game$statusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatus
     */
    select?: GameStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatus
     */
    omit?: GameStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatusInclude<ExtArgs> | null
    where?: GameStatusWhereInput
    orderBy?: GameStatusOrderByWithRelationInput | GameStatusOrderByWithRelationInput[]
    cursor?: GameStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameStatusScalarFieldEnum | GameStatusScalarFieldEnum[]
  }

  /**
   * Game.developers
   */
  export type Game$developersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeveloperInclude<ExtArgs> | null
    where?: DeveloperWhereInput
    orderBy?: DeveloperOrderByWithRelationInput | DeveloperOrderByWithRelationInput[]
    cursor?: DeveloperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeveloperScalarFieldEnum | DeveloperScalarFieldEnum[]
  }

  /**
   * Game.publishers
   */
  export type Game$publishersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publisher
     */
    select?: PublisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publisher
     */
    omit?: PublisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublisherInclude<ExtArgs> | null
    where?: PublisherWhereInput
    orderBy?: PublisherOrderByWithRelationInput | PublisherOrderByWithRelationInput[]
    cursor?: PublisherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PublisherScalarFieldEnum | PublisherScalarFieldEnum[]
  }

  /**
   * Game.images
   */
  export type Game$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameImage
     */
    select?: GameImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameImage
     */
    omit?: GameImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameImageInclude<ExtArgs> | null
    where?: GameImageWhereInput
    orderBy?: GameImageOrderByWithRelationInput | GameImageOrderByWithRelationInput[]
    cursor?: GameImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameImageScalarFieldEnum | GameImageScalarFieldEnum[]
  }

  /**
   * Game.achievements
   */
  export type Game$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    cursor?: AchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Game.User
   */
  export type Game$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Game without action
   */
  export type GameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
  }


  /**
   * Model Image
   */

  export type AggregateImage = {
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  export type ImageAvgAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    uploadedById: number | null
  }

  export type ImageSumAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    uploadedById: number | null
  }

  export type ImageMinAggregateOutputType = {
    id: number | null
    url: string | null
    checksum: string | null
    width: number | null
    height: number | null
    uploadedAt: Date | null
    uploadedById: number | null
  }

  export type ImageMaxAggregateOutputType = {
    id: number | null
    url: string | null
    checksum: string | null
    width: number | null
    height: number | null
    uploadedAt: Date | null
    uploadedById: number | null
  }

  export type ImageCountAggregateOutputType = {
    id: number
    url: number
    checksum: number
    width: number
    height: number
    uploadedAt: number
    uploadedById: number
    _all: number
  }


  export type ImageAvgAggregateInputType = {
    id?: true
    width?: true
    height?: true
    uploadedById?: true
  }

  export type ImageSumAggregateInputType = {
    id?: true
    width?: true
    height?: true
    uploadedById?: true
  }

  export type ImageMinAggregateInputType = {
    id?: true
    url?: true
    checksum?: true
    width?: true
    height?: true
    uploadedAt?: true
    uploadedById?: true
  }

  export type ImageMaxAggregateInputType = {
    id?: true
    url?: true
    checksum?: true
    width?: true
    height?: true
    uploadedAt?: true
    uploadedById?: true
  }

  export type ImageCountAggregateInputType = {
    id?: true
    url?: true
    checksum?: true
    width?: true
    height?: true
    uploadedAt?: true
    uploadedById?: true
    _all?: true
  }

  export type ImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Image to aggregate.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Images
    **/
    _count?: true | ImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageMaxAggregateInputType
  }

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
        [P in keyof T & keyof AggregateImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>
  }




  export type ImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithAggregationInput | ImageOrderByWithAggregationInput[]
    by: ImageScalarFieldEnum[] | ImageScalarFieldEnum
    having?: ImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageCountAggregateInputType | true
    _avg?: ImageAvgAggregateInputType
    _sum?: ImageSumAggregateInputType
    _min?: ImageMinAggregateInputType
    _max?: ImageMaxAggregateInputType
  }

  export type ImageGroupByOutputType = {
    id: number
    url: string
    checksum: string
    width: number | null
    height: number | null
    uploadedAt: Date
    uploadedById: number | null
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  type GetImageGroupByPayload<T extends ImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageGroupByOutputType[P]>
            : GetScalarType<T[P], ImageGroupByOutputType[P]>
        }
      >
    >


  export type ImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    checksum?: boolean
    width?: boolean
    height?: boolean
    uploadedAt?: boolean
    uploadedById?: boolean
    uploadedBy?: boolean | Image$uploadedByArgs<ExtArgs>
    games?: boolean | Image$gamesArgs<ExtArgs>
    User?: boolean | Image$UserArgs<ExtArgs>
    _count?: boolean | ImageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>

  export type ImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    checksum?: boolean
    width?: boolean
    height?: boolean
    uploadedAt?: boolean
    uploadedById?: boolean
    uploadedBy?: boolean | Image$uploadedByArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>

  export type ImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    checksum?: boolean
    width?: boolean
    height?: boolean
    uploadedAt?: boolean
    uploadedById?: boolean
    uploadedBy?: boolean | Image$uploadedByArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>

  export type ImageSelectScalar = {
    id?: boolean
    url?: boolean
    checksum?: boolean
    width?: boolean
    height?: boolean
    uploadedAt?: boolean
    uploadedById?: boolean
  }

  export type ImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "checksum" | "width" | "height" | "uploadedAt" | "uploadedById", ExtArgs["result"]["image"]>
  export type ImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploadedBy?: boolean | Image$uploadedByArgs<ExtArgs>
    games?: boolean | Image$gamesArgs<ExtArgs>
    User?: boolean | Image$UserArgs<ExtArgs>
    _count?: boolean | ImageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploadedBy?: boolean | Image$uploadedByArgs<ExtArgs>
  }
  export type ImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploadedBy?: boolean | Image$uploadedByArgs<ExtArgs>
  }

  export type $ImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Image"
    objects: {
      uploadedBy: Prisma.$UserPayload<ExtArgs> | null
      games: Prisma.$GamePayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      url: string
      checksum: string
      width: number | null
      height: number | null
      uploadedAt: Date
      uploadedById: number | null
    }, ExtArgs["result"]["image"]>
    composites: {}
  }

  type ImageGetPayload<S extends boolean | null | undefined | ImageDefaultArgs> = $Result.GetResult<Prisma.$ImagePayload, S>

  type ImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImageCountAggregateInputType | true
    }

  export interface ImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Image'], meta: { name: 'Image' } }
    /**
     * Find zero or one Image that matches the filter.
     * @param {ImageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImageFindUniqueArgs>(args: SelectSubset<T, ImageFindUniqueArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Image that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImageFindUniqueOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImageFindFirstArgs>(args?: SelectSubset<T, ImageFindFirstArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Image that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageWithIdOnly = await prisma.image.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImageFindManyArgs>(args?: SelectSubset<T, ImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Image.
     * @param {ImageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     * 
     */
    create<T extends ImageCreateArgs>(args: SelectSubset<T, ImageCreateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Images.
     * @param {ImageCreateManyArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImageCreateManyArgs>(args?: SelectSubset<T, ImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Images and returns the data saved in the database.
     * @param {ImageCreateManyAndReturnArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Images and only return the `id`
     * const imageWithIdOnly = await prisma.image.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImageCreateManyAndReturnArgs>(args?: SelectSubset<T, ImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Image.
     * @param {ImageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     * 
     */
    delete<T extends ImageDeleteArgs>(args: SelectSubset<T, ImageDeleteArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Image.
     * @param {ImageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImageUpdateArgs>(args: SelectSubset<T, ImageUpdateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Images.
     * @param {ImageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImageDeleteManyArgs>(args?: SelectSubset<T, ImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImageUpdateManyArgs>(args: SelectSubset<T, ImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images and returns the data updated in the database.
     * @param {ImageUpdateManyAndReturnArgs} args - Arguments to update many Images.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Images and only return the `id`
     * const imageWithIdOnly = await prisma.image.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImageUpdateManyAndReturnArgs>(args: SelectSubset<T, ImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Image.
     * @param {ImageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
     */
    upsert<T extends ImageUpsertArgs>(args: SelectSubset<T, ImageUpsertArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends ImageCountArgs>(
      args?: Subset<T, ImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageAggregateArgs>(args: Subset<T, ImageAggregateArgs>): Prisma.PrismaPromise<GetImageAggregateType<T>>

    /**
     * Group by Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageGroupByArgs['orderBy'] }
        : { orderBy?: ImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Image model
   */
  readonly fields: ImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uploadedBy<T extends Image$uploadedByArgs<ExtArgs> = {}>(args?: Subset<T, Image$uploadedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    games<T extends Image$gamesArgs<ExtArgs> = {}>(args?: Subset<T, Image$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends Image$UserArgs<ExtArgs> = {}>(args?: Subset<T, Image$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Image model
   */
  interface ImageFieldRefs {
    readonly id: FieldRef<"Image", 'Int'>
    readonly url: FieldRef<"Image", 'String'>
    readonly checksum: FieldRef<"Image", 'String'>
    readonly width: FieldRef<"Image", 'Int'>
    readonly height: FieldRef<"Image", 'Int'>
    readonly uploadedAt: FieldRef<"Image", 'DateTime'>
    readonly uploadedById: FieldRef<"Image", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Image findUnique
   */
  export type ImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findUniqueOrThrow
   */
  export type ImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findFirst
   */
  export type ImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findFirstOrThrow
   */
  export type ImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findMany
   */
  export type ImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image create
   */
  export type ImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to create a Image.
     */
    data: XOR<ImageCreateInput, ImageUncheckedCreateInput>
  }

  /**
   * Image createMany
   */
  export type ImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Image createManyAndReturn
   */
  export type ImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Image update
   */
  export type ImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to update a Image.
     */
    data: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
    /**
     * Choose, which Image to update.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image updateMany
   */
  export type ImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
    /**
     * Limit how many Images to update.
     */
    limit?: number
  }

  /**
   * Image updateManyAndReturn
   */
  export type ImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
    /**
     * Limit how many Images to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Image upsert
   */
  export type ImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The filter to search for the Image to update in case it exists.
     */
    where: ImageWhereUniqueInput
    /**
     * In case the Image found by the `where` argument doesn't exist, create a new Image with this data.
     */
    create: XOR<ImageCreateInput, ImageUncheckedCreateInput>
    /**
     * In case the Image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
  }

  /**
   * Image delete
   */
  export type ImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter which Image to delete.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image deleteMany
   */
  export type ImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Images to delete
     */
    where?: ImageWhereInput
    /**
     * Limit how many Images to delete.
     */
    limit?: number
  }

  /**
   * Image.uploadedBy
   */
  export type Image$uploadedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Image.games
   */
  export type Image$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Image.User
   */
  export type Image$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Image without action
   */
  export type ImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    id: number | null
    rating: number | null
    userId: number | null
    gameId: number | null
  }

  export type ReviewSumAggregateOutputType = {
    id: number | null
    rating: number | null
    userId: number | null
    gameId: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: number | null
    rating: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
    gameId: number | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: number | null
    rating: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
    gameId: number | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    rating: number
    content: number
    createdAt: number
    updatedAt: number
    userId: number
    gameId: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    id?: true
    rating?: true
    userId?: true
    gameId?: true
  }

  export type ReviewSumAggregateInputType = {
    id?: true
    rating?: true
    userId?: true
    gameId?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    rating?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    gameId?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    rating?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    gameId?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    rating?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    gameId?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: number
    rating: number
    content: string | null
    createdAt: Date
    updatedAt: Date
    userId: number
    gameId: number
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    gameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    tags?: boolean | Review$tagsArgs<ExtArgs>
    comments?: boolean | Review$commentsArgs<ExtArgs>
    _count?: boolean | ReviewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    gameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    gameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    rating?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    gameId?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rating" | "content" | "createdAt" | "updatedAt" | "userId" | "gameId", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    tags?: boolean | Review$tagsArgs<ExtArgs>
    comments?: boolean | Review$commentsArgs<ExtArgs>
    _count?: boolean | ReviewCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
      tags: Prisma.$ReviewUserTagPayload<ExtArgs>[]
      comments: Prisma.$ReviewCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rating: number
      content: string | null
      createdAt: Date
      updatedAt: Date
      userId: number
      gameId: number
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tags<T extends Review$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Review$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewUserTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Review$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Review$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'Int'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly content: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
    readonly userId: FieldRef<"Review", 'Int'>
    readonly gameId: FieldRef<"Review", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review.tags
   */
  export type Review$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUserTag
     */
    select?: ReviewUserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUserTag
     */
    omit?: ReviewUserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUserTagInclude<ExtArgs> | null
    where?: ReviewUserTagWhereInput
    orderBy?: ReviewUserTagOrderByWithRelationInput | ReviewUserTagOrderByWithRelationInput[]
    cursor?: ReviewUserTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewUserTagScalarFieldEnum | ReviewUserTagScalarFieldEnum[]
  }

  /**
   * Review.comments
   */
  export type Review$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewComment
     */
    omit?: ReviewCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    where?: ReviewCommentWhereInput
    orderBy?: ReviewCommentOrderByWithRelationInput | ReviewCommentOrderByWithRelationInput[]
    cursor?: ReviewCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewCommentScalarFieldEnum | ReviewCommentScalarFieldEnum[]
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model ReviewComment
   */

  export type AggregateReviewComment = {
    _count: ReviewCommentCountAggregateOutputType | null
    _avg: ReviewCommentAvgAggregateOutputType | null
    _sum: ReviewCommentSumAggregateOutputType | null
    _min: ReviewCommentMinAggregateOutputType | null
    _max: ReviewCommentMaxAggregateOutputType | null
  }

  export type ReviewCommentAvgAggregateOutputType = {
    id: number | null
    reviewId: number | null
    userId: number | null
  }

  export type ReviewCommentSumAggregateOutputType = {
    id: number | null
    reviewId: number | null
    userId: number | null
  }

  export type ReviewCommentMinAggregateOutputType = {
    id: number | null
    content: string | null
    createdAt: Date | null
    reviewId: number | null
    userId: number | null
  }

  export type ReviewCommentMaxAggregateOutputType = {
    id: number | null
    content: string | null
    createdAt: Date | null
    reviewId: number | null
    userId: number | null
  }

  export type ReviewCommentCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    reviewId: number
    userId: number
    _all: number
  }


  export type ReviewCommentAvgAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
  }

  export type ReviewCommentSumAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
  }

  export type ReviewCommentMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    reviewId?: true
    userId?: true
  }

  export type ReviewCommentMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    reviewId?: true
    userId?: true
  }

  export type ReviewCommentCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    reviewId?: true
    userId?: true
    _all?: true
  }

  export type ReviewCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewComment to aggregate.
     */
    where?: ReviewCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewComments to fetch.
     */
    orderBy?: ReviewCommentOrderByWithRelationInput | ReviewCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewComments
    **/
    _count?: true | ReviewCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewCommentMaxAggregateInputType
  }

  export type GetReviewCommentAggregateType<T extends ReviewCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewComment[P]>
      : GetScalarType<T[P], AggregateReviewComment[P]>
  }




  export type ReviewCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewCommentWhereInput
    orderBy?: ReviewCommentOrderByWithAggregationInput | ReviewCommentOrderByWithAggregationInput[]
    by: ReviewCommentScalarFieldEnum[] | ReviewCommentScalarFieldEnum
    having?: ReviewCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCommentCountAggregateInputType | true
    _avg?: ReviewCommentAvgAggregateInputType
    _sum?: ReviewCommentSumAggregateInputType
    _min?: ReviewCommentMinAggregateInputType
    _max?: ReviewCommentMaxAggregateInputType
  }

  export type ReviewCommentGroupByOutputType = {
    id: number
    content: string
    createdAt: Date
    reviewId: number
    userId: number
    _count: ReviewCommentCountAggregateOutputType | null
    _avg: ReviewCommentAvgAggregateOutputType | null
    _sum: ReviewCommentSumAggregateOutputType | null
    _min: ReviewCommentMinAggregateOutputType | null
    _max: ReviewCommentMaxAggregateOutputType | null
  }

  type GetReviewCommentGroupByPayload<T extends ReviewCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewCommentGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewCommentGroupByOutputType[P]>
        }
      >
    >


  export type ReviewCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    reviewId?: boolean
    userId?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewComment"]>

  export type ReviewCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    reviewId?: boolean
    userId?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewComment"]>

  export type ReviewCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    reviewId?: boolean
    userId?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewComment"]>

  export type ReviewCommentSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    reviewId?: boolean
    userId?: boolean
  }

  export type ReviewCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "createdAt" | "reviewId" | "userId", ExtArgs["result"]["reviewComment"]>
  export type ReviewCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewComment"
    objects: {
      review: Prisma.$ReviewPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      content: string
      createdAt: Date
      reviewId: number
      userId: number
    }, ExtArgs["result"]["reviewComment"]>
    composites: {}
  }

  type ReviewCommentGetPayload<S extends boolean | null | undefined | ReviewCommentDefaultArgs> = $Result.GetResult<Prisma.$ReviewCommentPayload, S>

  type ReviewCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCommentCountAggregateInputType | true
    }

  export interface ReviewCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewComment'], meta: { name: 'ReviewComment' } }
    /**
     * Find zero or one ReviewComment that matches the filter.
     * @param {ReviewCommentFindUniqueArgs} args - Arguments to find a ReviewComment
     * @example
     * // Get one ReviewComment
     * const reviewComment = await prisma.reviewComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewCommentFindUniqueArgs>(args: SelectSubset<T, ReviewCommentFindUniqueArgs<ExtArgs>>): Prisma__ReviewCommentClient<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReviewComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewCommentFindUniqueOrThrowArgs} args - Arguments to find a ReviewComment
     * @example
     * // Get one ReviewComment
     * const reviewComment = await prisma.reviewComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewCommentClient<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCommentFindFirstArgs} args - Arguments to find a ReviewComment
     * @example
     * // Get one ReviewComment
     * const reviewComment = await prisma.reviewComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewCommentFindFirstArgs>(args?: SelectSubset<T, ReviewCommentFindFirstArgs<ExtArgs>>): Prisma__ReviewCommentClient<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCommentFindFirstOrThrowArgs} args - Arguments to find a ReviewComment
     * @example
     * // Get one ReviewComment
     * const reviewComment = await prisma.reviewComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewCommentClient<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReviewComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewComments
     * const reviewComments = await prisma.reviewComment.findMany()
     * 
     * // Get first 10 ReviewComments
     * const reviewComments = await prisma.reviewComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewCommentWithIdOnly = await prisma.reviewComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewCommentFindManyArgs>(args?: SelectSubset<T, ReviewCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReviewComment.
     * @param {ReviewCommentCreateArgs} args - Arguments to create a ReviewComment.
     * @example
     * // Create one ReviewComment
     * const ReviewComment = await prisma.reviewComment.create({
     *   data: {
     *     // ... data to create a ReviewComment
     *   }
     * })
     * 
     */
    create<T extends ReviewCommentCreateArgs>(args: SelectSubset<T, ReviewCommentCreateArgs<ExtArgs>>): Prisma__ReviewCommentClient<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReviewComments.
     * @param {ReviewCommentCreateManyArgs} args - Arguments to create many ReviewComments.
     * @example
     * // Create many ReviewComments
     * const reviewComment = await prisma.reviewComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCommentCreateManyArgs>(args?: SelectSubset<T, ReviewCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewComments and returns the data saved in the database.
     * @param {ReviewCommentCreateManyAndReturnArgs} args - Arguments to create many ReviewComments.
     * @example
     * // Create many ReviewComments
     * const reviewComment = await prisma.reviewComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewComments and only return the `id`
     * const reviewCommentWithIdOnly = await prisma.reviewComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReviewComment.
     * @param {ReviewCommentDeleteArgs} args - Arguments to delete one ReviewComment.
     * @example
     * // Delete one ReviewComment
     * const ReviewComment = await prisma.reviewComment.delete({
     *   where: {
     *     // ... filter to delete one ReviewComment
     *   }
     * })
     * 
     */
    delete<T extends ReviewCommentDeleteArgs>(args: SelectSubset<T, ReviewCommentDeleteArgs<ExtArgs>>): Prisma__ReviewCommentClient<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReviewComment.
     * @param {ReviewCommentUpdateArgs} args - Arguments to update one ReviewComment.
     * @example
     * // Update one ReviewComment
     * const reviewComment = await prisma.reviewComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewCommentUpdateArgs>(args: SelectSubset<T, ReviewCommentUpdateArgs<ExtArgs>>): Prisma__ReviewCommentClient<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReviewComments.
     * @param {ReviewCommentDeleteManyArgs} args - Arguments to filter ReviewComments to delete.
     * @example
     * // Delete a few ReviewComments
     * const { count } = await prisma.reviewComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewCommentDeleteManyArgs>(args?: SelectSubset<T, ReviewCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewComments
     * const reviewComment = await prisma.reviewComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewCommentUpdateManyArgs>(args: SelectSubset<T, ReviewCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewComments and returns the data updated in the database.
     * @param {ReviewCommentUpdateManyAndReturnArgs} args - Arguments to update many ReviewComments.
     * @example
     * // Update many ReviewComments
     * const reviewComment = await prisma.reviewComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewComments and only return the `id`
     * const reviewCommentWithIdOnly = await prisma.reviewComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReviewComment.
     * @param {ReviewCommentUpsertArgs} args - Arguments to update or create a ReviewComment.
     * @example
     * // Update or create a ReviewComment
     * const reviewComment = await prisma.reviewComment.upsert({
     *   create: {
     *     // ... data to create a ReviewComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewComment we want to update
     *   }
     * })
     */
    upsert<T extends ReviewCommentUpsertArgs>(args: SelectSubset<T, ReviewCommentUpsertArgs<ExtArgs>>): Prisma__ReviewCommentClient<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReviewComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCommentCountArgs} args - Arguments to filter ReviewComments to count.
     * @example
     * // Count the number of ReviewComments
     * const count = await prisma.reviewComment.count({
     *   where: {
     *     // ... the filter for the ReviewComments we want to count
     *   }
     * })
    **/
    count<T extends ReviewCommentCountArgs>(
      args?: Subset<T, ReviewCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewCommentAggregateArgs>(args: Subset<T, ReviewCommentAggregateArgs>): Prisma.PrismaPromise<GetReviewCommentAggregateType<T>>

    /**
     * Group by ReviewComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewCommentGroupByArgs['orderBy'] }
        : { orderBy?: ReviewCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewComment model
   */
  readonly fields: ReviewCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    review<T extends ReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReviewDefaultArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewComment model
   */
  interface ReviewCommentFieldRefs {
    readonly id: FieldRef<"ReviewComment", 'Int'>
    readonly content: FieldRef<"ReviewComment", 'String'>
    readonly createdAt: FieldRef<"ReviewComment", 'DateTime'>
    readonly reviewId: FieldRef<"ReviewComment", 'Int'>
    readonly userId: FieldRef<"ReviewComment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ReviewComment findUnique
   */
  export type ReviewCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewComment
     */
    omit?: ReviewCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReviewComment to fetch.
     */
    where: ReviewCommentWhereUniqueInput
  }

  /**
   * ReviewComment findUniqueOrThrow
   */
  export type ReviewCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewComment
     */
    omit?: ReviewCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReviewComment to fetch.
     */
    where: ReviewCommentWhereUniqueInput
  }

  /**
   * ReviewComment findFirst
   */
  export type ReviewCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewComment
     */
    omit?: ReviewCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReviewComment to fetch.
     */
    where?: ReviewCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewComments to fetch.
     */
    orderBy?: ReviewCommentOrderByWithRelationInput | ReviewCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewComments.
     */
    cursor?: ReviewCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewComments.
     */
    distinct?: ReviewCommentScalarFieldEnum | ReviewCommentScalarFieldEnum[]
  }

  /**
   * ReviewComment findFirstOrThrow
   */
  export type ReviewCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewComment
     */
    omit?: ReviewCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReviewComment to fetch.
     */
    where?: ReviewCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewComments to fetch.
     */
    orderBy?: ReviewCommentOrderByWithRelationInput | ReviewCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewComments.
     */
    cursor?: ReviewCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewComments.
     */
    distinct?: ReviewCommentScalarFieldEnum | ReviewCommentScalarFieldEnum[]
  }

  /**
   * ReviewComment findMany
   */
  export type ReviewCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewComment
     */
    omit?: ReviewCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReviewComments to fetch.
     */
    where?: ReviewCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewComments to fetch.
     */
    orderBy?: ReviewCommentOrderByWithRelationInput | ReviewCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewComments.
     */
    cursor?: ReviewCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewComments.
     */
    skip?: number
    distinct?: ReviewCommentScalarFieldEnum | ReviewCommentScalarFieldEnum[]
  }

  /**
   * ReviewComment create
   */
  export type ReviewCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewComment
     */
    omit?: ReviewCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewComment.
     */
    data: XOR<ReviewCommentCreateInput, ReviewCommentUncheckedCreateInput>
  }

  /**
   * ReviewComment createMany
   */
  export type ReviewCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewComments.
     */
    data: ReviewCommentCreateManyInput | ReviewCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewComment createManyAndReturn
   */
  export type ReviewCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewComment
     */
    omit?: ReviewCommentOmit<ExtArgs> | null
    /**
     * The data used to create many ReviewComments.
     */
    data: ReviewCommentCreateManyInput | ReviewCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewComment update
   */
  export type ReviewCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewComment
     */
    omit?: ReviewCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewComment.
     */
    data: XOR<ReviewCommentUpdateInput, ReviewCommentUncheckedUpdateInput>
    /**
     * Choose, which ReviewComment to update.
     */
    where: ReviewCommentWhereUniqueInput
  }

  /**
   * ReviewComment updateMany
   */
  export type ReviewCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewComments.
     */
    data: XOR<ReviewCommentUpdateManyMutationInput, ReviewCommentUncheckedUpdateManyInput>
    /**
     * Filter which ReviewComments to update
     */
    where?: ReviewCommentWhereInput
    /**
     * Limit how many ReviewComments to update.
     */
    limit?: number
  }

  /**
   * ReviewComment updateManyAndReturn
   */
  export type ReviewCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewComment
     */
    omit?: ReviewCommentOmit<ExtArgs> | null
    /**
     * The data used to update ReviewComments.
     */
    data: XOR<ReviewCommentUpdateManyMutationInput, ReviewCommentUncheckedUpdateManyInput>
    /**
     * Filter which ReviewComments to update
     */
    where?: ReviewCommentWhereInput
    /**
     * Limit how many ReviewComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewComment upsert
   */
  export type ReviewCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewComment
     */
    omit?: ReviewCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewComment to update in case it exists.
     */
    where: ReviewCommentWhereUniqueInput
    /**
     * In case the ReviewComment found by the `where` argument doesn't exist, create a new ReviewComment with this data.
     */
    create: XOR<ReviewCommentCreateInput, ReviewCommentUncheckedCreateInput>
    /**
     * In case the ReviewComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewCommentUpdateInput, ReviewCommentUncheckedUpdateInput>
  }

  /**
   * ReviewComment delete
   */
  export type ReviewCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewComment
     */
    omit?: ReviewCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    /**
     * Filter which ReviewComment to delete.
     */
    where: ReviewCommentWhereUniqueInput
  }

  /**
   * ReviewComment deleteMany
   */
  export type ReviewCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewComments to delete
     */
    where?: ReviewCommentWhereInput
    /**
     * Limit how many ReviewComments to delete.
     */
    limit?: number
  }

  /**
   * ReviewComment without action
   */
  export type ReviewCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewComment
     */
    omit?: ReviewCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
  }


  /**
   * Model GameUser
   */

  export type AggregateGameUser = {
    _count: GameUserCountAggregateOutputType | null
    _avg: GameUserAvgAggregateOutputType | null
    _sum: GameUserSumAggregateOutputType | null
    _min: GameUserMinAggregateOutputType | null
    _max: GameUserMaxAggregateOutputType | null
  }

  export type GameUserAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    gameId: number | null
  }

  export type GameUserSumAggregateOutputType = {
    id: number | null
    userId: number | null
    gameId: number | null
  }

  export type GameUserMinAggregateOutputType = {
    id: number | null
    userId: number | null
    gameId: number | null
    progress: $Enums.ProgressStatus | null
  }

  export type GameUserMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    gameId: number | null
    progress: $Enums.ProgressStatus | null
  }

  export type GameUserCountAggregateOutputType = {
    id: number
    userId: number
    gameId: number
    progress: number
    _all: number
  }


  export type GameUserAvgAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
  }

  export type GameUserSumAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
  }

  export type GameUserMinAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    progress?: true
  }

  export type GameUserMaxAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    progress?: true
  }

  export type GameUserCountAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    progress?: true
    _all?: true
  }

  export type GameUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameUser to aggregate.
     */
    where?: GameUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameUsers to fetch.
     */
    orderBy?: GameUserOrderByWithRelationInput | GameUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameUsers
    **/
    _count?: true | GameUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameUserMaxAggregateInputType
  }

  export type GetGameUserAggregateType<T extends GameUserAggregateArgs> = {
        [P in keyof T & keyof AggregateGameUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameUser[P]>
      : GetScalarType<T[P], AggregateGameUser[P]>
  }




  export type GameUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameUserWhereInput
    orderBy?: GameUserOrderByWithAggregationInput | GameUserOrderByWithAggregationInput[]
    by: GameUserScalarFieldEnum[] | GameUserScalarFieldEnum
    having?: GameUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameUserCountAggregateInputType | true
    _avg?: GameUserAvgAggregateInputType
    _sum?: GameUserSumAggregateInputType
    _min?: GameUserMinAggregateInputType
    _max?: GameUserMaxAggregateInputType
  }

  export type GameUserGroupByOutputType = {
    id: number
    userId: number
    gameId: number
    progress: $Enums.ProgressStatus
    _count: GameUserCountAggregateOutputType | null
    _avg: GameUserAvgAggregateOutputType | null
    _sum: GameUserSumAggregateOutputType | null
    _min: GameUserMinAggregateOutputType | null
    _max: GameUserMaxAggregateOutputType | null
  }

  type GetGameUserGroupByPayload<T extends GameUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameUserGroupByOutputType[P]>
            : GetScalarType<T[P], GameUserGroupByOutputType[P]>
        }
      >
    >


  export type GameUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gameId?: boolean
    progress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameUser"]>

  export type GameUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gameId?: boolean
    progress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameUser"]>

  export type GameUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gameId?: boolean
    progress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameUser"]>

  export type GameUserSelectScalar = {
    id?: boolean
    userId?: boolean
    gameId?: boolean
    progress?: boolean
  }

  export type GameUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "gameId" | "progress", ExtArgs["result"]["gameUser"]>
  export type GameUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type GameUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type GameUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }

  export type $GameUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      gameId: number
      progress: $Enums.ProgressStatus
    }, ExtArgs["result"]["gameUser"]>
    composites: {}
  }

  type GameUserGetPayload<S extends boolean | null | undefined | GameUserDefaultArgs> = $Result.GetResult<Prisma.$GameUserPayload, S>

  type GameUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameUserCountAggregateInputType | true
    }

  export interface GameUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameUser'], meta: { name: 'GameUser' } }
    /**
     * Find zero or one GameUser that matches the filter.
     * @param {GameUserFindUniqueArgs} args - Arguments to find a GameUser
     * @example
     * // Get one GameUser
     * const gameUser = await prisma.gameUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameUserFindUniqueArgs>(args: SelectSubset<T, GameUserFindUniqueArgs<ExtArgs>>): Prisma__GameUserClient<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameUserFindUniqueOrThrowArgs} args - Arguments to find a GameUser
     * @example
     * // Get one GameUser
     * const gameUser = await prisma.gameUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameUserFindUniqueOrThrowArgs>(args: SelectSubset<T, GameUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameUserClient<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUserFindFirstArgs} args - Arguments to find a GameUser
     * @example
     * // Get one GameUser
     * const gameUser = await prisma.gameUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameUserFindFirstArgs>(args?: SelectSubset<T, GameUserFindFirstArgs<ExtArgs>>): Prisma__GameUserClient<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUserFindFirstOrThrowArgs} args - Arguments to find a GameUser
     * @example
     * // Get one GameUser
     * const gameUser = await prisma.gameUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameUserFindFirstOrThrowArgs>(args?: SelectSubset<T, GameUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameUserClient<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameUsers
     * const gameUsers = await prisma.gameUser.findMany()
     * 
     * // Get first 10 GameUsers
     * const gameUsers = await prisma.gameUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameUserWithIdOnly = await prisma.gameUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameUserFindManyArgs>(args?: SelectSubset<T, GameUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameUser.
     * @param {GameUserCreateArgs} args - Arguments to create a GameUser.
     * @example
     * // Create one GameUser
     * const GameUser = await prisma.gameUser.create({
     *   data: {
     *     // ... data to create a GameUser
     *   }
     * })
     * 
     */
    create<T extends GameUserCreateArgs>(args: SelectSubset<T, GameUserCreateArgs<ExtArgs>>): Prisma__GameUserClient<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameUsers.
     * @param {GameUserCreateManyArgs} args - Arguments to create many GameUsers.
     * @example
     * // Create many GameUsers
     * const gameUser = await prisma.gameUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameUserCreateManyArgs>(args?: SelectSubset<T, GameUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameUsers and returns the data saved in the database.
     * @param {GameUserCreateManyAndReturnArgs} args - Arguments to create many GameUsers.
     * @example
     * // Create many GameUsers
     * const gameUser = await prisma.gameUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameUsers and only return the `id`
     * const gameUserWithIdOnly = await prisma.gameUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameUserCreateManyAndReturnArgs>(args?: SelectSubset<T, GameUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameUser.
     * @param {GameUserDeleteArgs} args - Arguments to delete one GameUser.
     * @example
     * // Delete one GameUser
     * const GameUser = await prisma.gameUser.delete({
     *   where: {
     *     // ... filter to delete one GameUser
     *   }
     * })
     * 
     */
    delete<T extends GameUserDeleteArgs>(args: SelectSubset<T, GameUserDeleteArgs<ExtArgs>>): Prisma__GameUserClient<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameUser.
     * @param {GameUserUpdateArgs} args - Arguments to update one GameUser.
     * @example
     * // Update one GameUser
     * const gameUser = await prisma.gameUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameUserUpdateArgs>(args: SelectSubset<T, GameUserUpdateArgs<ExtArgs>>): Prisma__GameUserClient<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameUsers.
     * @param {GameUserDeleteManyArgs} args - Arguments to filter GameUsers to delete.
     * @example
     * // Delete a few GameUsers
     * const { count } = await prisma.gameUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameUserDeleteManyArgs>(args?: SelectSubset<T, GameUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameUsers
     * const gameUser = await prisma.gameUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameUserUpdateManyArgs>(args: SelectSubset<T, GameUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameUsers and returns the data updated in the database.
     * @param {GameUserUpdateManyAndReturnArgs} args - Arguments to update many GameUsers.
     * @example
     * // Update many GameUsers
     * const gameUser = await prisma.gameUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameUsers and only return the `id`
     * const gameUserWithIdOnly = await prisma.gameUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameUserUpdateManyAndReturnArgs>(args: SelectSubset<T, GameUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameUser.
     * @param {GameUserUpsertArgs} args - Arguments to update or create a GameUser.
     * @example
     * // Update or create a GameUser
     * const gameUser = await prisma.gameUser.upsert({
     *   create: {
     *     // ... data to create a GameUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameUser we want to update
     *   }
     * })
     */
    upsert<T extends GameUserUpsertArgs>(args: SelectSubset<T, GameUserUpsertArgs<ExtArgs>>): Prisma__GameUserClient<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUserCountArgs} args - Arguments to filter GameUsers to count.
     * @example
     * // Count the number of GameUsers
     * const count = await prisma.gameUser.count({
     *   where: {
     *     // ... the filter for the GameUsers we want to count
     *   }
     * })
    **/
    count<T extends GameUserCountArgs>(
      args?: Subset<T, GameUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameUserAggregateArgs>(args: Subset<T, GameUserAggregateArgs>): Prisma.PrismaPromise<GetGameUserAggregateType<T>>

    /**
     * Group by GameUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameUserGroupByArgs['orderBy'] }
        : { orderBy?: GameUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameUser model
   */
  readonly fields: GameUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameUser model
   */
  interface GameUserFieldRefs {
    readonly id: FieldRef<"GameUser", 'Int'>
    readonly userId: FieldRef<"GameUser", 'Int'>
    readonly gameId: FieldRef<"GameUser", 'Int'>
    readonly progress: FieldRef<"GameUser", 'ProgressStatus'>
  }
    

  // Custom InputTypes
  /**
   * GameUser findUnique
   */
  export type GameUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    /**
     * Filter, which GameUser to fetch.
     */
    where: GameUserWhereUniqueInput
  }

  /**
   * GameUser findUniqueOrThrow
   */
  export type GameUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    /**
     * Filter, which GameUser to fetch.
     */
    where: GameUserWhereUniqueInput
  }

  /**
   * GameUser findFirst
   */
  export type GameUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    /**
     * Filter, which GameUser to fetch.
     */
    where?: GameUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameUsers to fetch.
     */
    orderBy?: GameUserOrderByWithRelationInput | GameUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameUsers.
     */
    cursor?: GameUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameUsers.
     */
    distinct?: GameUserScalarFieldEnum | GameUserScalarFieldEnum[]
  }

  /**
   * GameUser findFirstOrThrow
   */
  export type GameUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    /**
     * Filter, which GameUser to fetch.
     */
    where?: GameUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameUsers to fetch.
     */
    orderBy?: GameUserOrderByWithRelationInput | GameUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameUsers.
     */
    cursor?: GameUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameUsers.
     */
    distinct?: GameUserScalarFieldEnum | GameUserScalarFieldEnum[]
  }

  /**
   * GameUser findMany
   */
  export type GameUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    /**
     * Filter, which GameUsers to fetch.
     */
    where?: GameUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameUsers to fetch.
     */
    orderBy?: GameUserOrderByWithRelationInput | GameUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameUsers.
     */
    cursor?: GameUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameUsers.
     */
    skip?: number
    distinct?: GameUserScalarFieldEnum | GameUserScalarFieldEnum[]
  }

  /**
   * GameUser create
   */
  export type GameUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    /**
     * The data needed to create a GameUser.
     */
    data: XOR<GameUserCreateInput, GameUserUncheckedCreateInput>
  }

  /**
   * GameUser createMany
   */
  export type GameUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameUsers.
     */
    data: GameUserCreateManyInput | GameUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameUser createManyAndReturn
   */
  export type GameUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * The data used to create many GameUsers.
     */
    data: GameUserCreateManyInput | GameUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameUser update
   */
  export type GameUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    /**
     * The data needed to update a GameUser.
     */
    data: XOR<GameUserUpdateInput, GameUserUncheckedUpdateInput>
    /**
     * Choose, which GameUser to update.
     */
    where: GameUserWhereUniqueInput
  }

  /**
   * GameUser updateMany
   */
  export type GameUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameUsers.
     */
    data: XOR<GameUserUpdateManyMutationInput, GameUserUncheckedUpdateManyInput>
    /**
     * Filter which GameUsers to update
     */
    where?: GameUserWhereInput
    /**
     * Limit how many GameUsers to update.
     */
    limit?: number
  }

  /**
   * GameUser updateManyAndReturn
   */
  export type GameUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * The data used to update GameUsers.
     */
    data: XOR<GameUserUpdateManyMutationInput, GameUserUncheckedUpdateManyInput>
    /**
     * Filter which GameUsers to update
     */
    where?: GameUserWhereInput
    /**
     * Limit how many GameUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameUser upsert
   */
  export type GameUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    /**
     * The filter to search for the GameUser to update in case it exists.
     */
    where: GameUserWhereUniqueInput
    /**
     * In case the GameUser found by the `where` argument doesn't exist, create a new GameUser with this data.
     */
    create: XOR<GameUserCreateInput, GameUserUncheckedCreateInput>
    /**
     * In case the GameUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameUserUpdateInput, GameUserUncheckedUpdateInput>
  }

  /**
   * GameUser delete
   */
  export type GameUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    /**
     * Filter which GameUser to delete.
     */
    where: GameUserWhereUniqueInput
  }

  /**
   * GameUser deleteMany
   */
  export type GameUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameUsers to delete
     */
    where?: GameUserWhereInput
    /**
     * Limit how many GameUsers to delete.
     */
    limit?: number
  }

  /**
   * GameUser without action
   */
  export type GameUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
  }


  /**
   * Model GameStatus
   */

  export type AggregateGameStatus = {
    _count: GameStatusCountAggregateOutputType | null
    _avg: GameStatusAvgAggregateOutputType | null
    _sum: GameStatusSumAggregateOutputType | null
    _min: GameStatusMinAggregateOutputType | null
    _max: GameStatusMaxAggregateOutputType | null
  }

  export type GameStatusAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type GameStatusSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type GameStatusMinAggregateOutputType = {
    id: number | null
    type: $Enums.GameStatusType | null
    userId: number | null
  }

  export type GameStatusMaxAggregateOutputType = {
    id: number | null
    type: $Enums.GameStatusType | null
    userId: number | null
  }

  export type GameStatusCountAggregateOutputType = {
    id: number
    type: number
    userId: number
    _all: number
  }


  export type GameStatusAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type GameStatusSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type GameStatusMinAggregateInputType = {
    id?: true
    type?: true
    userId?: true
  }

  export type GameStatusMaxAggregateInputType = {
    id?: true
    type?: true
    userId?: true
  }

  export type GameStatusCountAggregateInputType = {
    id?: true
    type?: true
    userId?: true
    _all?: true
  }

  export type GameStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameStatus to aggregate.
     */
    where?: GameStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameStatuses to fetch.
     */
    orderBy?: GameStatusOrderByWithRelationInput | GameStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameStatuses
    **/
    _count?: true | GameStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameStatusMaxAggregateInputType
  }

  export type GetGameStatusAggregateType<T extends GameStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateGameStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameStatus[P]>
      : GetScalarType<T[P], AggregateGameStatus[P]>
  }




  export type GameStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameStatusWhereInput
    orderBy?: GameStatusOrderByWithAggregationInput | GameStatusOrderByWithAggregationInput[]
    by: GameStatusScalarFieldEnum[] | GameStatusScalarFieldEnum
    having?: GameStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameStatusCountAggregateInputType | true
    _avg?: GameStatusAvgAggregateInputType
    _sum?: GameStatusSumAggregateInputType
    _min?: GameStatusMinAggregateInputType
    _max?: GameStatusMaxAggregateInputType
  }

  export type GameStatusGroupByOutputType = {
    id: number
    type: $Enums.GameStatusType
    userId: number
    _count: GameStatusCountAggregateOutputType | null
    _avg: GameStatusAvgAggregateOutputType | null
    _sum: GameStatusSumAggregateOutputType | null
    _min: GameStatusMinAggregateOutputType | null
    _max: GameStatusMaxAggregateOutputType | null
  }

  type GetGameStatusGroupByPayload<T extends GameStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameStatusGroupByOutputType[P]>
            : GetScalarType<T[P], GameStatusGroupByOutputType[P]>
        }
      >
    >


  export type GameStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    userId?: boolean
    games?: boolean | GameStatus$gamesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | GameStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameStatus"]>

  export type GameStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameStatus"]>

  export type GameStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameStatus"]>

  export type GameStatusSelectScalar = {
    id?: boolean
    type?: boolean
    userId?: boolean
  }

  export type GameStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "userId", ExtArgs["result"]["gameStatus"]>
  export type GameStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | GameStatus$gamesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | GameStatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GameStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GameStatusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GameStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameStatus"
    objects: {
      games: Prisma.$GamePayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.GameStatusType
      userId: number
    }, ExtArgs["result"]["gameStatus"]>
    composites: {}
  }

  type GameStatusGetPayload<S extends boolean | null | undefined | GameStatusDefaultArgs> = $Result.GetResult<Prisma.$GameStatusPayload, S>

  type GameStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameStatusCountAggregateInputType | true
    }

  export interface GameStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameStatus'], meta: { name: 'GameStatus' } }
    /**
     * Find zero or one GameStatus that matches the filter.
     * @param {GameStatusFindUniqueArgs} args - Arguments to find a GameStatus
     * @example
     * // Get one GameStatus
     * const gameStatus = await prisma.gameStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameStatusFindUniqueArgs>(args: SelectSubset<T, GameStatusFindUniqueArgs<ExtArgs>>): Prisma__GameStatusClient<$Result.GetResult<Prisma.$GameStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameStatusFindUniqueOrThrowArgs} args - Arguments to find a GameStatus
     * @example
     * // Get one GameStatus
     * const gameStatus = await prisma.gameStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, GameStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameStatusClient<$Result.GetResult<Prisma.$GameStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameStatusFindFirstArgs} args - Arguments to find a GameStatus
     * @example
     * // Get one GameStatus
     * const gameStatus = await prisma.gameStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameStatusFindFirstArgs>(args?: SelectSubset<T, GameStatusFindFirstArgs<ExtArgs>>): Prisma__GameStatusClient<$Result.GetResult<Prisma.$GameStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameStatusFindFirstOrThrowArgs} args - Arguments to find a GameStatus
     * @example
     * // Get one GameStatus
     * const gameStatus = await prisma.gameStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, GameStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameStatusClient<$Result.GetResult<Prisma.$GameStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameStatuses
     * const gameStatuses = await prisma.gameStatus.findMany()
     * 
     * // Get first 10 GameStatuses
     * const gameStatuses = await prisma.gameStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameStatusWithIdOnly = await prisma.gameStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameStatusFindManyArgs>(args?: SelectSubset<T, GameStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameStatus.
     * @param {GameStatusCreateArgs} args - Arguments to create a GameStatus.
     * @example
     * // Create one GameStatus
     * const GameStatus = await prisma.gameStatus.create({
     *   data: {
     *     // ... data to create a GameStatus
     *   }
     * })
     * 
     */
    create<T extends GameStatusCreateArgs>(args: SelectSubset<T, GameStatusCreateArgs<ExtArgs>>): Prisma__GameStatusClient<$Result.GetResult<Prisma.$GameStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameStatuses.
     * @param {GameStatusCreateManyArgs} args - Arguments to create many GameStatuses.
     * @example
     * // Create many GameStatuses
     * const gameStatus = await prisma.gameStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameStatusCreateManyArgs>(args?: SelectSubset<T, GameStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameStatuses and returns the data saved in the database.
     * @param {GameStatusCreateManyAndReturnArgs} args - Arguments to create many GameStatuses.
     * @example
     * // Create many GameStatuses
     * const gameStatus = await prisma.gameStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameStatuses and only return the `id`
     * const gameStatusWithIdOnly = await prisma.gameStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, GameStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameStatus.
     * @param {GameStatusDeleteArgs} args - Arguments to delete one GameStatus.
     * @example
     * // Delete one GameStatus
     * const GameStatus = await prisma.gameStatus.delete({
     *   where: {
     *     // ... filter to delete one GameStatus
     *   }
     * })
     * 
     */
    delete<T extends GameStatusDeleteArgs>(args: SelectSubset<T, GameStatusDeleteArgs<ExtArgs>>): Prisma__GameStatusClient<$Result.GetResult<Prisma.$GameStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameStatus.
     * @param {GameStatusUpdateArgs} args - Arguments to update one GameStatus.
     * @example
     * // Update one GameStatus
     * const gameStatus = await prisma.gameStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameStatusUpdateArgs>(args: SelectSubset<T, GameStatusUpdateArgs<ExtArgs>>): Prisma__GameStatusClient<$Result.GetResult<Prisma.$GameStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameStatuses.
     * @param {GameStatusDeleteManyArgs} args - Arguments to filter GameStatuses to delete.
     * @example
     * // Delete a few GameStatuses
     * const { count } = await prisma.gameStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameStatusDeleteManyArgs>(args?: SelectSubset<T, GameStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameStatuses
     * const gameStatus = await prisma.gameStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameStatusUpdateManyArgs>(args: SelectSubset<T, GameStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameStatuses and returns the data updated in the database.
     * @param {GameStatusUpdateManyAndReturnArgs} args - Arguments to update many GameStatuses.
     * @example
     * // Update many GameStatuses
     * const gameStatus = await prisma.gameStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameStatuses and only return the `id`
     * const gameStatusWithIdOnly = await prisma.gameStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, GameStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameStatus.
     * @param {GameStatusUpsertArgs} args - Arguments to update or create a GameStatus.
     * @example
     * // Update or create a GameStatus
     * const gameStatus = await prisma.gameStatus.upsert({
     *   create: {
     *     // ... data to create a GameStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameStatus we want to update
     *   }
     * })
     */
    upsert<T extends GameStatusUpsertArgs>(args: SelectSubset<T, GameStatusUpsertArgs<ExtArgs>>): Prisma__GameStatusClient<$Result.GetResult<Prisma.$GameStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameStatusCountArgs} args - Arguments to filter GameStatuses to count.
     * @example
     * // Count the number of GameStatuses
     * const count = await prisma.gameStatus.count({
     *   where: {
     *     // ... the filter for the GameStatuses we want to count
     *   }
     * })
    **/
    count<T extends GameStatusCountArgs>(
      args?: Subset<T, GameStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameStatusAggregateArgs>(args: Subset<T, GameStatusAggregateArgs>): Prisma.PrismaPromise<GetGameStatusAggregateType<T>>

    /**
     * Group by GameStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameStatusGroupByArgs['orderBy'] }
        : { orderBy?: GameStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameStatus model
   */
  readonly fields: GameStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    games<T extends GameStatus$gamesArgs<ExtArgs> = {}>(args?: Subset<T, GameStatus$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameStatus model
   */
  interface GameStatusFieldRefs {
    readonly id: FieldRef<"GameStatus", 'Int'>
    readonly type: FieldRef<"GameStatus", 'GameStatusType'>
    readonly userId: FieldRef<"GameStatus", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * GameStatus findUnique
   */
  export type GameStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatus
     */
    select?: GameStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatus
     */
    omit?: GameStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatusInclude<ExtArgs> | null
    /**
     * Filter, which GameStatus to fetch.
     */
    where: GameStatusWhereUniqueInput
  }

  /**
   * GameStatus findUniqueOrThrow
   */
  export type GameStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatus
     */
    select?: GameStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatus
     */
    omit?: GameStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatusInclude<ExtArgs> | null
    /**
     * Filter, which GameStatus to fetch.
     */
    where: GameStatusWhereUniqueInput
  }

  /**
   * GameStatus findFirst
   */
  export type GameStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatus
     */
    select?: GameStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatus
     */
    omit?: GameStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatusInclude<ExtArgs> | null
    /**
     * Filter, which GameStatus to fetch.
     */
    where?: GameStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameStatuses to fetch.
     */
    orderBy?: GameStatusOrderByWithRelationInput | GameStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameStatuses.
     */
    cursor?: GameStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameStatuses.
     */
    distinct?: GameStatusScalarFieldEnum | GameStatusScalarFieldEnum[]
  }

  /**
   * GameStatus findFirstOrThrow
   */
  export type GameStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatus
     */
    select?: GameStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatus
     */
    omit?: GameStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatusInclude<ExtArgs> | null
    /**
     * Filter, which GameStatus to fetch.
     */
    where?: GameStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameStatuses to fetch.
     */
    orderBy?: GameStatusOrderByWithRelationInput | GameStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameStatuses.
     */
    cursor?: GameStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameStatuses.
     */
    distinct?: GameStatusScalarFieldEnum | GameStatusScalarFieldEnum[]
  }

  /**
   * GameStatus findMany
   */
  export type GameStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatus
     */
    select?: GameStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatus
     */
    omit?: GameStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatusInclude<ExtArgs> | null
    /**
     * Filter, which GameStatuses to fetch.
     */
    where?: GameStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameStatuses to fetch.
     */
    orderBy?: GameStatusOrderByWithRelationInput | GameStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameStatuses.
     */
    cursor?: GameStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameStatuses.
     */
    skip?: number
    distinct?: GameStatusScalarFieldEnum | GameStatusScalarFieldEnum[]
  }

  /**
   * GameStatus create
   */
  export type GameStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatus
     */
    select?: GameStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatus
     */
    omit?: GameStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a GameStatus.
     */
    data: XOR<GameStatusCreateInput, GameStatusUncheckedCreateInput>
  }

  /**
   * GameStatus createMany
   */
  export type GameStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameStatuses.
     */
    data: GameStatusCreateManyInput | GameStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameStatus createManyAndReturn
   */
  export type GameStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatus
     */
    select?: GameStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatus
     */
    omit?: GameStatusOmit<ExtArgs> | null
    /**
     * The data used to create many GameStatuses.
     */
    data: GameStatusCreateManyInput | GameStatusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameStatus update
   */
  export type GameStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatus
     */
    select?: GameStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatus
     */
    omit?: GameStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a GameStatus.
     */
    data: XOR<GameStatusUpdateInput, GameStatusUncheckedUpdateInput>
    /**
     * Choose, which GameStatus to update.
     */
    where: GameStatusWhereUniqueInput
  }

  /**
   * GameStatus updateMany
   */
  export type GameStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameStatuses.
     */
    data: XOR<GameStatusUpdateManyMutationInput, GameStatusUncheckedUpdateManyInput>
    /**
     * Filter which GameStatuses to update
     */
    where?: GameStatusWhereInput
    /**
     * Limit how many GameStatuses to update.
     */
    limit?: number
  }

  /**
   * GameStatus updateManyAndReturn
   */
  export type GameStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatus
     */
    select?: GameStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatus
     */
    omit?: GameStatusOmit<ExtArgs> | null
    /**
     * The data used to update GameStatuses.
     */
    data: XOR<GameStatusUpdateManyMutationInput, GameStatusUncheckedUpdateManyInput>
    /**
     * Filter which GameStatuses to update
     */
    where?: GameStatusWhereInput
    /**
     * Limit how many GameStatuses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameStatus upsert
   */
  export type GameStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatus
     */
    select?: GameStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatus
     */
    omit?: GameStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the GameStatus to update in case it exists.
     */
    where: GameStatusWhereUniqueInput
    /**
     * In case the GameStatus found by the `where` argument doesn't exist, create a new GameStatus with this data.
     */
    create: XOR<GameStatusCreateInput, GameStatusUncheckedCreateInput>
    /**
     * In case the GameStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameStatusUpdateInput, GameStatusUncheckedUpdateInput>
  }

  /**
   * GameStatus delete
   */
  export type GameStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatus
     */
    select?: GameStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatus
     */
    omit?: GameStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatusInclude<ExtArgs> | null
    /**
     * Filter which GameStatus to delete.
     */
    where: GameStatusWhereUniqueInput
  }

  /**
   * GameStatus deleteMany
   */
  export type GameStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameStatuses to delete
     */
    where?: GameStatusWhereInput
    /**
     * Limit how many GameStatuses to delete.
     */
    limit?: number
  }

  /**
   * GameStatus.games
   */
  export type GameStatus$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * GameStatus without action
   */
  export type GameStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatus
     */
    select?: GameStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatus
     */
    omit?: GameStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatusInclude<ExtArgs> | null
  }


  /**
   * Model UserTag
   */

  export type AggregateUserTag = {
    _count: UserTagCountAggregateOutputType | null
    _avg: UserTagAvgAggregateOutputType | null
    _sum: UserTagSumAggregateOutputType | null
    _min: UserTagMinAggregateOutputType | null
    _max: UserTagMaxAggregateOutputType | null
  }

  export type UserTagAvgAggregateOutputType = {
    id: number | null
  }

  export type UserTagSumAggregateOutputType = {
    id: number | null
  }

  export type UserTagMinAggregateOutputType = {
    id: number | null
    label: string | null
  }

  export type UserTagMaxAggregateOutputType = {
    id: number | null
    label: string | null
  }

  export type UserTagCountAggregateOutputType = {
    id: number
    label: number
    _all: number
  }


  export type UserTagAvgAggregateInputType = {
    id?: true
  }

  export type UserTagSumAggregateInputType = {
    id?: true
  }

  export type UserTagMinAggregateInputType = {
    id?: true
    label?: true
  }

  export type UserTagMaxAggregateInputType = {
    id?: true
    label?: true
  }

  export type UserTagCountAggregateInputType = {
    id?: true
    label?: true
    _all?: true
  }

  export type UserTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTag to aggregate.
     */
    where?: UserTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagOrderByWithRelationInput | UserTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTags
    **/
    _count?: true | UserTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTagMaxAggregateInputType
  }

  export type GetUserTagAggregateType<T extends UserTagAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTag[P]>
      : GetScalarType<T[P], AggregateUserTag[P]>
  }




  export type UserTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTagWhereInput
    orderBy?: UserTagOrderByWithAggregationInput | UserTagOrderByWithAggregationInput[]
    by: UserTagScalarFieldEnum[] | UserTagScalarFieldEnum
    having?: UserTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTagCountAggregateInputType | true
    _avg?: UserTagAvgAggregateInputType
    _sum?: UserTagSumAggregateInputType
    _min?: UserTagMinAggregateInputType
    _max?: UserTagMaxAggregateInputType
  }

  export type UserTagGroupByOutputType = {
    id: number
    label: string
    _count: UserTagCountAggregateOutputType | null
    _avg: UserTagAvgAggregateOutputType | null
    _sum: UserTagSumAggregateOutputType | null
    _min: UserTagMinAggregateOutputType | null
    _max: UserTagMaxAggregateOutputType | null
  }

  type GetUserTagGroupByPayload<T extends UserTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTagGroupByOutputType[P]>
            : GetScalarType<T[P], UserTagGroupByOutputType[P]>
        }
      >
    >


  export type UserTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    users?: boolean | UserTag$usersArgs<ExtArgs>
    _count?: boolean | UserTagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTag"]>

  export type UserTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
  }, ExtArgs["result"]["userTag"]>

  export type UserTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
  }, ExtArgs["result"]["userTag"]>

  export type UserTagSelectScalar = {
    id?: boolean
    label?: boolean
  }

  export type UserTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label", ExtArgs["result"]["userTag"]>
  export type UserTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserTag$usersArgs<ExtArgs>
    _count?: boolean | UserTagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTag"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      label: string
    }, ExtArgs["result"]["userTag"]>
    composites: {}
  }

  type UserTagGetPayload<S extends boolean | null | undefined | UserTagDefaultArgs> = $Result.GetResult<Prisma.$UserTagPayload, S>

  type UserTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserTagCountAggregateInputType | true
    }

  export interface UserTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTag'], meta: { name: 'UserTag' } }
    /**
     * Find zero or one UserTag that matches the filter.
     * @param {UserTagFindUniqueArgs} args - Arguments to find a UserTag
     * @example
     * // Get one UserTag
     * const userTag = await prisma.userTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTagFindUniqueArgs>(args: SelectSubset<T, UserTagFindUniqueArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserTagFindUniqueOrThrowArgs} args - Arguments to find a UserTag
     * @example
     * // Get one UserTag
     * const userTag = await prisma.userTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTagFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagFindFirstArgs} args - Arguments to find a UserTag
     * @example
     * // Get one UserTag
     * const userTag = await prisma.userTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTagFindFirstArgs>(args?: SelectSubset<T, UserTagFindFirstArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagFindFirstOrThrowArgs} args - Arguments to find a UserTag
     * @example
     * // Get one UserTag
     * const userTag = await prisma.userTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTagFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTags
     * const userTags = await prisma.userTag.findMany()
     * 
     * // Get first 10 UserTags
     * const userTags = await prisma.userTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTagWithIdOnly = await prisma.userTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserTagFindManyArgs>(args?: SelectSubset<T, UserTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserTag.
     * @param {UserTagCreateArgs} args - Arguments to create a UserTag.
     * @example
     * // Create one UserTag
     * const UserTag = await prisma.userTag.create({
     *   data: {
     *     // ... data to create a UserTag
     *   }
     * })
     * 
     */
    create<T extends UserTagCreateArgs>(args: SelectSubset<T, UserTagCreateArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserTags.
     * @param {UserTagCreateManyArgs} args - Arguments to create many UserTags.
     * @example
     * // Create many UserTags
     * const userTag = await prisma.userTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTagCreateManyArgs>(args?: SelectSubset<T, UserTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserTags and returns the data saved in the database.
     * @param {UserTagCreateManyAndReturnArgs} args - Arguments to create many UserTags.
     * @example
     * // Create many UserTags
     * const userTag = await prisma.userTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserTags and only return the `id`
     * const userTagWithIdOnly = await prisma.userTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserTagCreateManyAndReturnArgs>(args?: SelectSubset<T, UserTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserTag.
     * @param {UserTagDeleteArgs} args - Arguments to delete one UserTag.
     * @example
     * // Delete one UserTag
     * const UserTag = await prisma.userTag.delete({
     *   where: {
     *     // ... filter to delete one UserTag
     *   }
     * })
     * 
     */
    delete<T extends UserTagDeleteArgs>(args: SelectSubset<T, UserTagDeleteArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserTag.
     * @param {UserTagUpdateArgs} args - Arguments to update one UserTag.
     * @example
     * // Update one UserTag
     * const userTag = await prisma.userTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTagUpdateArgs>(args: SelectSubset<T, UserTagUpdateArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserTags.
     * @param {UserTagDeleteManyArgs} args - Arguments to filter UserTags to delete.
     * @example
     * // Delete a few UserTags
     * const { count } = await prisma.userTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTagDeleteManyArgs>(args?: SelectSubset<T, UserTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTags
     * const userTag = await prisma.userTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTagUpdateManyArgs>(args: SelectSubset<T, UserTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTags and returns the data updated in the database.
     * @param {UserTagUpdateManyAndReturnArgs} args - Arguments to update many UserTags.
     * @example
     * // Update many UserTags
     * const userTag = await prisma.userTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserTags and only return the `id`
     * const userTagWithIdOnly = await prisma.userTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserTagUpdateManyAndReturnArgs>(args: SelectSubset<T, UserTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserTag.
     * @param {UserTagUpsertArgs} args - Arguments to update or create a UserTag.
     * @example
     * // Update or create a UserTag
     * const userTag = await prisma.userTag.upsert({
     *   create: {
     *     // ... data to create a UserTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTag we want to update
     *   }
     * })
     */
    upsert<T extends UserTagUpsertArgs>(args: SelectSubset<T, UserTagUpsertArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagCountArgs} args - Arguments to filter UserTags to count.
     * @example
     * // Count the number of UserTags
     * const count = await prisma.userTag.count({
     *   where: {
     *     // ... the filter for the UserTags we want to count
     *   }
     * })
    **/
    count<T extends UserTagCountArgs>(
      args?: Subset<T, UserTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTagAggregateArgs>(args: Subset<T, UserTagAggregateArgs>): Prisma.PrismaPromise<GetUserTagAggregateType<T>>

    /**
     * Group by UserTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTagGroupByArgs['orderBy'] }
        : { orderBy?: UserTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTag model
   */
  readonly fields: UserTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UserTag$usersArgs<ExtArgs> = {}>(args?: Subset<T, UserTag$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTag model
   */
  interface UserTagFieldRefs {
    readonly id: FieldRef<"UserTag", 'Int'>
    readonly label: FieldRef<"UserTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserTag findUnique
   */
  export type UserTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * Filter, which UserTag to fetch.
     */
    where: UserTagWhereUniqueInput
  }

  /**
   * UserTag findUniqueOrThrow
   */
  export type UserTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * Filter, which UserTag to fetch.
     */
    where: UserTagWhereUniqueInput
  }

  /**
   * UserTag findFirst
   */
  export type UserTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * Filter, which UserTag to fetch.
     */
    where?: UserTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagOrderByWithRelationInput | UserTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTags.
     */
    cursor?: UserTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTags.
     */
    distinct?: UserTagScalarFieldEnum | UserTagScalarFieldEnum[]
  }

  /**
   * UserTag findFirstOrThrow
   */
  export type UserTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * Filter, which UserTag to fetch.
     */
    where?: UserTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagOrderByWithRelationInput | UserTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTags.
     */
    cursor?: UserTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTags.
     */
    distinct?: UserTagScalarFieldEnum | UserTagScalarFieldEnum[]
  }

  /**
   * UserTag findMany
   */
  export type UserTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * Filter, which UserTags to fetch.
     */
    where?: UserTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagOrderByWithRelationInput | UserTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTags.
     */
    cursor?: UserTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    distinct?: UserTagScalarFieldEnum | UserTagScalarFieldEnum[]
  }

  /**
   * UserTag create
   */
  export type UserTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTag.
     */
    data: XOR<UserTagCreateInput, UserTagUncheckedCreateInput>
  }

  /**
   * UserTag createMany
   */
  export type UserTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTags.
     */
    data: UserTagCreateManyInput | UserTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTag createManyAndReturn
   */
  export type UserTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * The data used to create many UserTags.
     */
    data: UserTagCreateManyInput | UserTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTag update
   */
  export type UserTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTag.
     */
    data: XOR<UserTagUpdateInput, UserTagUncheckedUpdateInput>
    /**
     * Choose, which UserTag to update.
     */
    where: UserTagWhereUniqueInput
  }

  /**
   * UserTag updateMany
   */
  export type UserTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTags.
     */
    data: XOR<UserTagUpdateManyMutationInput, UserTagUncheckedUpdateManyInput>
    /**
     * Filter which UserTags to update
     */
    where?: UserTagWhereInput
    /**
     * Limit how many UserTags to update.
     */
    limit?: number
  }

  /**
   * UserTag updateManyAndReturn
   */
  export type UserTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * The data used to update UserTags.
     */
    data: XOR<UserTagUpdateManyMutationInput, UserTagUncheckedUpdateManyInput>
    /**
     * Filter which UserTags to update
     */
    where?: UserTagWhereInput
    /**
     * Limit how many UserTags to update.
     */
    limit?: number
  }

  /**
   * UserTag upsert
   */
  export type UserTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTag to update in case it exists.
     */
    where: UserTagWhereUniqueInput
    /**
     * In case the UserTag found by the `where` argument doesn't exist, create a new UserTag with this data.
     */
    create: XOR<UserTagCreateInput, UserTagUncheckedCreateInput>
    /**
     * In case the UserTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTagUpdateInput, UserTagUncheckedUpdateInput>
  }

  /**
   * UserTag delete
   */
  export type UserTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * Filter which UserTag to delete.
     */
    where: UserTagWhereUniqueInput
  }

  /**
   * UserTag deleteMany
   */
  export type UserTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTags to delete
     */
    where?: UserTagWhereInput
    /**
     * Limit how many UserTags to delete.
     */
    limit?: number
  }

  /**
   * UserTag.users
   */
  export type UserTag$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * UserTag without action
   */
  export type UserTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
  }


  /**
   * Model GameTag
   */

  export type AggregateGameTag = {
    _count: GameTagCountAggregateOutputType | null
    _avg: GameTagAvgAggregateOutputType | null
    _sum: GameTagSumAggregateOutputType | null
    _min: GameTagMinAggregateOutputType | null
    _max: GameTagMaxAggregateOutputType | null
  }

  export type GameTagAvgAggregateOutputType = {
    id: number | null
  }

  export type GameTagSumAggregateOutputType = {
    id: number | null
  }

  export type GameTagMinAggregateOutputType = {
    id: number | null
    label: string | null
  }

  export type GameTagMaxAggregateOutputType = {
    id: number | null
    label: string | null
  }

  export type GameTagCountAggregateOutputType = {
    id: number
    label: number
    _all: number
  }


  export type GameTagAvgAggregateInputType = {
    id?: true
  }

  export type GameTagSumAggregateInputType = {
    id?: true
  }

  export type GameTagMinAggregateInputType = {
    id?: true
    label?: true
  }

  export type GameTagMaxAggregateInputType = {
    id?: true
    label?: true
  }

  export type GameTagCountAggregateInputType = {
    id?: true
    label?: true
    _all?: true
  }

  export type GameTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameTag to aggregate.
     */
    where?: GameTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameTags to fetch.
     */
    orderBy?: GameTagOrderByWithRelationInput | GameTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameTags
    **/
    _count?: true | GameTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameTagMaxAggregateInputType
  }

  export type GetGameTagAggregateType<T extends GameTagAggregateArgs> = {
        [P in keyof T & keyof AggregateGameTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameTag[P]>
      : GetScalarType<T[P], AggregateGameTag[P]>
  }




  export type GameTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameTagWhereInput
    orderBy?: GameTagOrderByWithAggregationInput | GameTagOrderByWithAggregationInput[]
    by: GameTagScalarFieldEnum[] | GameTagScalarFieldEnum
    having?: GameTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameTagCountAggregateInputType | true
    _avg?: GameTagAvgAggregateInputType
    _sum?: GameTagSumAggregateInputType
    _min?: GameTagMinAggregateInputType
    _max?: GameTagMaxAggregateInputType
  }

  export type GameTagGroupByOutputType = {
    id: number
    label: string
    _count: GameTagCountAggregateOutputType | null
    _avg: GameTagAvgAggregateOutputType | null
    _sum: GameTagSumAggregateOutputType | null
    _min: GameTagMinAggregateOutputType | null
    _max: GameTagMaxAggregateOutputType | null
  }

  type GetGameTagGroupByPayload<T extends GameTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameTagGroupByOutputType[P]>
            : GetScalarType<T[P], GameTagGroupByOutputType[P]>
        }
      >
    >


  export type GameTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    games?: boolean | GameTag$gamesArgs<ExtArgs>
    _count?: boolean | GameTagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameTag"]>

  export type GameTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
  }, ExtArgs["result"]["gameTag"]>

  export type GameTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
  }, ExtArgs["result"]["gameTag"]>

  export type GameTagSelectScalar = {
    id?: boolean
    label?: boolean
  }

  export type GameTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label", ExtArgs["result"]["gameTag"]>
  export type GameTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | GameTag$gamesArgs<ExtArgs>
    _count?: boolean | GameTagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GameTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GameTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GameTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameTag"
    objects: {
      games: Prisma.$GamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      label: string
    }, ExtArgs["result"]["gameTag"]>
    composites: {}
  }

  type GameTagGetPayload<S extends boolean | null | undefined | GameTagDefaultArgs> = $Result.GetResult<Prisma.$GameTagPayload, S>

  type GameTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameTagCountAggregateInputType | true
    }

  export interface GameTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameTag'], meta: { name: 'GameTag' } }
    /**
     * Find zero or one GameTag that matches the filter.
     * @param {GameTagFindUniqueArgs} args - Arguments to find a GameTag
     * @example
     * // Get one GameTag
     * const gameTag = await prisma.gameTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameTagFindUniqueArgs>(args: SelectSubset<T, GameTagFindUniqueArgs<ExtArgs>>): Prisma__GameTagClient<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameTagFindUniqueOrThrowArgs} args - Arguments to find a GameTag
     * @example
     * // Get one GameTag
     * const gameTag = await prisma.gameTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameTagFindUniqueOrThrowArgs>(args: SelectSubset<T, GameTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameTagClient<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameTagFindFirstArgs} args - Arguments to find a GameTag
     * @example
     * // Get one GameTag
     * const gameTag = await prisma.gameTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameTagFindFirstArgs>(args?: SelectSubset<T, GameTagFindFirstArgs<ExtArgs>>): Prisma__GameTagClient<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameTagFindFirstOrThrowArgs} args - Arguments to find a GameTag
     * @example
     * // Get one GameTag
     * const gameTag = await prisma.gameTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameTagFindFirstOrThrowArgs>(args?: SelectSubset<T, GameTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameTagClient<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameTags
     * const gameTags = await prisma.gameTag.findMany()
     * 
     * // Get first 10 GameTags
     * const gameTags = await prisma.gameTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameTagWithIdOnly = await prisma.gameTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameTagFindManyArgs>(args?: SelectSubset<T, GameTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameTag.
     * @param {GameTagCreateArgs} args - Arguments to create a GameTag.
     * @example
     * // Create one GameTag
     * const GameTag = await prisma.gameTag.create({
     *   data: {
     *     // ... data to create a GameTag
     *   }
     * })
     * 
     */
    create<T extends GameTagCreateArgs>(args: SelectSubset<T, GameTagCreateArgs<ExtArgs>>): Prisma__GameTagClient<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameTags.
     * @param {GameTagCreateManyArgs} args - Arguments to create many GameTags.
     * @example
     * // Create many GameTags
     * const gameTag = await prisma.gameTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameTagCreateManyArgs>(args?: SelectSubset<T, GameTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameTags and returns the data saved in the database.
     * @param {GameTagCreateManyAndReturnArgs} args - Arguments to create many GameTags.
     * @example
     * // Create many GameTags
     * const gameTag = await prisma.gameTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameTags and only return the `id`
     * const gameTagWithIdOnly = await prisma.gameTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameTagCreateManyAndReturnArgs>(args?: SelectSubset<T, GameTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameTag.
     * @param {GameTagDeleteArgs} args - Arguments to delete one GameTag.
     * @example
     * // Delete one GameTag
     * const GameTag = await prisma.gameTag.delete({
     *   where: {
     *     // ... filter to delete one GameTag
     *   }
     * })
     * 
     */
    delete<T extends GameTagDeleteArgs>(args: SelectSubset<T, GameTagDeleteArgs<ExtArgs>>): Prisma__GameTagClient<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameTag.
     * @param {GameTagUpdateArgs} args - Arguments to update one GameTag.
     * @example
     * // Update one GameTag
     * const gameTag = await prisma.gameTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameTagUpdateArgs>(args: SelectSubset<T, GameTagUpdateArgs<ExtArgs>>): Prisma__GameTagClient<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameTags.
     * @param {GameTagDeleteManyArgs} args - Arguments to filter GameTags to delete.
     * @example
     * // Delete a few GameTags
     * const { count } = await prisma.gameTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameTagDeleteManyArgs>(args?: SelectSubset<T, GameTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameTags
     * const gameTag = await prisma.gameTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameTagUpdateManyArgs>(args: SelectSubset<T, GameTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameTags and returns the data updated in the database.
     * @param {GameTagUpdateManyAndReturnArgs} args - Arguments to update many GameTags.
     * @example
     * // Update many GameTags
     * const gameTag = await prisma.gameTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameTags and only return the `id`
     * const gameTagWithIdOnly = await prisma.gameTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameTagUpdateManyAndReturnArgs>(args: SelectSubset<T, GameTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameTag.
     * @param {GameTagUpsertArgs} args - Arguments to update or create a GameTag.
     * @example
     * // Update or create a GameTag
     * const gameTag = await prisma.gameTag.upsert({
     *   create: {
     *     // ... data to create a GameTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameTag we want to update
     *   }
     * })
     */
    upsert<T extends GameTagUpsertArgs>(args: SelectSubset<T, GameTagUpsertArgs<ExtArgs>>): Prisma__GameTagClient<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameTagCountArgs} args - Arguments to filter GameTags to count.
     * @example
     * // Count the number of GameTags
     * const count = await prisma.gameTag.count({
     *   where: {
     *     // ... the filter for the GameTags we want to count
     *   }
     * })
    **/
    count<T extends GameTagCountArgs>(
      args?: Subset<T, GameTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameTagAggregateArgs>(args: Subset<T, GameTagAggregateArgs>): Prisma.PrismaPromise<GetGameTagAggregateType<T>>

    /**
     * Group by GameTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameTagGroupByArgs['orderBy'] }
        : { orderBy?: GameTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameTag model
   */
  readonly fields: GameTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    games<T extends GameTag$gamesArgs<ExtArgs> = {}>(args?: Subset<T, GameTag$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameTag model
   */
  interface GameTagFieldRefs {
    readonly id: FieldRef<"GameTag", 'Int'>
    readonly label: FieldRef<"GameTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GameTag findUnique
   */
  export type GameTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
    /**
     * Filter, which GameTag to fetch.
     */
    where: GameTagWhereUniqueInput
  }

  /**
   * GameTag findUniqueOrThrow
   */
  export type GameTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
    /**
     * Filter, which GameTag to fetch.
     */
    where: GameTagWhereUniqueInput
  }

  /**
   * GameTag findFirst
   */
  export type GameTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
    /**
     * Filter, which GameTag to fetch.
     */
    where?: GameTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameTags to fetch.
     */
    orderBy?: GameTagOrderByWithRelationInput | GameTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameTags.
     */
    cursor?: GameTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameTags.
     */
    distinct?: GameTagScalarFieldEnum | GameTagScalarFieldEnum[]
  }

  /**
   * GameTag findFirstOrThrow
   */
  export type GameTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
    /**
     * Filter, which GameTag to fetch.
     */
    where?: GameTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameTags to fetch.
     */
    orderBy?: GameTagOrderByWithRelationInput | GameTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameTags.
     */
    cursor?: GameTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameTags.
     */
    distinct?: GameTagScalarFieldEnum | GameTagScalarFieldEnum[]
  }

  /**
   * GameTag findMany
   */
  export type GameTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
    /**
     * Filter, which GameTags to fetch.
     */
    where?: GameTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameTags to fetch.
     */
    orderBy?: GameTagOrderByWithRelationInput | GameTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameTags.
     */
    cursor?: GameTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameTags.
     */
    skip?: number
    distinct?: GameTagScalarFieldEnum | GameTagScalarFieldEnum[]
  }

  /**
   * GameTag create
   */
  export type GameTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
    /**
     * The data needed to create a GameTag.
     */
    data: XOR<GameTagCreateInput, GameTagUncheckedCreateInput>
  }

  /**
   * GameTag createMany
   */
  export type GameTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameTags.
     */
    data: GameTagCreateManyInput | GameTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameTag createManyAndReturn
   */
  export type GameTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * The data used to create many GameTags.
     */
    data: GameTagCreateManyInput | GameTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameTag update
   */
  export type GameTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
    /**
     * The data needed to update a GameTag.
     */
    data: XOR<GameTagUpdateInput, GameTagUncheckedUpdateInput>
    /**
     * Choose, which GameTag to update.
     */
    where: GameTagWhereUniqueInput
  }

  /**
   * GameTag updateMany
   */
  export type GameTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameTags.
     */
    data: XOR<GameTagUpdateManyMutationInput, GameTagUncheckedUpdateManyInput>
    /**
     * Filter which GameTags to update
     */
    where?: GameTagWhereInput
    /**
     * Limit how many GameTags to update.
     */
    limit?: number
  }

  /**
   * GameTag updateManyAndReturn
   */
  export type GameTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * The data used to update GameTags.
     */
    data: XOR<GameTagUpdateManyMutationInput, GameTagUncheckedUpdateManyInput>
    /**
     * Filter which GameTags to update
     */
    where?: GameTagWhereInput
    /**
     * Limit how many GameTags to update.
     */
    limit?: number
  }

  /**
   * GameTag upsert
   */
  export type GameTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
    /**
     * The filter to search for the GameTag to update in case it exists.
     */
    where: GameTagWhereUniqueInput
    /**
     * In case the GameTag found by the `where` argument doesn't exist, create a new GameTag with this data.
     */
    create: XOR<GameTagCreateInput, GameTagUncheckedCreateInput>
    /**
     * In case the GameTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameTagUpdateInput, GameTagUncheckedUpdateInput>
  }

  /**
   * GameTag delete
   */
  export type GameTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
    /**
     * Filter which GameTag to delete.
     */
    where: GameTagWhereUniqueInput
  }

  /**
   * GameTag deleteMany
   */
  export type GameTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameTags to delete
     */
    where?: GameTagWhereInput
    /**
     * Limit how many GameTags to delete.
     */
    limit?: number
  }

  /**
   * GameTag.games
   */
  export type GameTag$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * GameTag without action
   */
  export type GameTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
  }


  /**
   * Model ReviewUserTag
   */

  export type AggregateReviewUserTag = {
    _count: ReviewUserTagCountAggregateOutputType | null
    _avg: ReviewUserTagAvgAggregateOutputType | null
    _sum: ReviewUserTagSumAggregateOutputType | null
    _min: ReviewUserTagMinAggregateOutputType | null
    _max: ReviewUserTagMaxAggregateOutputType | null
  }

  export type ReviewUserTagAvgAggregateOutputType = {
    id: number | null
    reviewId: number | null
    userId: number | null
  }

  export type ReviewUserTagSumAggregateOutputType = {
    id: number | null
    reviewId: number | null
    userId: number | null
  }

  export type ReviewUserTagMinAggregateOutputType = {
    id: number | null
    label: string | null
    reviewId: number | null
    userId: number | null
  }

  export type ReviewUserTagMaxAggregateOutputType = {
    id: number | null
    label: string | null
    reviewId: number | null
    userId: number | null
  }

  export type ReviewUserTagCountAggregateOutputType = {
    id: number
    label: number
    reviewId: number
    userId: number
    _all: number
  }


  export type ReviewUserTagAvgAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
  }

  export type ReviewUserTagSumAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
  }

  export type ReviewUserTagMinAggregateInputType = {
    id?: true
    label?: true
    reviewId?: true
    userId?: true
  }

  export type ReviewUserTagMaxAggregateInputType = {
    id?: true
    label?: true
    reviewId?: true
    userId?: true
  }

  export type ReviewUserTagCountAggregateInputType = {
    id?: true
    label?: true
    reviewId?: true
    userId?: true
    _all?: true
  }

  export type ReviewUserTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewUserTag to aggregate.
     */
    where?: ReviewUserTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewUserTags to fetch.
     */
    orderBy?: ReviewUserTagOrderByWithRelationInput | ReviewUserTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewUserTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewUserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewUserTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewUserTags
    **/
    _count?: true | ReviewUserTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewUserTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewUserTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewUserTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewUserTagMaxAggregateInputType
  }

  export type GetReviewUserTagAggregateType<T extends ReviewUserTagAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewUserTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewUserTag[P]>
      : GetScalarType<T[P], AggregateReviewUserTag[P]>
  }




  export type ReviewUserTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewUserTagWhereInput
    orderBy?: ReviewUserTagOrderByWithAggregationInput | ReviewUserTagOrderByWithAggregationInput[]
    by: ReviewUserTagScalarFieldEnum[] | ReviewUserTagScalarFieldEnum
    having?: ReviewUserTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewUserTagCountAggregateInputType | true
    _avg?: ReviewUserTagAvgAggregateInputType
    _sum?: ReviewUserTagSumAggregateInputType
    _min?: ReviewUserTagMinAggregateInputType
    _max?: ReviewUserTagMaxAggregateInputType
  }

  export type ReviewUserTagGroupByOutputType = {
    id: number
    label: string
    reviewId: number
    userId: number
    _count: ReviewUserTagCountAggregateOutputType | null
    _avg: ReviewUserTagAvgAggregateOutputType | null
    _sum: ReviewUserTagSumAggregateOutputType | null
    _min: ReviewUserTagMinAggregateOutputType | null
    _max: ReviewUserTagMaxAggregateOutputType | null
  }

  type GetReviewUserTagGroupByPayload<T extends ReviewUserTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewUserTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewUserTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewUserTagGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewUserTagGroupByOutputType[P]>
        }
      >
    >


  export type ReviewUserTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    reviewId?: boolean
    userId?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewUserTag"]>

  export type ReviewUserTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    reviewId?: boolean
    userId?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewUserTag"]>

  export type ReviewUserTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    reviewId?: boolean
    userId?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewUserTag"]>

  export type ReviewUserTagSelectScalar = {
    id?: boolean
    label?: boolean
    reviewId?: boolean
    userId?: boolean
  }

  export type ReviewUserTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "reviewId" | "userId", ExtArgs["result"]["reviewUserTag"]>
  export type ReviewUserTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewUserTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewUserTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewUserTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewUserTag"
    objects: {
      review: Prisma.$ReviewPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      label: string
      reviewId: number
      userId: number
    }, ExtArgs["result"]["reviewUserTag"]>
    composites: {}
  }

  type ReviewUserTagGetPayload<S extends boolean | null | undefined | ReviewUserTagDefaultArgs> = $Result.GetResult<Prisma.$ReviewUserTagPayload, S>

  type ReviewUserTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewUserTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewUserTagCountAggregateInputType | true
    }

  export interface ReviewUserTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewUserTag'], meta: { name: 'ReviewUserTag' } }
    /**
     * Find zero or one ReviewUserTag that matches the filter.
     * @param {ReviewUserTagFindUniqueArgs} args - Arguments to find a ReviewUserTag
     * @example
     * // Get one ReviewUserTag
     * const reviewUserTag = await prisma.reviewUserTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewUserTagFindUniqueArgs>(args: SelectSubset<T, ReviewUserTagFindUniqueArgs<ExtArgs>>): Prisma__ReviewUserTagClient<$Result.GetResult<Prisma.$ReviewUserTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReviewUserTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewUserTagFindUniqueOrThrowArgs} args - Arguments to find a ReviewUserTag
     * @example
     * // Get one ReviewUserTag
     * const reviewUserTag = await prisma.reviewUserTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewUserTagFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewUserTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewUserTagClient<$Result.GetResult<Prisma.$ReviewUserTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewUserTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUserTagFindFirstArgs} args - Arguments to find a ReviewUserTag
     * @example
     * // Get one ReviewUserTag
     * const reviewUserTag = await prisma.reviewUserTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewUserTagFindFirstArgs>(args?: SelectSubset<T, ReviewUserTagFindFirstArgs<ExtArgs>>): Prisma__ReviewUserTagClient<$Result.GetResult<Prisma.$ReviewUserTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewUserTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUserTagFindFirstOrThrowArgs} args - Arguments to find a ReviewUserTag
     * @example
     * // Get one ReviewUserTag
     * const reviewUserTag = await prisma.reviewUserTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewUserTagFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewUserTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewUserTagClient<$Result.GetResult<Prisma.$ReviewUserTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReviewUserTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUserTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewUserTags
     * const reviewUserTags = await prisma.reviewUserTag.findMany()
     * 
     * // Get first 10 ReviewUserTags
     * const reviewUserTags = await prisma.reviewUserTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewUserTagWithIdOnly = await prisma.reviewUserTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewUserTagFindManyArgs>(args?: SelectSubset<T, ReviewUserTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewUserTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReviewUserTag.
     * @param {ReviewUserTagCreateArgs} args - Arguments to create a ReviewUserTag.
     * @example
     * // Create one ReviewUserTag
     * const ReviewUserTag = await prisma.reviewUserTag.create({
     *   data: {
     *     // ... data to create a ReviewUserTag
     *   }
     * })
     * 
     */
    create<T extends ReviewUserTagCreateArgs>(args: SelectSubset<T, ReviewUserTagCreateArgs<ExtArgs>>): Prisma__ReviewUserTagClient<$Result.GetResult<Prisma.$ReviewUserTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReviewUserTags.
     * @param {ReviewUserTagCreateManyArgs} args - Arguments to create many ReviewUserTags.
     * @example
     * // Create many ReviewUserTags
     * const reviewUserTag = await prisma.reviewUserTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewUserTagCreateManyArgs>(args?: SelectSubset<T, ReviewUserTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewUserTags and returns the data saved in the database.
     * @param {ReviewUserTagCreateManyAndReturnArgs} args - Arguments to create many ReviewUserTags.
     * @example
     * // Create many ReviewUserTags
     * const reviewUserTag = await prisma.reviewUserTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewUserTags and only return the `id`
     * const reviewUserTagWithIdOnly = await prisma.reviewUserTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewUserTagCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewUserTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewUserTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReviewUserTag.
     * @param {ReviewUserTagDeleteArgs} args - Arguments to delete one ReviewUserTag.
     * @example
     * // Delete one ReviewUserTag
     * const ReviewUserTag = await prisma.reviewUserTag.delete({
     *   where: {
     *     // ... filter to delete one ReviewUserTag
     *   }
     * })
     * 
     */
    delete<T extends ReviewUserTagDeleteArgs>(args: SelectSubset<T, ReviewUserTagDeleteArgs<ExtArgs>>): Prisma__ReviewUserTagClient<$Result.GetResult<Prisma.$ReviewUserTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReviewUserTag.
     * @param {ReviewUserTagUpdateArgs} args - Arguments to update one ReviewUserTag.
     * @example
     * // Update one ReviewUserTag
     * const reviewUserTag = await prisma.reviewUserTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUserTagUpdateArgs>(args: SelectSubset<T, ReviewUserTagUpdateArgs<ExtArgs>>): Prisma__ReviewUserTagClient<$Result.GetResult<Prisma.$ReviewUserTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReviewUserTags.
     * @param {ReviewUserTagDeleteManyArgs} args - Arguments to filter ReviewUserTags to delete.
     * @example
     * // Delete a few ReviewUserTags
     * const { count } = await prisma.reviewUserTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewUserTagDeleteManyArgs>(args?: SelectSubset<T, ReviewUserTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewUserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUserTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewUserTags
     * const reviewUserTag = await prisma.reviewUserTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUserTagUpdateManyArgs>(args: SelectSubset<T, ReviewUserTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewUserTags and returns the data updated in the database.
     * @param {ReviewUserTagUpdateManyAndReturnArgs} args - Arguments to update many ReviewUserTags.
     * @example
     * // Update many ReviewUserTags
     * const reviewUserTag = await prisma.reviewUserTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewUserTags and only return the `id`
     * const reviewUserTagWithIdOnly = await prisma.reviewUserTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUserTagUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUserTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewUserTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReviewUserTag.
     * @param {ReviewUserTagUpsertArgs} args - Arguments to update or create a ReviewUserTag.
     * @example
     * // Update or create a ReviewUserTag
     * const reviewUserTag = await prisma.reviewUserTag.upsert({
     *   create: {
     *     // ... data to create a ReviewUserTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewUserTag we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUserTagUpsertArgs>(args: SelectSubset<T, ReviewUserTagUpsertArgs<ExtArgs>>): Prisma__ReviewUserTagClient<$Result.GetResult<Prisma.$ReviewUserTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReviewUserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUserTagCountArgs} args - Arguments to filter ReviewUserTags to count.
     * @example
     * // Count the number of ReviewUserTags
     * const count = await prisma.reviewUserTag.count({
     *   where: {
     *     // ... the filter for the ReviewUserTags we want to count
     *   }
     * })
    **/
    count<T extends ReviewUserTagCountArgs>(
      args?: Subset<T, ReviewUserTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewUserTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewUserTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUserTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewUserTagAggregateArgs>(args: Subset<T, ReviewUserTagAggregateArgs>): Prisma.PrismaPromise<GetReviewUserTagAggregateType<T>>

    /**
     * Group by ReviewUserTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUserTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewUserTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewUserTagGroupByArgs['orderBy'] }
        : { orderBy?: ReviewUserTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewUserTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewUserTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewUserTag model
   */
  readonly fields: ReviewUserTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewUserTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewUserTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    review<T extends ReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReviewDefaultArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewUserTag model
   */
  interface ReviewUserTagFieldRefs {
    readonly id: FieldRef<"ReviewUserTag", 'Int'>
    readonly label: FieldRef<"ReviewUserTag", 'String'>
    readonly reviewId: FieldRef<"ReviewUserTag", 'Int'>
    readonly userId: FieldRef<"ReviewUserTag", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ReviewUserTag findUnique
   */
  export type ReviewUserTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUserTag
     */
    select?: ReviewUserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUserTag
     */
    omit?: ReviewUserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUserTagInclude<ExtArgs> | null
    /**
     * Filter, which ReviewUserTag to fetch.
     */
    where: ReviewUserTagWhereUniqueInput
  }

  /**
   * ReviewUserTag findUniqueOrThrow
   */
  export type ReviewUserTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUserTag
     */
    select?: ReviewUserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUserTag
     */
    omit?: ReviewUserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUserTagInclude<ExtArgs> | null
    /**
     * Filter, which ReviewUserTag to fetch.
     */
    where: ReviewUserTagWhereUniqueInput
  }

  /**
   * ReviewUserTag findFirst
   */
  export type ReviewUserTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUserTag
     */
    select?: ReviewUserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUserTag
     */
    omit?: ReviewUserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUserTagInclude<ExtArgs> | null
    /**
     * Filter, which ReviewUserTag to fetch.
     */
    where?: ReviewUserTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewUserTags to fetch.
     */
    orderBy?: ReviewUserTagOrderByWithRelationInput | ReviewUserTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewUserTags.
     */
    cursor?: ReviewUserTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewUserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewUserTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewUserTags.
     */
    distinct?: ReviewUserTagScalarFieldEnum | ReviewUserTagScalarFieldEnum[]
  }

  /**
   * ReviewUserTag findFirstOrThrow
   */
  export type ReviewUserTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUserTag
     */
    select?: ReviewUserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUserTag
     */
    omit?: ReviewUserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUserTagInclude<ExtArgs> | null
    /**
     * Filter, which ReviewUserTag to fetch.
     */
    where?: ReviewUserTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewUserTags to fetch.
     */
    orderBy?: ReviewUserTagOrderByWithRelationInput | ReviewUserTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewUserTags.
     */
    cursor?: ReviewUserTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewUserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewUserTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewUserTags.
     */
    distinct?: ReviewUserTagScalarFieldEnum | ReviewUserTagScalarFieldEnum[]
  }

  /**
   * ReviewUserTag findMany
   */
  export type ReviewUserTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUserTag
     */
    select?: ReviewUserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUserTag
     */
    omit?: ReviewUserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUserTagInclude<ExtArgs> | null
    /**
     * Filter, which ReviewUserTags to fetch.
     */
    where?: ReviewUserTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewUserTags to fetch.
     */
    orderBy?: ReviewUserTagOrderByWithRelationInput | ReviewUserTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewUserTags.
     */
    cursor?: ReviewUserTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewUserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewUserTags.
     */
    skip?: number
    distinct?: ReviewUserTagScalarFieldEnum | ReviewUserTagScalarFieldEnum[]
  }

  /**
   * ReviewUserTag create
   */
  export type ReviewUserTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUserTag
     */
    select?: ReviewUserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUserTag
     */
    omit?: ReviewUserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUserTagInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewUserTag.
     */
    data: XOR<ReviewUserTagCreateInput, ReviewUserTagUncheckedCreateInput>
  }

  /**
   * ReviewUserTag createMany
   */
  export type ReviewUserTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewUserTags.
     */
    data: ReviewUserTagCreateManyInput | ReviewUserTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewUserTag createManyAndReturn
   */
  export type ReviewUserTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUserTag
     */
    select?: ReviewUserTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUserTag
     */
    omit?: ReviewUserTagOmit<ExtArgs> | null
    /**
     * The data used to create many ReviewUserTags.
     */
    data: ReviewUserTagCreateManyInput | ReviewUserTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUserTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewUserTag update
   */
  export type ReviewUserTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUserTag
     */
    select?: ReviewUserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUserTag
     */
    omit?: ReviewUserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUserTagInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewUserTag.
     */
    data: XOR<ReviewUserTagUpdateInput, ReviewUserTagUncheckedUpdateInput>
    /**
     * Choose, which ReviewUserTag to update.
     */
    where: ReviewUserTagWhereUniqueInput
  }

  /**
   * ReviewUserTag updateMany
   */
  export type ReviewUserTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewUserTags.
     */
    data: XOR<ReviewUserTagUpdateManyMutationInput, ReviewUserTagUncheckedUpdateManyInput>
    /**
     * Filter which ReviewUserTags to update
     */
    where?: ReviewUserTagWhereInput
    /**
     * Limit how many ReviewUserTags to update.
     */
    limit?: number
  }

  /**
   * ReviewUserTag updateManyAndReturn
   */
  export type ReviewUserTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUserTag
     */
    select?: ReviewUserTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUserTag
     */
    omit?: ReviewUserTagOmit<ExtArgs> | null
    /**
     * The data used to update ReviewUserTags.
     */
    data: XOR<ReviewUserTagUpdateManyMutationInput, ReviewUserTagUncheckedUpdateManyInput>
    /**
     * Filter which ReviewUserTags to update
     */
    where?: ReviewUserTagWhereInput
    /**
     * Limit how many ReviewUserTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUserTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewUserTag upsert
   */
  export type ReviewUserTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUserTag
     */
    select?: ReviewUserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUserTag
     */
    omit?: ReviewUserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUserTagInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewUserTag to update in case it exists.
     */
    where: ReviewUserTagWhereUniqueInput
    /**
     * In case the ReviewUserTag found by the `where` argument doesn't exist, create a new ReviewUserTag with this data.
     */
    create: XOR<ReviewUserTagCreateInput, ReviewUserTagUncheckedCreateInput>
    /**
     * In case the ReviewUserTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUserTagUpdateInput, ReviewUserTagUncheckedUpdateInput>
  }

  /**
   * ReviewUserTag delete
   */
  export type ReviewUserTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUserTag
     */
    select?: ReviewUserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUserTag
     */
    omit?: ReviewUserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUserTagInclude<ExtArgs> | null
    /**
     * Filter which ReviewUserTag to delete.
     */
    where: ReviewUserTagWhereUniqueInput
  }

  /**
   * ReviewUserTag deleteMany
   */
  export type ReviewUserTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewUserTags to delete
     */
    where?: ReviewUserTagWhereInput
    /**
     * Limit how many ReviewUserTags to delete.
     */
    limit?: number
  }

  /**
   * ReviewUserTag without action
   */
  export type ReviewUserTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUserTag
     */
    select?: ReviewUserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUserTag
     */
    omit?: ReviewUserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUserTagInclude<ExtArgs> | null
  }


  /**
   * Model Developer
   */

  export type AggregateDeveloper = {
    _count: DeveloperCountAggregateOutputType | null
    _avg: DeveloperAvgAggregateOutputType | null
    _sum: DeveloperSumAggregateOutputType | null
    _min: DeveloperMinAggregateOutputType | null
    _max: DeveloperMaxAggregateOutputType | null
  }

  export type DeveloperAvgAggregateOutputType = {
    id: number | null
  }

  export type DeveloperSumAggregateOutputType = {
    id: number | null
  }

  export type DeveloperMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type DeveloperMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type DeveloperCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type DeveloperAvgAggregateInputType = {
    id?: true
  }

  export type DeveloperSumAggregateInputType = {
    id?: true
  }

  export type DeveloperMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type DeveloperMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type DeveloperCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type DeveloperAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Developer to aggregate.
     */
    where?: DeveloperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Developers to fetch.
     */
    orderBy?: DeveloperOrderByWithRelationInput | DeveloperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeveloperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Developers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Developers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Developers
    **/
    _count?: true | DeveloperCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeveloperAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeveloperSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeveloperMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeveloperMaxAggregateInputType
  }

  export type GetDeveloperAggregateType<T extends DeveloperAggregateArgs> = {
        [P in keyof T & keyof AggregateDeveloper]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeveloper[P]>
      : GetScalarType<T[P], AggregateDeveloper[P]>
  }




  export type DeveloperGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeveloperWhereInput
    orderBy?: DeveloperOrderByWithAggregationInput | DeveloperOrderByWithAggregationInput[]
    by: DeveloperScalarFieldEnum[] | DeveloperScalarFieldEnum
    having?: DeveloperScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeveloperCountAggregateInputType | true
    _avg?: DeveloperAvgAggregateInputType
    _sum?: DeveloperSumAggregateInputType
    _min?: DeveloperMinAggregateInputType
    _max?: DeveloperMaxAggregateInputType
  }

  export type DeveloperGroupByOutputType = {
    id: number
    name: string
    _count: DeveloperCountAggregateOutputType | null
    _avg: DeveloperAvgAggregateOutputType | null
    _sum: DeveloperSumAggregateOutputType | null
    _min: DeveloperMinAggregateOutputType | null
    _max: DeveloperMaxAggregateOutputType | null
  }

  type GetDeveloperGroupByPayload<T extends DeveloperGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeveloperGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeveloperGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeveloperGroupByOutputType[P]>
            : GetScalarType<T[P], DeveloperGroupByOutputType[P]>
        }
      >
    >


  export type DeveloperSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    games?: boolean | Developer$gamesArgs<ExtArgs>
    _count?: boolean | DeveloperCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["developer"]>

  export type DeveloperSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["developer"]>

  export type DeveloperSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["developer"]>

  export type DeveloperSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type DeveloperOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["developer"]>
  export type DeveloperInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | Developer$gamesArgs<ExtArgs>
    _count?: boolean | DeveloperCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeveloperIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DeveloperIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DeveloperPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Developer"
    objects: {
      games: Prisma.$GamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["developer"]>
    composites: {}
  }

  type DeveloperGetPayload<S extends boolean | null | undefined | DeveloperDefaultArgs> = $Result.GetResult<Prisma.$DeveloperPayload, S>

  type DeveloperCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeveloperFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeveloperCountAggregateInputType | true
    }

  export interface DeveloperDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Developer'], meta: { name: 'Developer' } }
    /**
     * Find zero or one Developer that matches the filter.
     * @param {DeveloperFindUniqueArgs} args - Arguments to find a Developer
     * @example
     * // Get one Developer
     * const developer = await prisma.developer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeveloperFindUniqueArgs>(args: SelectSubset<T, DeveloperFindUniqueArgs<ExtArgs>>): Prisma__DeveloperClient<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Developer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeveloperFindUniqueOrThrowArgs} args - Arguments to find a Developer
     * @example
     * // Get one Developer
     * const developer = await prisma.developer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeveloperFindUniqueOrThrowArgs>(args: SelectSubset<T, DeveloperFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeveloperClient<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Developer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeveloperFindFirstArgs} args - Arguments to find a Developer
     * @example
     * // Get one Developer
     * const developer = await prisma.developer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeveloperFindFirstArgs>(args?: SelectSubset<T, DeveloperFindFirstArgs<ExtArgs>>): Prisma__DeveloperClient<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Developer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeveloperFindFirstOrThrowArgs} args - Arguments to find a Developer
     * @example
     * // Get one Developer
     * const developer = await prisma.developer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeveloperFindFirstOrThrowArgs>(args?: SelectSubset<T, DeveloperFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeveloperClient<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Developers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeveloperFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Developers
     * const developers = await prisma.developer.findMany()
     * 
     * // Get first 10 Developers
     * const developers = await prisma.developer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const developerWithIdOnly = await prisma.developer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeveloperFindManyArgs>(args?: SelectSubset<T, DeveloperFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Developer.
     * @param {DeveloperCreateArgs} args - Arguments to create a Developer.
     * @example
     * // Create one Developer
     * const Developer = await prisma.developer.create({
     *   data: {
     *     // ... data to create a Developer
     *   }
     * })
     * 
     */
    create<T extends DeveloperCreateArgs>(args: SelectSubset<T, DeveloperCreateArgs<ExtArgs>>): Prisma__DeveloperClient<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Developers.
     * @param {DeveloperCreateManyArgs} args - Arguments to create many Developers.
     * @example
     * // Create many Developers
     * const developer = await prisma.developer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeveloperCreateManyArgs>(args?: SelectSubset<T, DeveloperCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Developers and returns the data saved in the database.
     * @param {DeveloperCreateManyAndReturnArgs} args - Arguments to create many Developers.
     * @example
     * // Create many Developers
     * const developer = await prisma.developer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Developers and only return the `id`
     * const developerWithIdOnly = await prisma.developer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeveloperCreateManyAndReturnArgs>(args?: SelectSubset<T, DeveloperCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Developer.
     * @param {DeveloperDeleteArgs} args - Arguments to delete one Developer.
     * @example
     * // Delete one Developer
     * const Developer = await prisma.developer.delete({
     *   where: {
     *     // ... filter to delete one Developer
     *   }
     * })
     * 
     */
    delete<T extends DeveloperDeleteArgs>(args: SelectSubset<T, DeveloperDeleteArgs<ExtArgs>>): Prisma__DeveloperClient<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Developer.
     * @param {DeveloperUpdateArgs} args - Arguments to update one Developer.
     * @example
     * // Update one Developer
     * const developer = await prisma.developer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeveloperUpdateArgs>(args: SelectSubset<T, DeveloperUpdateArgs<ExtArgs>>): Prisma__DeveloperClient<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Developers.
     * @param {DeveloperDeleteManyArgs} args - Arguments to filter Developers to delete.
     * @example
     * // Delete a few Developers
     * const { count } = await prisma.developer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeveloperDeleteManyArgs>(args?: SelectSubset<T, DeveloperDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Developers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeveloperUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Developers
     * const developer = await prisma.developer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeveloperUpdateManyArgs>(args: SelectSubset<T, DeveloperUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Developers and returns the data updated in the database.
     * @param {DeveloperUpdateManyAndReturnArgs} args - Arguments to update many Developers.
     * @example
     * // Update many Developers
     * const developer = await prisma.developer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Developers and only return the `id`
     * const developerWithIdOnly = await prisma.developer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeveloperUpdateManyAndReturnArgs>(args: SelectSubset<T, DeveloperUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Developer.
     * @param {DeveloperUpsertArgs} args - Arguments to update or create a Developer.
     * @example
     * // Update or create a Developer
     * const developer = await prisma.developer.upsert({
     *   create: {
     *     // ... data to create a Developer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Developer we want to update
     *   }
     * })
     */
    upsert<T extends DeveloperUpsertArgs>(args: SelectSubset<T, DeveloperUpsertArgs<ExtArgs>>): Prisma__DeveloperClient<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Developers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeveloperCountArgs} args - Arguments to filter Developers to count.
     * @example
     * // Count the number of Developers
     * const count = await prisma.developer.count({
     *   where: {
     *     // ... the filter for the Developers we want to count
     *   }
     * })
    **/
    count<T extends DeveloperCountArgs>(
      args?: Subset<T, DeveloperCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeveloperCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Developer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeveloperAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeveloperAggregateArgs>(args: Subset<T, DeveloperAggregateArgs>): Prisma.PrismaPromise<GetDeveloperAggregateType<T>>

    /**
     * Group by Developer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeveloperGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeveloperGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeveloperGroupByArgs['orderBy'] }
        : { orderBy?: DeveloperGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeveloperGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeveloperGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Developer model
   */
  readonly fields: DeveloperFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Developer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeveloperClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    games<T extends Developer$gamesArgs<ExtArgs> = {}>(args?: Subset<T, Developer$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Developer model
   */
  interface DeveloperFieldRefs {
    readonly id: FieldRef<"Developer", 'Int'>
    readonly name: FieldRef<"Developer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Developer findUnique
   */
  export type DeveloperFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeveloperInclude<ExtArgs> | null
    /**
     * Filter, which Developer to fetch.
     */
    where: DeveloperWhereUniqueInput
  }

  /**
   * Developer findUniqueOrThrow
   */
  export type DeveloperFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeveloperInclude<ExtArgs> | null
    /**
     * Filter, which Developer to fetch.
     */
    where: DeveloperWhereUniqueInput
  }

  /**
   * Developer findFirst
   */
  export type DeveloperFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeveloperInclude<ExtArgs> | null
    /**
     * Filter, which Developer to fetch.
     */
    where?: DeveloperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Developers to fetch.
     */
    orderBy?: DeveloperOrderByWithRelationInput | DeveloperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Developers.
     */
    cursor?: DeveloperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Developers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Developers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Developers.
     */
    distinct?: DeveloperScalarFieldEnum | DeveloperScalarFieldEnum[]
  }

  /**
   * Developer findFirstOrThrow
   */
  export type DeveloperFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeveloperInclude<ExtArgs> | null
    /**
     * Filter, which Developer to fetch.
     */
    where?: DeveloperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Developers to fetch.
     */
    orderBy?: DeveloperOrderByWithRelationInput | DeveloperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Developers.
     */
    cursor?: DeveloperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Developers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Developers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Developers.
     */
    distinct?: DeveloperScalarFieldEnum | DeveloperScalarFieldEnum[]
  }

  /**
   * Developer findMany
   */
  export type DeveloperFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeveloperInclude<ExtArgs> | null
    /**
     * Filter, which Developers to fetch.
     */
    where?: DeveloperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Developers to fetch.
     */
    orderBy?: DeveloperOrderByWithRelationInput | DeveloperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Developers.
     */
    cursor?: DeveloperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Developers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Developers.
     */
    skip?: number
    distinct?: DeveloperScalarFieldEnum | DeveloperScalarFieldEnum[]
  }

  /**
   * Developer create
   */
  export type DeveloperCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeveloperInclude<ExtArgs> | null
    /**
     * The data needed to create a Developer.
     */
    data: XOR<DeveloperCreateInput, DeveloperUncheckedCreateInput>
  }

  /**
   * Developer createMany
   */
  export type DeveloperCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Developers.
     */
    data: DeveloperCreateManyInput | DeveloperCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Developer createManyAndReturn
   */
  export type DeveloperCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * The data used to create many Developers.
     */
    data: DeveloperCreateManyInput | DeveloperCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Developer update
   */
  export type DeveloperUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeveloperInclude<ExtArgs> | null
    /**
     * The data needed to update a Developer.
     */
    data: XOR<DeveloperUpdateInput, DeveloperUncheckedUpdateInput>
    /**
     * Choose, which Developer to update.
     */
    where: DeveloperWhereUniqueInput
  }

  /**
   * Developer updateMany
   */
  export type DeveloperUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Developers.
     */
    data: XOR<DeveloperUpdateManyMutationInput, DeveloperUncheckedUpdateManyInput>
    /**
     * Filter which Developers to update
     */
    where?: DeveloperWhereInput
    /**
     * Limit how many Developers to update.
     */
    limit?: number
  }

  /**
   * Developer updateManyAndReturn
   */
  export type DeveloperUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * The data used to update Developers.
     */
    data: XOR<DeveloperUpdateManyMutationInput, DeveloperUncheckedUpdateManyInput>
    /**
     * Filter which Developers to update
     */
    where?: DeveloperWhereInput
    /**
     * Limit how many Developers to update.
     */
    limit?: number
  }

  /**
   * Developer upsert
   */
  export type DeveloperUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeveloperInclude<ExtArgs> | null
    /**
     * The filter to search for the Developer to update in case it exists.
     */
    where: DeveloperWhereUniqueInput
    /**
     * In case the Developer found by the `where` argument doesn't exist, create a new Developer with this data.
     */
    create: XOR<DeveloperCreateInput, DeveloperUncheckedCreateInput>
    /**
     * In case the Developer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeveloperUpdateInput, DeveloperUncheckedUpdateInput>
  }

  /**
   * Developer delete
   */
  export type DeveloperDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeveloperInclude<ExtArgs> | null
    /**
     * Filter which Developer to delete.
     */
    where: DeveloperWhereUniqueInput
  }

  /**
   * Developer deleteMany
   */
  export type DeveloperDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Developers to delete
     */
    where?: DeveloperWhereInput
    /**
     * Limit how many Developers to delete.
     */
    limit?: number
  }

  /**
   * Developer.games
   */
  export type Developer$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Developer without action
   */
  export type DeveloperDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeveloperInclude<ExtArgs> | null
  }


  /**
   * Model Publisher
   */

  export type AggregatePublisher = {
    _count: PublisherCountAggregateOutputType | null
    _avg: PublisherAvgAggregateOutputType | null
    _sum: PublisherSumAggregateOutputType | null
    _min: PublisherMinAggregateOutputType | null
    _max: PublisherMaxAggregateOutputType | null
  }

  export type PublisherAvgAggregateOutputType = {
    id: number | null
  }

  export type PublisherSumAggregateOutputType = {
    id: number | null
  }

  export type PublisherMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type PublisherMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type PublisherCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type PublisherAvgAggregateInputType = {
    id?: true
  }

  export type PublisherSumAggregateInputType = {
    id?: true
  }

  export type PublisherMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type PublisherMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type PublisherCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type PublisherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Publisher to aggregate.
     */
    where?: PublisherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publishers to fetch.
     */
    orderBy?: PublisherOrderByWithRelationInput | PublisherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PublisherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publishers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publishers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Publishers
    **/
    _count?: true | PublisherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PublisherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PublisherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PublisherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PublisherMaxAggregateInputType
  }

  export type GetPublisherAggregateType<T extends PublisherAggregateArgs> = {
        [P in keyof T & keyof AggregatePublisher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublisher[P]>
      : GetScalarType<T[P], AggregatePublisher[P]>
  }




  export type PublisherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublisherWhereInput
    orderBy?: PublisherOrderByWithAggregationInput | PublisherOrderByWithAggregationInput[]
    by: PublisherScalarFieldEnum[] | PublisherScalarFieldEnum
    having?: PublisherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublisherCountAggregateInputType | true
    _avg?: PublisherAvgAggregateInputType
    _sum?: PublisherSumAggregateInputType
    _min?: PublisherMinAggregateInputType
    _max?: PublisherMaxAggregateInputType
  }

  export type PublisherGroupByOutputType = {
    id: number
    name: string
    _count: PublisherCountAggregateOutputType | null
    _avg: PublisherAvgAggregateOutputType | null
    _sum: PublisherSumAggregateOutputType | null
    _min: PublisherMinAggregateOutputType | null
    _max: PublisherMaxAggregateOutputType | null
  }

  type GetPublisherGroupByPayload<T extends PublisherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PublisherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublisherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublisherGroupByOutputType[P]>
            : GetScalarType<T[P], PublisherGroupByOutputType[P]>
        }
      >
    >


  export type PublisherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    games?: boolean | Publisher$gamesArgs<ExtArgs>
    _count?: boolean | PublisherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publisher"]>

  export type PublisherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["publisher"]>

  export type PublisherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["publisher"]>

  export type PublisherSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type PublisherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["publisher"]>
  export type PublisherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | Publisher$gamesArgs<ExtArgs>
    _count?: boolean | PublisherCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PublisherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PublisherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PublisherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Publisher"
    objects: {
      games: Prisma.$GamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["publisher"]>
    composites: {}
  }

  type PublisherGetPayload<S extends boolean | null | undefined | PublisherDefaultArgs> = $Result.GetResult<Prisma.$PublisherPayload, S>

  type PublisherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PublisherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PublisherCountAggregateInputType | true
    }

  export interface PublisherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Publisher'], meta: { name: 'Publisher' } }
    /**
     * Find zero or one Publisher that matches the filter.
     * @param {PublisherFindUniqueArgs} args - Arguments to find a Publisher
     * @example
     * // Get one Publisher
     * const publisher = await prisma.publisher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PublisherFindUniqueArgs>(args: SelectSubset<T, PublisherFindUniqueArgs<ExtArgs>>): Prisma__PublisherClient<$Result.GetResult<Prisma.$PublisherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Publisher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PublisherFindUniqueOrThrowArgs} args - Arguments to find a Publisher
     * @example
     * // Get one Publisher
     * const publisher = await prisma.publisher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PublisherFindUniqueOrThrowArgs>(args: SelectSubset<T, PublisherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PublisherClient<$Result.GetResult<Prisma.$PublisherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Publisher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublisherFindFirstArgs} args - Arguments to find a Publisher
     * @example
     * // Get one Publisher
     * const publisher = await prisma.publisher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PublisherFindFirstArgs>(args?: SelectSubset<T, PublisherFindFirstArgs<ExtArgs>>): Prisma__PublisherClient<$Result.GetResult<Prisma.$PublisherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Publisher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublisherFindFirstOrThrowArgs} args - Arguments to find a Publisher
     * @example
     * // Get one Publisher
     * const publisher = await prisma.publisher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PublisherFindFirstOrThrowArgs>(args?: SelectSubset<T, PublisherFindFirstOrThrowArgs<ExtArgs>>): Prisma__PublisherClient<$Result.GetResult<Prisma.$PublisherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Publishers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublisherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publishers
     * const publishers = await prisma.publisher.findMany()
     * 
     * // Get first 10 Publishers
     * const publishers = await prisma.publisher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const publisherWithIdOnly = await prisma.publisher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PublisherFindManyArgs>(args?: SelectSubset<T, PublisherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublisherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Publisher.
     * @param {PublisherCreateArgs} args - Arguments to create a Publisher.
     * @example
     * // Create one Publisher
     * const Publisher = await prisma.publisher.create({
     *   data: {
     *     // ... data to create a Publisher
     *   }
     * })
     * 
     */
    create<T extends PublisherCreateArgs>(args: SelectSubset<T, PublisherCreateArgs<ExtArgs>>): Prisma__PublisherClient<$Result.GetResult<Prisma.$PublisherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Publishers.
     * @param {PublisherCreateManyArgs} args - Arguments to create many Publishers.
     * @example
     * // Create many Publishers
     * const publisher = await prisma.publisher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PublisherCreateManyArgs>(args?: SelectSubset<T, PublisherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Publishers and returns the data saved in the database.
     * @param {PublisherCreateManyAndReturnArgs} args - Arguments to create many Publishers.
     * @example
     * // Create many Publishers
     * const publisher = await prisma.publisher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Publishers and only return the `id`
     * const publisherWithIdOnly = await prisma.publisher.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PublisherCreateManyAndReturnArgs>(args?: SelectSubset<T, PublisherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublisherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Publisher.
     * @param {PublisherDeleteArgs} args - Arguments to delete one Publisher.
     * @example
     * // Delete one Publisher
     * const Publisher = await prisma.publisher.delete({
     *   where: {
     *     // ... filter to delete one Publisher
     *   }
     * })
     * 
     */
    delete<T extends PublisherDeleteArgs>(args: SelectSubset<T, PublisherDeleteArgs<ExtArgs>>): Prisma__PublisherClient<$Result.GetResult<Prisma.$PublisherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Publisher.
     * @param {PublisherUpdateArgs} args - Arguments to update one Publisher.
     * @example
     * // Update one Publisher
     * const publisher = await prisma.publisher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PublisherUpdateArgs>(args: SelectSubset<T, PublisherUpdateArgs<ExtArgs>>): Prisma__PublisherClient<$Result.GetResult<Prisma.$PublisherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Publishers.
     * @param {PublisherDeleteManyArgs} args - Arguments to filter Publishers to delete.
     * @example
     * // Delete a few Publishers
     * const { count } = await prisma.publisher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PublisherDeleteManyArgs>(args?: SelectSubset<T, PublisherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publishers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublisherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publishers
     * const publisher = await prisma.publisher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PublisherUpdateManyArgs>(args: SelectSubset<T, PublisherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publishers and returns the data updated in the database.
     * @param {PublisherUpdateManyAndReturnArgs} args - Arguments to update many Publishers.
     * @example
     * // Update many Publishers
     * const publisher = await prisma.publisher.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Publishers and only return the `id`
     * const publisherWithIdOnly = await prisma.publisher.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PublisherUpdateManyAndReturnArgs>(args: SelectSubset<T, PublisherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublisherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Publisher.
     * @param {PublisherUpsertArgs} args - Arguments to update or create a Publisher.
     * @example
     * // Update or create a Publisher
     * const publisher = await prisma.publisher.upsert({
     *   create: {
     *     // ... data to create a Publisher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publisher we want to update
     *   }
     * })
     */
    upsert<T extends PublisherUpsertArgs>(args: SelectSubset<T, PublisherUpsertArgs<ExtArgs>>): Prisma__PublisherClient<$Result.GetResult<Prisma.$PublisherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Publishers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublisherCountArgs} args - Arguments to filter Publishers to count.
     * @example
     * // Count the number of Publishers
     * const count = await prisma.publisher.count({
     *   where: {
     *     // ... the filter for the Publishers we want to count
     *   }
     * })
    **/
    count<T extends PublisherCountArgs>(
      args?: Subset<T, PublisherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublisherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Publisher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublisherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublisherAggregateArgs>(args: Subset<T, PublisherAggregateArgs>): Prisma.PrismaPromise<GetPublisherAggregateType<T>>

    /**
     * Group by Publisher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublisherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PublisherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PublisherGroupByArgs['orderBy'] }
        : { orderBy?: PublisherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PublisherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublisherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Publisher model
   */
  readonly fields: PublisherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Publisher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PublisherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    games<T extends Publisher$gamesArgs<ExtArgs> = {}>(args?: Subset<T, Publisher$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Publisher model
   */
  interface PublisherFieldRefs {
    readonly id: FieldRef<"Publisher", 'Int'>
    readonly name: FieldRef<"Publisher", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Publisher findUnique
   */
  export type PublisherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publisher
     */
    select?: PublisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publisher
     */
    omit?: PublisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublisherInclude<ExtArgs> | null
    /**
     * Filter, which Publisher to fetch.
     */
    where: PublisherWhereUniqueInput
  }

  /**
   * Publisher findUniqueOrThrow
   */
  export type PublisherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publisher
     */
    select?: PublisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publisher
     */
    omit?: PublisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublisherInclude<ExtArgs> | null
    /**
     * Filter, which Publisher to fetch.
     */
    where: PublisherWhereUniqueInput
  }

  /**
   * Publisher findFirst
   */
  export type PublisherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publisher
     */
    select?: PublisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publisher
     */
    omit?: PublisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublisherInclude<ExtArgs> | null
    /**
     * Filter, which Publisher to fetch.
     */
    where?: PublisherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publishers to fetch.
     */
    orderBy?: PublisherOrderByWithRelationInput | PublisherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Publishers.
     */
    cursor?: PublisherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publishers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publishers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Publishers.
     */
    distinct?: PublisherScalarFieldEnum | PublisherScalarFieldEnum[]
  }

  /**
   * Publisher findFirstOrThrow
   */
  export type PublisherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publisher
     */
    select?: PublisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publisher
     */
    omit?: PublisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublisherInclude<ExtArgs> | null
    /**
     * Filter, which Publisher to fetch.
     */
    where?: PublisherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publishers to fetch.
     */
    orderBy?: PublisherOrderByWithRelationInput | PublisherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Publishers.
     */
    cursor?: PublisherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publishers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publishers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Publishers.
     */
    distinct?: PublisherScalarFieldEnum | PublisherScalarFieldEnum[]
  }

  /**
   * Publisher findMany
   */
  export type PublisherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publisher
     */
    select?: PublisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publisher
     */
    omit?: PublisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublisherInclude<ExtArgs> | null
    /**
     * Filter, which Publishers to fetch.
     */
    where?: PublisherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publishers to fetch.
     */
    orderBy?: PublisherOrderByWithRelationInput | PublisherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Publishers.
     */
    cursor?: PublisherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publishers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publishers.
     */
    skip?: number
    distinct?: PublisherScalarFieldEnum | PublisherScalarFieldEnum[]
  }

  /**
   * Publisher create
   */
  export type PublisherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publisher
     */
    select?: PublisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publisher
     */
    omit?: PublisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublisherInclude<ExtArgs> | null
    /**
     * The data needed to create a Publisher.
     */
    data: XOR<PublisherCreateInput, PublisherUncheckedCreateInput>
  }

  /**
   * Publisher createMany
   */
  export type PublisherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Publishers.
     */
    data: PublisherCreateManyInput | PublisherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Publisher createManyAndReturn
   */
  export type PublisherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publisher
     */
    select?: PublisherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Publisher
     */
    omit?: PublisherOmit<ExtArgs> | null
    /**
     * The data used to create many Publishers.
     */
    data: PublisherCreateManyInput | PublisherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Publisher update
   */
  export type PublisherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publisher
     */
    select?: PublisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publisher
     */
    omit?: PublisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublisherInclude<ExtArgs> | null
    /**
     * The data needed to update a Publisher.
     */
    data: XOR<PublisherUpdateInput, PublisherUncheckedUpdateInput>
    /**
     * Choose, which Publisher to update.
     */
    where: PublisherWhereUniqueInput
  }

  /**
   * Publisher updateMany
   */
  export type PublisherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Publishers.
     */
    data: XOR<PublisherUpdateManyMutationInput, PublisherUncheckedUpdateManyInput>
    /**
     * Filter which Publishers to update
     */
    where?: PublisherWhereInput
    /**
     * Limit how many Publishers to update.
     */
    limit?: number
  }

  /**
   * Publisher updateManyAndReturn
   */
  export type PublisherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publisher
     */
    select?: PublisherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Publisher
     */
    omit?: PublisherOmit<ExtArgs> | null
    /**
     * The data used to update Publishers.
     */
    data: XOR<PublisherUpdateManyMutationInput, PublisherUncheckedUpdateManyInput>
    /**
     * Filter which Publishers to update
     */
    where?: PublisherWhereInput
    /**
     * Limit how many Publishers to update.
     */
    limit?: number
  }

  /**
   * Publisher upsert
   */
  export type PublisherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publisher
     */
    select?: PublisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publisher
     */
    omit?: PublisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublisherInclude<ExtArgs> | null
    /**
     * The filter to search for the Publisher to update in case it exists.
     */
    where: PublisherWhereUniqueInput
    /**
     * In case the Publisher found by the `where` argument doesn't exist, create a new Publisher with this data.
     */
    create: XOR<PublisherCreateInput, PublisherUncheckedCreateInput>
    /**
     * In case the Publisher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PublisherUpdateInput, PublisherUncheckedUpdateInput>
  }

  /**
   * Publisher delete
   */
  export type PublisherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publisher
     */
    select?: PublisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publisher
     */
    omit?: PublisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublisherInclude<ExtArgs> | null
    /**
     * Filter which Publisher to delete.
     */
    where: PublisherWhereUniqueInput
  }

  /**
   * Publisher deleteMany
   */
  export type PublisherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Publishers to delete
     */
    where?: PublisherWhereInput
    /**
     * Limit how many Publishers to delete.
     */
    limit?: number
  }

  /**
   * Publisher.games
   */
  export type Publisher$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Publisher without action
   */
  export type PublisherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publisher
     */
    select?: PublisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publisher
     */
    omit?: PublisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublisherInclude<ExtArgs> | null
  }


  /**
   * Model GameImage
   */

  export type AggregateGameImage = {
    _count: GameImageCountAggregateOutputType | null
    _avg: GameImageAvgAggregateOutputType | null
    _sum: GameImageSumAggregateOutputType | null
    _min: GameImageMinAggregateOutputType | null
    _max: GameImageMaxAggregateOutputType | null
  }

  export type GameImageAvgAggregateOutputType = {
    id: number | null
    gameId: number | null
  }

  export type GameImageSumAggregateOutputType = {
    id: number | null
    gameId: number | null
  }

  export type GameImageMinAggregateOutputType = {
    id: number | null
    url: string | null
    gameId: number | null
  }

  export type GameImageMaxAggregateOutputType = {
    id: number | null
    url: string | null
    gameId: number | null
  }

  export type GameImageCountAggregateOutputType = {
    id: number
    url: number
    gameId: number
    _all: number
  }


  export type GameImageAvgAggregateInputType = {
    id?: true
    gameId?: true
  }

  export type GameImageSumAggregateInputType = {
    id?: true
    gameId?: true
  }

  export type GameImageMinAggregateInputType = {
    id?: true
    url?: true
    gameId?: true
  }

  export type GameImageMaxAggregateInputType = {
    id?: true
    url?: true
    gameId?: true
  }

  export type GameImageCountAggregateInputType = {
    id?: true
    url?: true
    gameId?: true
    _all?: true
  }

  export type GameImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameImage to aggregate.
     */
    where?: GameImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameImages to fetch.
     */
    orderBy?: GameImageOrderByWithRelationInput | GameImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameImages
    **/
    _count?: true | GameImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameImageMaxAggregateInputType
  }

  export type GetGameImageAggregateType<T extends GameImageAggregateArgs> = {
        [P in keyof T & keyof AggregateGameImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameImage[P]>
      : GetScalarType<T[P], AggregateGameImage[P]>
  }




  export type GameImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameImageWhereInput
    orderBy?: GameImageOrderByWithAggregationInput | GameImageOrderByWithAggregationInput[]
    by: GameImageScalarFieldEnum[] | GameImageScalarFieldEnum
    having?: GameImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameImageCountAggregateInputType | true
    _avg?: GameImageAvgAggregateInputType
    _sum?: GameImageSumAggregateInputType
    _min?: GameImageMinAggregateInputType
    _max?: GameImageMaxAggregateInputType
  }

  export type GameImageGroupByOutputType = {
    id: number
    url: string
    gameId: number
    _count: GameImageCountAggregateOutputType | null
    _avg: GameImageAvgAggregateOutputType | null
    _sum: GameImageSumAggregateOutputType | null
    _min: GameImageMinAggregateOutputType | null
    _max: GameImageMaxAggregateOutputType | null
  }

  type GetGameImageGroupByPayload<T extends GameImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameImageGroupByOutputType[P]>
            : GetScalarType<T[P], GameImageGroupByOutputType[P]>
        }
      >
    >


  export type GameImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    gameId?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameImage"]>

  export type GameImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    gameId?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameImage"]>

  export type GameImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    gameId?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameImage"]>

  export type GameImageSelectScalar = {
    id?: boolean
    url?: boolean
    gameId?: boolean
  }

  export type GameImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "gameId", ExtArgs["result"]["gameImage"]>
  export type GameImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type GameImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type GameImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
  }

  export type $GameImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameImage"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      url: string
      gameId: number
    }, ExtArgs["result"]["gameImage"]>
    composites: {}
  }

  type GameImageGetPayload<S extends boolean | null | undefined | GameImageDefaultArgs> = $Result.GetResult<Prisma.$GameImagePayload, S>

  type GameImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameImageCountAggregateInputType | true
    }

  export interface GameImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameImage'], meta: { name: 'GameImage' } }
    /**
     * Find zero or one GameImage that matches the filter.
     * @param {GameImageFindUniqueArgs} args - Arguments to find a GameImage
     * @example
     * // Get one GameImage
     * const gameImage = await prisma.gameImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameImageFindUniqueArgs>(args: SelectSubset<T, GameImageFindUniqueArgs<ExtArgs>>): Prisma__GameImageClient<$Result.GetResult<Prisma.$GameImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameImageFindUniqueOrThrowArgs} args - Arguments to find a GameImage
     * @example
     * // Get one GameImage
     * const gameImage = await prisma.gameImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameImageFindUniqueOrThrowArgs>(args: SelectSubset<T, GameImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameImageClient<$Result.GetResult<Prisma.$GameImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameImageFindFirstArgs} args - Arguments to find a GameImage
     * @example
     * // Get one GameImage
     * const gameImage = await prisma.gameImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameImageFindFirstArgs>(args?: SelectSubset<T, GameImageFindFirstArgs<ExtArgs>>): Prisma__GameImageClient<$Result.GetResult<Prisma.$GameImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameImageFindFirstOrThrowArgs} args - Arguments to find a GameImage
     * @example
     * // Get one GameImage
     * const gameImage = await prisma.gameImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameImageFindFirstOrThrowArgs>(args?: SelectSubset<T, GameImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameImageClient<$Result.GetResult<Prisma.$GameImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameImages
     * const gameImages = await prisma.gameImage.findMany()
     * 
     * // Get first 10 GameImages
     * const gameImages = await prisma.gameImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameImageWithIdOnly = await prisma.gameImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameImageFindManyArgs>(args?: SelectSubset<T, GameImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameImage.
     * @param {GameImageCreateArgs} args - Arguments to create a GameImage.
     * @example
     * // Create one GameImage
     * const GameImage = await prisma.gameImage.create({
     *   data: {
     *     // ... data to create a GameImage
     *   }
     * })
     * 
     */
    create<T extends GameImageCreateArgs>(args: SelectSubset<T, GameImageCreateArgs<ExtArgs>>): Prisma__GameImageClient<$Result.GetResult<Prisma.$GameImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameImages.
     * @param {GameImageCreateManyArgs} args - Arguments to create many GameImages.
     * @example
     * // Create many GameImages
     * const gameImage = await prisma.gameImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameImageCreateManyArgs>(args?: SelectSubset<T, GameImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameImages and returns the data saved in the database.
     * @param {GameImageCreateManyAndReturnArgs} args - Arguments to create many GameImages.
     * @example
     * // Create many GameImages
     * const gameImage = await prisma.gameImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameImages and only return the `id`
     * const gameImageWithIdOnly = await prisma.gameImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameImageCreateManyAndReturnArgs>(args?: SelectSubset<T, GameImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameImage.
     * @param {GameImageDeleteArgs} args - Arguments to delete one GameImage.
     * @example
     * // Delete one GameImage
     * const GameImage = await prisma.gameImage.delete({
     *   where: {
     *     // ... filter to delete one GameImage
     *   }
     * })
     * 
     */
    delete<T extends GameImageDeleteArgs>(args: SelectSubset<T, GameImageDeleteArgs<ExtArgs>>): Prisma__GameImageClient<$Result.GetResult<Prisma.$GameImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameImage.
     * @param {GameImageUpdateArgs} args - Arguments to update one GameImage.
     * @example
     * // Update one GameImage
     * const gameImage = await prisma.gameImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameImageUpdateArgs>(args: SelectSubset<T, GameImageUpdateArgs<ExtArgs>>): Prisma__GameImageClient<$Result.GetResult<Prisma.$GameImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameImages.
     * @param {GameImageDeleteManyArgs} args - Arguments to filter GameImages to delete.
     * @example
     * // Delete a few GameImages
     * const { count } = await prisma.gameImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameImageDeleteManyArgs>(args?: SelectSubset<T, GameImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameImages
     * const gameImage = await prisma.gameImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameImageUpdateManyArgs>(args: SelectSubset<T, GameImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameImages and returns the data updated in the database.
     * @param {GameImageUpdateManyAndReturnArgs} args - Arguments to update many GameImages.
     * @example
     * // Update many GameImages
     * const gameImage = await prisma.gameImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameImages and only return the `id`
     * const gameImageWithIdOnly = await prisma.gameImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameImageUpdateManyAndReturnArgs>(args: SelectSubset<T, GameImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameImage.
     * @param {GameImageUpsertArgs} args - Arguments to update or create a GameImage.
     * @example
     * // Update or create a GameImage
     * const gameImage = await prisma.gameImage.upsert({
     *   create: {
     *     // ... data to create a GameImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameImage we want to update
     *   }
     * })
     */
    upsert<T extends GameImageUpsertArgs>(args: SelectSubset<T, GameImageUpsertArgs<ExtArgs>>): Prisma__GameImageClient<$Result.GetResult<Prisma.$GameImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameImageCountArgs} args - Arguments to filter GameImages to count.
     * @example
     * // Count the number of GameImages
     * const count = await prisma.gameImage.count({
     *   where: {
     *     // ... the filter for the GameImages we want to count
     *   }
     * })
    **/
    count<T extends GameImageCountArgs>(
      args?: Subset<T, GameImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameImageAggregateArgs>(args: Subset<T, GameImageAggregateArgs>): Prisma.PrismaPromise<GetGameImageAggregateType<T>>

    /**
     * Group by GameImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameImageGroupByArgs['orderBy'] }
        : { orderBy?: GameImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameImage model
   */
  readonly fields: GameImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameImage model
   */
  interface GameImageFieldRefs {
    readonly id: FieldRef<"GameImage", 'Int'>
    readonly url: FieldRef<"GameImage", 'String'>
    readonly gameId: FieldRef<"GameImage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * GameImage findUnique
   */
  export type GameImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameImage
     */
    select?: GameImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameImage
     */
    omit?: GameImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameImageInclude<ExtArgs> | null
    /**
     * Filter, which GameImage to fetch.
     */
    where: GameImageWhereUniqueInput
  }

  /**
   * GameImage findUniqueOrThrow
   */
  export type GameImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameImage
     */
    select?: GameImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameImage
     */
    omit?: GameImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameImageInclude<ExtArgs> | null
    /**
     * Filter, which GameImage to fetch.
     */
    where: GameImageWhereUniqueInput
  }

  /**
   * GameImage findFirst
   */
  export type GameImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameImage
     */
    select?: GameImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameImage
     */
    omit?: GameImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameImageInclude<ExtArgs> | null
    /**
     * Filter, which GameImage to fetch.
     */
    where?: GameImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameImages to fetch.
     */
    orderBy?: GameImageOrderByWithRelationInput | GameImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameImages.
     */
    cursor?: GameImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameImages.
     */
    distinct?: GameImageScalarFieldEnum | GameImageScalarFieldEnum[]
  }

  /**
   * GameImage findFirstOrThrow
   */
  export type GameImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameImage
     */
    select?: GameImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameImage
     */
    omit?: GameImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameImageInclude<ExtArgs> | null
    /**
     * Filter, which GameImage to fetch.
     */
    where?: GameImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameImages to fetch.
     */
    orderBy?: GameImageOrderByWithRelationInput | GameImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameImages.
     */
    cursor?: GameImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameImages.
     */
    distinct?: GameImageScalarFieldEnum | GameImageScalarFieldEnum[]
  }

  /**
   * GameImage findMany
   */
  export type GameImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameImage
     */
    select?: GameImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameImage
     */
    omit?: GameImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameImageInclude<ExtArgs> | null
    /**
     * Filter, which GameImages to fetch.
     */
    where?: GameImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameImages to fetch.
     */
    orderBy?: GameImageOrderByWithRelationInput | GameImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameImages.
     */
    cursor?: GameImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameImages.
     */
    skip?: number
    distinct?: GameImageScalarFieldEnum | GameImageScalarFieldEnum[]
  }

  /**
   * GameImage create
   */
  export type GameImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameImage
     */
    select?: GameImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameImage
     */
    omit?: GameImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameImageInclude<ExtArgs> | null
    /**
     * The data needed to create a GameImage.
     */
    data: XOR<GameImageCreateInput, GameImageUncheckedCreateInput>
  }

  /**
   * GameImage createMany
   */
  export type GameImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameImages.
     */
    data: GameImageCreateManyInput | GameImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameImage createManyAndReturn
   */
  export type GameImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameImage
     */
    select?: GameImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameImage
     */
    omit?: GameImageOmit<ExtArgs> | null
    /**
     * The data used to create many GameImages.
     */
    data: GameImageCreateManyInput | GameImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameImage update
   */
  export type GameImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameImage
     */
    select?: GameImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameImage
     */
    omit?: GameImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameImageInclude<ExtArgs> | null
    /**
     * The data needed to update a GameImage.
     */
    data: XOR<GameImageUpdateInput, GameImageUncheckedUpdateInput>
    /**
     * Choose, which GameImage to update.
     */
    where: GameImageWhereUniqueInput
  }

  /**
   * GameImage updateMany
   */
  export type GameImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameImages.
     */
    data: XOR<GameImageUpdateManyMutationInput, GameImageUncheckedUpdateManyInput>
    /**
     * Filter which GameImages to update
     */
    where?: GameImageWhereInput
    /**
     * Limit how many GameImages to update.
     */
    limit?: number
  }

  /**
   * GameImage updateManyAndReturn
   */
  export type GameImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameImage
     */
    select?: GameImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameImage
     */
    omit?: GameImageOmit<ExtArgs> | null
    /**
     * The data used to update GameImages.
     */
    data: XOR<GameImageUpdateManyMutationInput, GameImageUncheckedUpdateManyInput>
    /**
     * Filter which GameImages to update
     */
    where?: GameImageWhereInput
    /**
     * Limit how many GameImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameImage upsert
   */
  export type GameImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameImage
     */
    select?: GameImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameImage
     */
    omit?: GameImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameImageInclude<ExtArgs> | null
    /**
     * The filter to search for the GameImage to update in case it exists.
     */
    where: GameImageWhereUniqueInput
    /**
     * In case the GameImage found by the `where` argument doesn't exist, create a new GameImage with this data.
     */
    create: XOR<GameImageCreateInput, GameImageUncheckedCreateInput>
    /**
     * In case the GameImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameImageUpdateInput, GameImageUncheckedUpdateInput>
  }

  /**
   * GameImage delete
   */
  export type GameImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameImage
     */
    select?: GameImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameImage
     */
    omit?: GameImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameImageInclude<ExtArgs> | null
    /**
     * Filter which GameImage to delete.
     */
    where: GameImageWhereUniqueInput
  }

  /**
   * GameImage deleteMany
   */
  export type GameImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameImages to delete
     */
    where?: GameImageWhereInput
    /**
     * Limit how many GameImages to delete.
     */
    limit?: number
  }

  /**
   * GameImage without action
   */
  export type GameImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameImage
     */
    select?: GameImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameImage
     */
    omit?: GameImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameImageInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    id: number | null
    gameId: number | null
  }

  export type AchievementSumAggregateOutputType = {
    id: number | null
    gameId: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    gameId: number | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    gameId: number | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    title: number
    description: number
    gameId: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    id?: true
    gameId?: true
  }

  export type AchievementSumAggregateInputType = {
    id?: true
    gameId?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    gameId?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    gameId?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    gameId?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: number
    title: string
    description: string | null
    gameId: number
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    gameId?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    unlocks?: boolean | Achievement$unlocksArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    gameId?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    gameId?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    gameId?: boolean
  }

  export type AchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "gameId", ExtArgs["result"]["achievement"]>
  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    unlocks?: boolean | Achievement$unlocksArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
  }

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
      unlocks: Prisma.$AchievementUnlockPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      gameId: number
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements and returns the data updated in the database.
     * @param {AchievementUpdateManyAndReturnArgs} args - Arguments to update many Achievements.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, AchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unlocks<T extends Achievement$unlocksArgs<ExtArgs> = {}>(args?: Subset<T, Achievement$unlocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'Int'>
    readonly title: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly gameId: FieldRef<"Achievement", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement updateManyAndReturn
   */
  export type AchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to delete.
     */
    limit?: number
  }

  /**
   * Achievement.unlocks
   */
  export type Achievement$unlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    where?: AchievementUnlockWhereInput
    orderBy?: AchievementUnlockOrderByWithRelationInput | AchievementUnlockOrderByWithRelationInput[]
    cursor?: AchievementUnlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchievementUnlockScalarFieldEnum | AchievementUnlockScalarFieldEnum[]
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model AchievementUnlock
   */

  export type AggregateAchievementUnlock = {
    _count: AchievementUnlockCountAggregateOutputType | null
    _avg: AchievementUnlockAvgAggregateOutputType | null
    _sum: AchievementUnlockSumAggregateOutputType | null
    _min: AchievementUnlockMinAggregateOutputType | null
    _max: AchievementUnlockMaxAggregateOutputType | null
  }

  export type AchievementUnlockAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    achievementId: number | null
  }

  export type AchievementUnlockSumAggregateOutputType = {
    id: number | null
    userId: number | null
    achievementId: number | null
  }

  export type AchievementUnlockMinAggregateOutputType = {
    id: number | null
    unlockedAt: Date | null
    userId: number | null
    achievementId: number | null
  }

  export type AchievementUnlockMaxAggregateOutputType = {
    id: number | null
    unlockedAt: Date | null
    userId: number | null
    achievementId: number | null
  }

  export type AchievementUnlockCountAggregateOutputType = {
    id: number
    unlockedAt: number
    userId: number
    achievementId: number
    _all: number
  }


  export type AchievementUnlockAvgAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
  }

  export type AchievementUnlockSumAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
  }

  export type AchievementUnlockMinAggregateInputType = {
    id?: true
    unlockedAt?: true
    userId?: true
    achievementId?: true
  }

  export type AchievementUnlockMaxAggregateInputType = {
    id?: true
    unlockedAt?: true
    userId?: true
    achievementId?: true
  }

  export type AchievementUnlockCountAggregateInputType = {
    id?: true
    unlockedAt?: true
    userId?: true
    achievementId?: true
    _all?: true
  }

  export type AchievementUnlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AchievementUnlock to aggregate.
     */
    where?: AchievementUnlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementUnlocks to fetch.
     */
    orderBy?: AchievementUnlockOrderByWithRelationInput | AchievementUnlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementUnlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementUnlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementUnlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AchievementUnlocks
    **/
    _count?: true | AchievementUnlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementUnlockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementUnlockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementUnlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementUnlockMaxAggregateInputType
  }

  export type GetAchievementUnlockAggregateType<T extends AchievementUnlockAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievementUnlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievementUnlock[P]>
      : GetScalarType<T[P], AggregateAchievementUnlock[P]>
  }




  export type AchievementUnlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementUnlockWhereInput
    orderBy?: AchievementUnlockOrderByWithAggregationInput | AchievementUnlockOrderByWithAggregationInput[]
    by: AchievementUnlockScalarFieldEnum[] | AchievementUnlockScalarFieldEnum
    having?: AchievementUnlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementUnlockCountAggregateInputType | true
    _avg?: AchievementUnlockAvgAggregateInputType
    _sum?: AchievementUnlockSumAggregateInputType
    _min?: AchievementUnlockMinAggregateInputType
    _max?: AchievementUnlockMaxAggregateInputType
  }

  export type AchievementUnlockGroupByOutputType = {
    id: number
    unlockedAt: Date
    userId: number
    achievementId: number
    _count: AchievementUnlockCountAggregateOutputType | null
    _avg: AchievementUnlockAvgAggregateOutputType | null
    _sum: AchievementUnlockSumAggregateOutputType | null
    _min: AchievementUnlockMinAggregateOutputType | null
    _max: AchievementUnlockMaxAggregateOutputType | null
  }

  type GetAchievementUnlockGroupByPayload<T extends AchievementUnlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementUnlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementUnlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementUnlockGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementUnlockGroupByOutputType[P]>
        }
      >
    >


  export type AchievementUnlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unlockedAt?: boolean
    userId?: boolean
    achievementId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievementUnlock"]>

  export type AchievementUnlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unlockedAt?: boolean
    userId?: boolean
    achievementId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievementUnlock"]>

  export type AchievementUnlockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unlockedAt?: boolean
    userId?: boolean
    achievementId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievementUnlock"]>

  export type AchievementUnlockSelectScalar = {
    id?: boolean
    unlockedAt?: boolean
    userId?: boolean
    achievementId?: boolean
  }

  export type AchievementUnlockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unlockedAt" | "userId" | "achievementId", ExtArgs["result"]["achievementUnlock"]>
  export type AchievementUnlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }
  export type AchievementUnlockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }
  export type AchievementUnlockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }

  export type $AchievementUnlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AchievementUnlock"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      achievement: Prisma.$AchievementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      unlockedAt: Date
      userId: number
      achievementId: number
    }, ExtArgs["result"]["achievementUnlock"]>
    composites: {}
  }

  type AchievementUnlockGetPayload<S extends boolean | null | undefined | AchievementUnlockDefaultArgs> = $Result.GetResult<Prisma.$AchievementUnlockPayload, S>

  type AchievementUnlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AchievementUnlockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AchievementUnlockCountAggregateInputType | true
    }

  export interface AchievementUnlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AchievementUnlock'], meta: { name: 'AchievementUnlock' } }
    /**
     * Find zero or one AchievementUnlock that matches the filter.
     * @param {AchievementUnlockFindUniqueArgs} args - Arguments to find a AchievementUnlock
     * @example
     * // Get one AchievementUnlock
     * const achievementUnlock = await prisma.achievementUnlock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementUnlockFindUniqueArgs>(args: SelectSubset<T, AchievementUnlockFindUniqueArgs<ExtArgs>>): Prisma__AchievementUnlockClient<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AchievementUnlock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AchievementUnlockFindUniqueOrThrowArgs} args - Arguments to find a AchievementUnlock
     * @example
     * // Get one AchievementUnlock
     * const achievementUnlock = await prisma.achievementUnlock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementUnlockFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementUnlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementUnlockClient<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AchievementUnlock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUnlockFindFirstArgs} args - Arguments to find a AchievementUnlock
     * @example
     * // Get one AchievementUnlock
     * const achievementUnlock = await prisma.achievementUnlock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementUnlockFindFirstArgs>(args?: SelectSubset<T, AchievementUnlockFindFirstArgs<ExtArgs>>): Prisma__AchievementUnlockClient<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AchievementUnlock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUnlockFindFirstOrThrowArgs} args - Arguments to find a AchievementUnlock
     * @example
     * // Get one AchievementUnlock
     * const achievementUnlock = await prisma.achievementUnlock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementUnlockFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementUnlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementUnlockClient<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AchievementUnlocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUnlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AchievementUnlocks
     * const achievementUnlocks = await prisma.achievementUnlock.findMany()
     * 
     * // Get first 10 AchievementUnlocks
     * const achievementUnlocks = await prisma.achievementUnlock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementUnlockWithIdOnly = await prisma.achievementUnlock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementUnlockFindManyArgs>(args?: SelectSubset<T, AchievementUnlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AchievementUnlock.
     * @param {AchievementUnlockCreateArgs} args - Arguments to create a AchievementUnlock.
     * @example
     * // Create one AchievementUnlock
     * const AchievementUnlock = await prisma.achievementUnlock.create({
     *   data: {
     *     // ... data to create a AchievementUnlock
     *   }
     * })
     * 
     */
    create<T extends AchievementUnlockCreateArgs>(args: SelectSubset<T, AchievementUnlockCreateArgs<ExtArgs>>): Prisma__AchievementUnlockClient<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AchievementUnlocks.
     * @param {AchievementUnlockCreateManyArgs} args - Arguments to create many AchievementUnlocks.
     * @example
     * // Create many AchievementUnlocks
     * const achievementUnlock = await prisma.achievementUnlock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementUnlockCreateManyArgs>(args?: SelectSubset<T, AchievementUnlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AchievementUnlocks and returns the data saved in the database.
     * @param {AchievementUnlockCreateManyAndReturnArgs} args - Arguments to create many AchievementUnlocks.
     * @example
     * // Create many AchievementUnlocks
     * const achievementUnlock = await prisma.achievementUnlock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AchievementUnlocks and only return the `id`
     * const achievementUnlockWithIdOnly = await prisma.achievementUnlock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementUnlockCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementUnlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AchievementUnlock.
     * @param {AchievementUnlockDeleteArgs} args - Arguments to delete one AchievementUnlock.
     * @example
     * // Delete one AchievementUnlock
     * const AchievementUnlock = await prisma.achievementUnlock.delete({
     *   where: {
     *     // ... filter to delete one AchievementUnlock
     *   }
     * })
     * 
     */
    delete<T extends AchievementUnlockDeleteArgs>(args: SelectSubset<T, AchievementUnlockDeleteArgs<ExtArgs>>): Prisma__AchievementUnlockClient<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AchievementUnlock.
     * @param {AchievementUnlockUpdateArgs} args - Arguments to update one AchievementUnlock.
     * @example
     * // Update one AchievementUnlock
     * const achievementUnlock = await prisma.achievementUnlock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUnlockUpdateArgs>(args: SelectSubset<T, AchievementUnlockUpdateArgs<ExtArgs>>): Prisma__AchievementUnlockClient<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AchievementUnlocks.
     * @param {AchievementUnlockDeleteManyArgs} args - Arguments to filter AchievementUnlocks to delete.
     * @example
     * // Delete a few AchievementUnlocks
     * const { count } = await prisma.achievementUnlock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementUnlockDeleteManyArgs>(args?: SelectSubset<T, AchievementUnlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AchievementUnlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUnlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AchievementUnlocks
     * const achievementUnlock = await prisma.achievementUnlock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUnlockUpdateManyArgs>(args: SelectSubset<T, AchievementUnlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AchievementUnlocks and returns the data updated in the database.
     * @param {AchievementUnlockUpdateManyAndReturnArgs} args - Arguments to update many AchievementUnlocks.
     * @example
     * // Update many AchievementUnlocks
     * const achievementUnlock = await prisma.achievementUnlock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AchievementUnlocks and only return the `id`
     * const achievementUnlockWithIdOnly = await prisma.achievementUnlock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AchievementUnlockUpdateManyAndReturnArgs>(args: SelectSubset<T, AchievementUnlockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AchievementUnlock.
     * @param {AchievementUnlockUpsertArgs} args - Arguments to update or create a AchievementUnlock.
     * @example
     * // Update or create a AchievementUnlock
     * const achievementUnlock = await prisma.achievementUnlock.upsert({
     *   create: {
     *     // ... data to create a AchievementUnlock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AchievementUnlock we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUnlockUpsertArgs>(args: SelectSubset<T, AchievementUnlockUpsertArgs<ExtArgs>>): Prisma__AchievementUnlockClient<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AchievementUnlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUnlockCountArgs} args - Arguments to filter AchievementUnlocks to count.
     * @example
     * // Count the number of AchievementUnlocks
     * const count = await prisma.achievementUnlock.count({
     *   where: {
     *     // ... the filter for the AchievementUnlocks we want to count
     *   }
     * })
    **/
    count<T extends AchievementUnlockCountArgs>(
      args?: Subset<T, AchievementUnlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementUnlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AchievementUnlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUnlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementUnlockAggregateArgs>(args: Subset<T, AchievementUnlockAggregateArgs>): Prisma.PrismaPromise<GetAchievementUnlockAggregateType<T>>

    /**
     * Group by AchievementUnlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUnlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementUnlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementUnlockGroupByArgs['orderBy'] }
        : { orderBy?: AchievementUnlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementUnlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementUnlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AchievementUnlock model
   */
  readonly fields: AchievementUnlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AchievementUnlock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementUnlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    achievement<T extends AchievementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AchievementDefaultArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AchievementUnlock model
   */
  interface AchievementUnlockFieldRefs {
    readonly id: FieldRef<"AchievementUnlock", 'Int'>
    readonly unlockedAt: FieldRef<"AchievementUnlock", 'DateTime'>
    readonly userId: FieldRef<"AchievementUnlock", 'Int'>
    readonly achievementId: FieldRef<"AchievementUnlock", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AchievementUnlock findUnique
   */
  export type AchievementUnlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    /**
     * Filter, which AchievementUnlock to fetch.
     */
    where: AchievementUnlockWhereUniqueInput
  }

  /**
   * AchievementUnlock findUniqueOrThrow
   */
  export type AchievementUnlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    /**
     * Filter, which AchievementUnlock to fetch.
     */
    where: AchievementUnlockWhereUniqueInput
  }

  /**
   * AchievementUnlock findFirst
   */
  export type AchievementUnlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    /**
     * Filter, which AchievementUnlock to fetch.
     */
    where?: AchievementUnlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementUnlocks to fetch.
     */
    orderBy?: AchievementUnlockOrderByWithRelationInput | AchievementUnlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AchievementUnlocks.
     */
    cursor?: AchievementUnlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementUnlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementUnlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AchievementUnlocks.
     */
    distinct?: AchievementUnlockScalarFieldEnum | AchievementUnlockScalarFieldEnum[]
  }

  /**
   * AchievementUnlock findFirstOrThrow
   */
  export type AchievementUnlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    /**
     * Filter, which AchievementUnlock to fetch.
     */
    where?: AchievementUnlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementUnlocks to fetch.
     */
    orderBy?: AchievementUnlockOrderByWithRelationInput | AchievementUnlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AchievementUnlocks.
     */
    cursor?: AchievementUnlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementUnlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementUnlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AchievementUnlocks.
     */
    distinct?: AchievementUnlockScalarFieldEnum | AchievementUnlockScalarFieldEnum[]
  }

  /**
   * AchievementUnlock findMany
   */
  export type AchievementUnlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    /**
     * Filter, which AchievementUnlocks to fetch.
     */
    where?: AchievementUnlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementUnlocks to fetch.
     */
    orderBy?: AchievementUnlockOrderByWithRelationInput | AchievementUnlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AchievementUnlocks.
     */
    cursor?: AchievementUnlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementUnlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementUnlocks.
     */
    skip?: number
    distinct?: AchievementUnlockScalarFieldEnum | AchievementUnlockScalarFieldEnum[]
  }

  /**
   * AchievementUnlock create
   */
  export type AchievementUnlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    /**
     * The data needed to create a AchievementUnlock.
     */
    data: XOR<AchievementUnlockCreateInput, AchievementUnlockUncheckedCreateInput>
  }

  /**
   * AchievementUnlock createMany
   */
  export type AchievementUnlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AchievementUnlocks.
     */
    data: AchievementUnlockCreateManyInput | AchievementUnlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AchievementUnlock createManyAndReturn
   */
  export type AchievementUnlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * The data used to create many AchievementUnlocks.
     */
    data: AchievementUnlockCreateManyInput | AchievementUnlockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AchievementUnlock update
   */
  export type AchievementUnlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    /**
     * The data needed to update a AchievementUnlock.
     */
    data: XOR<AchievementUnlockUpdateInput, AchievementUnlockUncheckedUpdateInput>
    /**
     * Choose, which AchievementUnlock to update.
     */
    where: AchievementUnlockWhereUniqueInput
  }

  /**
   * AchievementUnlock updateMany
   */
  export type AchievementUnlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AchievementUnlocks.
     */
    data: XOR<AchievementUnlockUpdateManyMutationInput, AchievementUnlockUncheckedUpdateManyInput>
    /**
     * Filter which AchievementUnlocks to update
     */
    where?: AchievementUnlockWhereInput
    /**
     * Limit how many AchievementUnlocks to update.
     */
    limit?: number
  }

  /**
   * AchievementUnlock updateManyAndReturn
   */
  export type AchievementUnlockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * The data used to update AchievementUnlocks.
     */
    data: XOR<AchievementUnlockUpdateManyMutationInput, AchievementUnlockUncheckedUpdateManyInput>
    /**
     * Filter which AchievementUnlocks to update
     */
    where?: AchievementUnlockWhereInput
    /**
     * Limit how many AchievementUnlocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AchievementUnlock upsert
   */
  export type AchievementUnlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    /**
     * The filter to search for the AchievementUnlock to update in case it exists.
     */
    where: AchievementUnlockWhereUniqueInput
    /**
     * In case the AchievementUnlock found by the `where` argument doesn't exist, create a new AchievementUnlock with this data.
     */
    create: XOR<AchievementUnlockCreateInput, AchievementUnlockUncheckedCreateInput>
    /**
     * In case the AchievementUnlock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUnlockUpdateInput, AchievementUnlockUncheckedUpdateInput>
  }

  /**
   * AchievementUnlock delete
   */
  export type AchievementUnlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    /**
     * Filter which AchievementUnlock to delete.
     */
    where: AchievementUnlockWhereUniqueInput
  }

  /**
   * AchievementUnlock deleteMany
   */
  export type AchievementUnlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AchievementUnlocks to delete
     */
    where?: AchievementUnlockWhereInput
    /**
     * Limit how many AchievementUnlocks to delete.
     */
    limit?: number
  }

  /**
   * AchievementUnlock without action
   */
  export type AchievementUnlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
  }


  /**
   * Model EmailChange
   */

  export type AggregateEmailChange = {
    _count: EmailChangeCountAggregateOutputType | null
    _avg: EmailChangeAvgAggregateOutputType | null
    _sum: EmailChangeSumAggregateOutputType | null
    _min: EmailChangeMinAggregateOutputType | null
    _max: EmailChangeMaxAggregateOutputType | null
  }

  export type EmailChangeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type EmailChangeSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type EmailChangeMinAggregateOutputType = {
    id: number | null
    userId: number | null
    newEmail: string | null
    token: string | null
    createdAt: Date | null
  }

  export type EmailChangeMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    newEmail: string | null
    token: string | null
    createdAt: Date | null
  }

  export type EmailChangeCountAggregateOutputType = {
    id: number
    userId: number
    newEmail: number
    token: number
    createdAt: number
    _all: number
  }


  export type EmailChangeAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type EmailChangeSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type EmailChangeMinAggregateInputType = {
    id?: true
    userId?: true
    newEmail?: true
    token?: true
    createdAt?: true
  }

  export type EmailChangeMaxAggregateInputType = {
    id?: true
    userId?: true
    newEmail?: true
    token?: true
    createdAt?: true
  }

  export type EmailChangeCountAggregateInputType = {
    id?: true
    userId?: true
    newEmail?: true
    token?: true
    createdAt?: true
    _all?: true
  }

  export type EmailChangeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailChange to aggregate.
     */
    where?: EmailChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailChanges to fetch.
     */
    orderBy?: EmailChangeOrderByWithRelationInput | EmailChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailChanges
    **/
    _count?: true | EmailChangeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailChangeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailChangeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailChangeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailChangeMaxAggregateInputType
  }

  export type GetEmailChangeAggregateType<T extends EmailChangeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailChange]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailChange[P]>
      : GetScalarType<T[P], AggregateEmailChange[P]>
  }




  export type EmailChangeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailChangeWhereInput
    orderBy?: EmailChangeOrderByWithAggregationInput | EmailChangeOrderByWithAggregationInput[]
    by: EmailChangeScalarFieldEnum[] | EmailChangeScalarFieldEnum
    having?: EmailChangeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailChangeCountAggregateInputType | true
    _avg?: EmailChangeAvgAggregateInputType
    _sum?: EmailChangeSumAggregateInputType
    _min?: EmailChangeMinAggregateInputType
    _max?: EmailChangeMaxAggregateInputType
  }

  export type EmailChangeGroupByOutputType = {
    id: number
    userId: number
    newEmail: string
    token: string
    createdAt: Date
    _count: EmailChangeCountAggregateOutputType | null
    _avg: EmailChangeAvgAggregateOutputType | null
    _sum: EmailChangeSumAggregateOutputType | null
    _min: EmailChangeMinAggregateOutputType | null
    _max: EmailChangeMaxAggregateOutputType | null
  }

  type GetEmailChangeGroupByPayload<T extends EmailChangeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailChangeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailChangeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailChangeGroupByOutputType[P]>
            : GetScalarType<T[P], EmailChangeGroupByOutputType[P]>
        }
      >
    >


  export type EmailChangeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    newEmail?: boolean
    token?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailChange"]>

  export type EmailChangeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    newEmail?: boolean
    token?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailChange"]>

  export type EmailChangeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    newEmail?: boolean
    token?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailChange"]>

  export type EmailChangeSelectScalar = {
    id?: boolean
    userId?: boolean
    newEmail?: boolean
    token?: boolean
    createdAt?: boolean
  }

  export type EmailChangeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "newEmail" | "token" | "createdAt", ExtArgs["result"]["emailChange"]>
  export type EmailChangeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailChangeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailChangeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmailChangePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailChange"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      newEmail: string
      token: string
      createdAt: Date
    }, ExtArgs["result"]["emailChange"]>
    composites: {}
  }

  type EmailChangeGetPayload<S extends boolean | null | undefined | EmailChangeDefaultArgs> = $Result.GetResult<Prisma.$EmailChangePayload, S>

  type EmailChangeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailChangeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailChangeCountAggregateInputType | true
    }

  export interface EmailChangeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailChange'], meta: { name: 'EmailChange' } }
    /**
     * Find zero or one EmailChange that matches the filter.
     * @param {EmailChangeFindUniqueArgs} args - Arguments to find a EmailChange
     * @example
     * // Get one EmailChange
     * const emailChange = await prisma.emailChange.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailChangeFindUniqueArgs>(args: SelectSubset<T, EmailChangeFindUniqueArgs<ExtArgs>>): Prisma__EmailChangeClient<$Result.GetResult<Prisma.$EmailChangePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailChange that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailChangeFindUniqueOrThrowArgs} args - Arguments to find a EmailChange
     * @example
     * // Get one EmailChange
     * const emailChange = await prisma.emailChange.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailChangeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailChangeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailChangeClient<$Result.GetResult<Prisma.$EmailChangePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailChange that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailChangeFindFirstArgs} args - Arguments to find a EmailChange
     * @example
     * // Get one EmailChange
     * const emailChange = await prisma.emailChange.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailChangeFindFirstArgs>(args?: SelectSubset<T, EmailChangeFindFirstArgs<ExtArgs>>): Prisma__EmailChangeClient<$Result.GetResult<Prisma.$EmailChangePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailChange that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailChangeFindFirstOrThrowArgs} args - Arguments to find a EmailChange
     * @example
     * // Get one EmailChange
     * const emailChange = await prisma.emailChange.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailChangeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailChangeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailChangeClient<$Result.GetResult<Prisma.$EmailChangePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailChanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailChangeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailChanges
     * const emailChanges = await prisma.emailChange.findMany()
     * 
     * // Get first 10 EmailChanges
     * const emailChanges = await prisma.emailChange.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailChangeWithIdOnly = await prisma.emailChange.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailChangeFindManyArgs>(args?: SelectSubset<T, EmailChangeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailChangePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailChange.
     * @param {EmailChangeCreateArgs} args - Arguments to create a EmailChange.
     * @example
     * // Create one EmailChange
     * const EmailChange = await prisma.emailChange.create({
     *   data: {
     *     // ... data to create a EmailChange
     *   }
     * })
     * 
     */
    create<T extends EmailChangeCreateArgs>(args: SelectSubset<T, EmailChangeCreateArgs<ExtArgs>>): Prisma__EmailChangeClient<$Result.GetResult<Prisma.$EmailChangePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailChanges.
     * @param {EmailChangeCreateManyArgs} args - Arguments to create many EmailChanges.
     * @example
     * // Create many EmailChanges
     * const emailChange = await prisma.emailChange.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailChangeCreateManyArgs>(args?: SelectSubset<T, EmailChangeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailChanges and returns the data saved in the database.
     * @param {EmailChangeCreateManyAndReturnArgs} args - Arguments to create many EmailChanges.
     * @example
     * // Create many EmailChanges
     * const emailChange = await prisma.emailChange.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailChanges and only return the `id`
     * const emailChangeWithIdOnly = await prisma.emailChange.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailChangeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailChangeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailChangePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailChange.
     * @param {EmailChangeDeleteArgs} args - Arguments to delete one EmailChange.
     * @example
     * // Delete one EmailChange
     * const EmailChange = await prisma.emailChange.delete({
     *   where: {
     *     // ... filter to delete one EmailChange
     *   }
     * })
     * 
     */
    delete<T extends EmailChangeDeleteArgs>(args: SelectSubset<T, EmailChangeDeleteArgs<ExtArgs>>): Prisma__EmailChangeClient<$Result.GetResult<Prisma.$EmailChangePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailChange.
     * @param {EmailChangeUpdateArgs} args - Arguments to update one EmailChange.
     * @example
     * // Update one EmailChange
     * const emailChange = await prisma.emailChange.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailChangeUpdateArgs>(args: SelectSubset<T, EmailChangeUpdateArgs<ExtArgs>>): Prisma__EmailChangeClient<$Result.GetResult<Prisma.$EmailChangePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailChanges.
     * @param {EmailChangeDeleteManyArgs} args - Arguments to filter EmailChanges to delete.
     * @example
     * // Delete a few EmailChanges
     * const { count } = await prisma.emailChange.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailChangeDeleteManyArgs>(args?: SelectSubset<T, EmailChangeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailChangeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailChanges
     * const emailChange = await prisma.emailChange.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailChangeUpdateManyArgs>(args: SelectSubset<T, EmailChangeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailChanges and returns the data updated in the database.
     * @param {EmailChangeUpdateManyAndReturnArgs} args - Arguments to update many EmailChanges.
     * @example
     * // Update many EmailChanges
     * const emailChange = await prisma.emailChange.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailChanges and only return the `id`
     * const emailChangeWithIdOnly = await prisma.emailChange.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailChangeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailChangeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailChangePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailChange.
     * @param {EmailChangeUpsertArgs} args - Arguments to update or create a EmailChange.
     * @example
     * // Update or create a EmailChange
     * const emailChange = await prisma.emailChange.upsert({
     *   create: {
     *     // ... data to create a EmailChange
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailChange we want to update
     *   }
     * })
     */
    upsert<T extends EmailChangeUpsertArgs>(args: SelectSubset<T, EmailChangeUpsertArgs<ExtArgs>>): Prisma__EmailChangeClient<$Result.GetResult<Prisma.$EmailChangePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailChangeCountArgs} args - Arguments to filter EmailChanges to count.
     * @example
     * // Count the number of EmailChanges
     * const count = await prisma.emailChange.count({
     *   where: {
     *     // ... the filter for the EmailChanges we want to count
     *   }
     * })
    **/
    count<T extends EmailChangeCountArgs>(
      args?: Subset<T, EmailChangeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailChangeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailChangeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailChangeAggregateArgs>(args: Subset<T, EmailChangeAggregateArgs>): Prisma.PrismaPromise<GetEmailChangeAggregateType<T>>

    /**
     * Group by EmailChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailChangeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailChangeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailChangeGroupByArgs['orderBy'] }
        : { orderBy?: EmailChangeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailChangeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailChangeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailChange model
   */
  readonly fields: EmailChangeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailChange.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailChangeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailChange model
   */
  interface EmailChangeFieldRefs {
    readonly id: FieldRef<"EmailChange", 'Int'>
    readonly userId: FieldRef<"EmailChange", 'Int'>
    readonly newEmail: FieldRef<"EmailChange", 'String'>
    readonly token: FieldRef<"EmailChange", 'String'>
    readonly createdAt: FieldRef<"EmailChange", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailChange findUnique
   */
  export type EmailChangeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChange
     */
    select?: EmailChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChange
     */
    omit?: EmailChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeInclude<ExtArgs> | null
    /**
     * Filter, which EmailChange to fetch.
     */
    where: EmailChangeWhereUniqueInput
  }

  /**
   * EmailChange findUniqueOrThrow
   */
  export type EmailChangeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChange
     */
    select?: EmailChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChange
     */
    omit?: EmailChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeInclude<ExtArgs> | null
    /**
     * Filter, which EmailChange to fetch.
     */
    where: EmailChangeWhereUniqueInput
  }

  /**
   * EmailChange findFirst
   */
  export type EmailChangeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChange
     */
    select?: EmailChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChange
     */
    omit?: EmailChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeInclude<ExtArgs> | null
    /**
     * Filter, which EmailChange to fetch.
     */
    where?: EmailChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailChanges to fetch.
     */
    orderBy?: EmailChangeOrderByWithRelationInput | EmailChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailChanges.
     */
    cursor?: EmailChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailChanges.
     */
    distinct?: EmailChangeScalarFieldEnum | EmailChangeScalarFieldEnum[]
  }

  /**
   * EmailChange findFirstOrThrow
   */
  export type EmailChangeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChange
     */
    select?: EmailChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChange
     */
    omit?: EmailChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeInclude<ExtArgs> | null
    /**
     * Filter, which EmailChange to fetch.
     */
    where?: EmailChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailChanges to fetch.
     */
    orderBy?: EmailChangeOrderByWithRelationInput | EmailChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailChanges.
     */
    cursor?: EmailChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailChanges.
     */
    distinct?: EmailChangeScalarFieldEnum | EmailChangeScalarFieldEnum[]
  }

  /**
   * EmailChange findMany
   */
  export type EmailChangeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChange
     */
    select?: EmailChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChange
     */
    omit?: EmailChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeInclude<ExtArgs> | null
    /**
     * Filter, which EmailChanges to fetch.
     */
    where?: EmailChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailChanges to fetch.
     */
    orderBy?: EmailChangeOrderByWithRelationInput | EmailChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailChanges.
     */
    cursor?: EmailChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailChanges.
     */
    skip?: number
    distinct?: EmailChangeScalarFieldEnum | EmailChangeScalarFieldEnum[]
  }

  /**
   * EmailChange create
   */
  export type EmailChangeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChange
     */
    select?: EmailChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChange
     */
    omit?: EmailChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailChange.
     */
    data: XOR<EmailChangeCreateInput, EmailChangeUncheckedCreateInput>
  }

  /**
   * EmailChange createMany
   */
  export type EmailChangeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailChanges.
     */
    data: EmailChangeCreateManyInput | EmailChangeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailChange createManyAndReturn
   */
  export type EmailChangeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChange
     */
    select?: EmailChangeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChange
     */
    omit?: EmailChangeOmit<ExtArgs> | null
    /**
     * The data used to create many EmailChanges.
     */
    data: EmailChangeCreateManyInput | EmailChangeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailChange update
   */
  export type EmailChangeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChange
     */
    select?: EmailChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChange
     */
    omit?: EmailChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailChange.
     */
    data: XOR<EmailChangeUpdateInput, EmailChangeUncheckedUpdateInput>
    /**
     * Choose, which EmailChange to update.
     */
    where: EmailChangeWhereUniqueInput
  }

  /**
   * EmailChange updateMany
   */
  export type EmailChangeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailChanges.
     */
    data: XOR<EmailChangeUpdateManyMutationInput, EmailChangeUncheckedUpdateManyInput>
    /**
     * Filter which EmailChanges to update
     */
    where?: EmailChangeWhereInput
    /**
     * Limit how many EmailChanges to update.
     */
    limit?: number
  }

  /**
   * EmailChange updateManyAndReturn
   */
  export type EmailChangeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChange
     */
    select?: EmailChangeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChange
     */
    omit?: EmailChangeOmit<ExtArgs> | null
    /**
     * The data used to update EmailChanges.
     */
    data: XOR<EmailChangeUpdateManyMutationInput, EmailChangeUncheckedUpdateManyInput>
    /**
     * Filter which EmailChanges to update
     */
    where?: EmailChangeWhereInput
    /**
     * Limit how many EmailChanges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailChange upsert
   */
  export type EmailChangeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChange
     */
    select?: EmailChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChange
     */
    omit?: EmailChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailChange to update in case it exists.
     */
    where: EmailChangeWhereUniqueInput
    /**
     * In case the EmailChange found by the `where` argument doesn't exist, create a new EmailChange with this data.
     */
    create: XOR<EmailChangeCreateInput, EmailChangeUncheckedCreateInput>
    /**
     * In case the EmailChange was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailChangeUpdateInput, EmailChangeUncheckedUpdateInput>
  }

  /**
   * EmailChange delete
   */
  export type EmailChangeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChange
     */
    select?: EmailChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChange
     */
    omit?: EmailChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeInclude<ExtArgs> | null
    /**
     * Filter which EmailChange to delete.
     */
    where: EmailChangeWhereUniqueInput
  }

  /**
   * EmailChange deleteMany
   */
  export type EmailChangeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailChanges to delete
     */
    where?: EmailChangeWhereInput
    /**
     * Limit how many EmailChanges to delete.
     */
    limit?: number
  }

  /**
   * EmailChange without action
   */
  export type EmailChangeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChange
     */
    select?: EmailChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChange
     */
    omit?: EmailChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeInclude<ExtArgs> | null
  }


  /**
   * Model EmailVerification
   */

  export type AggregateEmailVerification = {
    _count: EmailVerificationCountAggregateOutputType | null
    _avg: EmailVerificationAvgAggregateOutputType | null
    _sum: EmailVerificationSumAggregateOutputType | null
    _min: EmailVerificationMinAggregateOutputType | null
    _max: EmailVerificationMaxAggregateOutputType | null
  }

  export type EmailVerificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type EmailVerificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type EmailVerificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type EmailVerificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type EmailVerificationCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type EmailVerificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type EmailVerificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type EmailVerificationMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    createdAt?: true
    expiresAt?: true
  }

  export type EmailVerificationMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    createdAt?: true
    expiresAt?: true
  }

  export type EmailVerificationCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type EmailVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailVerification to aggregate.
     */
    where?: EmailVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerifications to fetch.
     */
    orderBy?: EmailVerificationOrderByWithRelationInput | EmailVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailVerifications
    **/
    _count?: true | EmailVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailVerificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailVerificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailVerificationMaxAggregateInputType
  }

  export type GetEmailVerificationAggregateType<T extends EmailVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailVerification[P]>
      : GetScalarType<T[P], AggregateEmailVerification[P]>
  }




  export type EmailVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailVerificationWhereInput
    orderBy?: EmailVerificationOrderByWithAggregationInput | EmailVerificationOrderByWithAggregationInput[]
    by: EmailVerificationScalarFieldEnum[] | EmailVerificationScalarFieldEnum
    having?: EmailVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailVerificationCountAggregateInputType | true
    _avg?: EmailVerificationAvgAggregateInputType
    _sum?: EmailVerificationSumAggregateInputType
    _min?: EmailVerificationMinAggregateInputType
    _max?: EmailVerificationMaxAggregateInputType
  }

  export type EmailVerificationGroupByOutputType = {
    id: number
    userId: number
    token: string
    createdAt: Date
    expiresAt: Date
    _count: EmailVerificationCountAggregateOutputType | null
    _avg: EmailVerificationAvgAggregateOutputType | null
    _sum: EmailVerificationSumAggregateOutputType | null
    _min: EmailVerificationMinAggregateOutputType | null
    _max: EmailVerificationMaxAggregateOutputType | null
  }

  type GetEmailVerificationGroupByPayload<T extends EmailVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], EmailVerificationGroupByOutputType[P]>
        }
      >
    >


  export type EmailVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailVerification"]>

  export type EmailVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailVerification"]>

  export type EmailVerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailVerification"]>

  export type EmailVerificationSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type EmailVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "createdAt" | "expiresAt", ExtArgs["result"]["emailVerification"]>
  export type EmailVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailVerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailVerificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmailVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailVerification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      token: string
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["emailVerification"]>
    composites: {}
  }

  type EmailVerificationGetPayload<S extends boolean | null | undefined | EmailVerificationDefaultArgs> = $Result.GetResult<Prisma.$EmailVerificationPayload, S>

  type EmailVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailVerificationCountAggregateInputType | true
    }

  export interface EmailVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailVerification'], meta: { name: 'EmailVerification' } }
    /**
     * Find zero or one EmailVerification that matches the filter.
     * @param {EmailVerificationFindUniqueArgs} args - Arguments to find a EmailVerification
     * @example
     * // Get one EmailVerification
     * const emailVerification = await prisma.emailVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailVerificationFindUniqueArgs>(args: SelectSubset<T, EmailVerificationFindUniqueArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailVerificationFindUniqueOrThrowArgs} args - Arguments to find a EmailVerification
     * @example
     * // Get one EmailVerification
     * const emailVerification = await prisma.emailVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationFindFirstArgs} args - Arguments to find a EmailVerification
     * @example
     * // Get one EmailVerification
     * const emailVerification = await prisma.emailVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailVerificationFindFirstArgs>(args?: SelectSubset<T, EmailVerificationFindFirstArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationFindFirstOrThrowArgs} args - Arguments to find a EmailVerification
     * @example
     * // Get one EmailVerification
     * const emailVerification = await prisma.emailVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailVerifications
     * const emailVerifications = await prisma.emailVerification.findMany()
     * 
     * // Get first 10 EmailVerifications
     * const emailVerifications = await prisma.emailVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailVerificationWithIdOnly = await prisma.emailVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailVerificationFindManyArgs>(args?: SelectSubset<T, EmailVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailVerification.
     * @param {EmailVerificationCreateArgs} args - Arguments to create a EmailVerification.
     * @example
     * // Create one EmailVerification
     * const EmailVerification = await prisma.emailVerification.create({
     *   data: {
     *     // ... data to create a EmailVerification
     *   }
     * })
     * 
     */
    create<T extends EmailVerificationCreateArgs>(args: SelectSubset<T, EmailVerificationCreateArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailVerifications.
     * @param {EmailVerificationCreateManyArgs} args - Arguments to create many EmailVerifications.
     * @example
     * // Create many EmailVerifications
     * const emailVerification = await prisma.emailVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailVerificationCreateManyArgs>(args?: SelectSubset<T, EmailVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailVerifications and returns the data saved in the database.
     * @param {EmailVerificationCreateManyAndReturnArgs} args - Arguments to create many EmailVerifications.
     * @example
     * // Create many EmailVerifications
     * const emailVerification = await prisma.emailVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailVerifications and only return the `id`
     * const emailVerificationWithIdOnly = await prisma.emailVerification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailVerification.
     * @param {EmailVerificationDeleteArgs} args - Arguments to delete one EmailVerification.
     * @example
     * // Delete one EmailVerification
     * const EmailVerification = await prisma.emailVerification.delete({
     *   where: {
     *     // ... filter to delete one EmailVerification
     *   }
     * })
     * 
     */
    delete<T extends EmailVerificationDeleteArgs>(args: SelectSubset<T, EmailVerificationDeleteArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailVerification.
     * @param {EmailVerificationUpdateArgs} args - Arguments to update one EmailVerification.
     * @example
     * // Update one EmailVerification
     * const emailVerification = await prisma.emailVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailVerificationUpdateArgs>(args: SelectSubset<T, EmailVerificationUpdateArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailVerifications.
     * @param {EmailVerificationDeleteManyArgs} args - Arguments to filter EmailVerifications to delete.
     * @example
     * // Delete a few EmailVerifications
     * const { count } = await prisma.emailVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailVerificationDeleteManyArgs>(args?: SelectSubset<T, EmailVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailVerifications
     * const emailVerification = await prisma.emailVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailVerificationUpdateManyArgs>(args: SelectSubset<T, EmailVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailVerifications and returns the data updated in the database.
     * @param {EmailVerificationUpdateManyAndReturnArgs} args - Arguments to update many EmailVerifications.
     * @example
     * // Update many EmailVerifications
     * const emailVerification = await prisma.emailVerification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailVerifications and only return the `id`
     * const emailVerificationWithIdOnly = await prisma.emailVerification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailVerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailVerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailVerification.
     * @param {EmailVerificationUpsertArgs} args - Arguments to update or create a EmailVerification.
     * @example
     * // Update or create a EmailVerification
     * const emailVerification = await prisma.emailVerification.upsert({
     *   create: {
     *     // ... data to create a EmailVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailVerification we want to update
     *   }
     * })
     */
    upsert<T extends EmailVerificationUpsertArgs>(args: SelectSubset<T, EmailVerificationUpsertArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationCountArgs} args - Arguments to filter EmailVerifications to count.
     * @example
     * // Count the number of EmailVerifications
     * const count = await prisma.emailVerification.count({
     *   where: {
     *     // ... the filter for the EmailVerifications we want to count
     *   }
     * })
    **/
    count<T extends EmailVerificationCountArgs>(
      args?: Subset<T, EmailVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailVerificationAggregateArgs>(args: Subset<T, EmailVerificationAggregateArgs>): Prisma.PrismaPromise<GetEmailVerificationAggregateType<T>>

    /**
     * Group by EmailVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailVerificationGroupByArgs['orderBy'] }
        : { orderBy?: EmailVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailVerification model
   */
  readonly fields: EmailVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailVerification model
   */
  interface EmailVerificationFieldRefs {
    readonly id: FieldRef<"EmailVerification", 'Int'>
    readonly userId: FieldRef<"EmailVerification", 'Int'>
    readonly token: FieldRef<"EmailVerification", 'String'>
    readonly createdAt: FieldRef<"EmailVerification", 'DateTime'>
    readonly expiresAt: FieldRef<"EmailVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailVerification findUnique
   */
  export type EmailVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerification to fetch.
     */
    where: EmailVerificationWhereUniqueInput
  }

  /**
   * EmailVerification findUniqueOrThrow
   */
  export type EmailVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerification to fetch.
     */
    where: EmailVerificationWhereUniqueInput
  }

  /**
   * EmailVerification findFirst
   */
  export type EmailVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerification to fetch.
     */
    where?: EmailVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerifications to fetch.
     */
    orderBy?: EmailVerificationOrderByWithRelationInput | EmailVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailVerifications.
     */
    cursor?: EmailVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailVerifications.
     */
    distinct?: EmailVerificationScalarFieldEnum | EmailVerificationScalarFieldEnum[]
  }

  /**
   * EmailVerification findFirstOrThrow
   */
  export type EmailVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerification to fetch.
     */
    where?: EmailVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerifications to fetch.
     */
    orderBy?: EmailVerificationOrderByWithRelationInput | EmailVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailVerifications.
     */
    cursor?: EmailVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailVerifications.
     */
    distinct?: EmailVerificationScalarFieldEnum | EmailVerificationScalarFieldEnum[]
  }

  /**
   * EmailVerification findMany
   */
  export type EmailVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerifications to fetch.
     */
    where?: EmailVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerifications to fetch.
     */
    orderBy?: EmailVerificationOrderByWithRelationInput | EmailVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailVerifications.
     */
    cursor?: EmailVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerifications.
     */
    skip?: number
    distinct?: EmailVerificationScalarFieldEnum | EmailVerificationScalarFieldEnum[]
  }

  /**
   * EmailVerification create
   */
  export type EmailVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailVerification.
     */
    data: XOR<EmailVerificationCreateInput, EmailVerificationUncheckedCreateInput>
  }

  /**
   * EmailVerification createMany
   */
  export type EmailVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailVerifications.
     */
    data: EmailVerificationCreateManyInput | EmailVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailVerification createManyAndReturn
   */
  export type EmailVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * The data used to create many EmailVerifications.
     */
    data: EmailVerificationCreateManyInput | EmailVerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailVerification update
   */
  export type EmailVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailVerification.
     */
    data: XOR<EmailVerificationUpdateInput, EmailVerificationUncheckedUpdateInput>
    /**
     * Choose, which EmailVerification to update.
     */
    where: EmailVerificationWhereUniqueInput
  }

  /**
   * EmailVerification updateMany
   */
  export type EmailVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailVerifications.
     */
    data: XOR<EmailVerificationUpdateManyMutationInput, EmailVerificationUncheckedUpdateManyInput>
    /**
     * Filter which EmailVerifications to update
     */
    where?: EmailVerificationWhereInput
    /**
     * Limit how many EmailVerifications to update.
     */
    limit?: number
  }

  /**
   * EmailVerification updateManyAndReturn
   */
  export type EmailVerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * The data used to update EmailVerifications.
     */
    data: XOR<EmailVerificationUpdateManyMutationInput, EmailVerificationUncheckedUpdateManyInput>
    /**
     * Filter which EmailVerifications to update
     */
    where?: EmailVerificationWhereInput
    /**
     * Limit how many EmailVerifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailVerification upsert
   */
  export type EmailVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailVerification to update in case it exists.
     */
    where: EmailVerificationWhereUniqueInput
    /**
     * In case the EmailVerification found by the `where` argument doesn't exist, create a new EmailVerification with this data.
     */
    create: XOR<EmailVerificationCreateInput, EmailVerificationUncheckedCreateInput>
    /**
     * In case the EmailVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailVerificationUpdateInput, EmailVerificationUncheckedUpdateInput>
  }

  /**
   * EmailVerification delete
   */
  export type EmailVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * Filter which EmailVerification to delete.
     */
    where: EmailVerificationWhereUniqueInput
  }

  /**
   * EmailVerification deleteMany
   */
  export type EmailVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailVerifications to delete
     */
    where?: EmailVerificationWhereInput
    /**
     * Limit how many EmailVerifications to delete.
     */
    limit?: number
  }

  /**
   * EmailVerification without action
   */
  export type EmailVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
  }


  /**
   * Model PasswordReset
   */

  export type AggregatePasswordReset = {
    _count: PasswordResetCountAggregateOutputType | null
    _avg: PasswordResetAvgAggregateOutputType | null
    _sum: PasswordResetSumAggregateOutputType | null
    _min: PasswordResetMinAggregateOutputType | null
    _max: PasswordResetMaxAggregateOutputType | null
  }

  export type PasswordResetAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PasswordResetSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PasswordResetMinAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type PasswordResetMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type PasswordResetCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type PasswordResetAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PasswordResetSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PasswordResetMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    createdAt?: true
    expiresAt?: true
  }

  export type PasswordResetMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    createdAt?: true
    expiresAt?: true
  }

  export type PasswordResetCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type PasswordResetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordReset to aggregate.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResets
    **/
    _count?: true | PasswordResetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasswordResetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasswordResetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetMaxAggregateInputType
  }

  export type GetPasswordResetAggregateType<T extends PasswordResetAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordReset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordReset[P]>
      : GetScalarType<T[P], AggregatePasswordReset[P]>
  }




  export type PasswordResetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetWhereInput
    orderBy?: PasswordResetOrderByWithAggregationInput | PasswordResetOrderByWithAggregationInput[]
    by: PasswordResetScalarFieldEnum[] | PasswordResetScalarFieldEnum
    having?: PasswordResetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetCountAggregateInputType | true
    _avg?: PasswordResetAvgAggregateInputType
    _sum?: PasswordResetSumAggregateInputType
    _min?: PasswordResetMinAggregateInputType
    _max?: PasswordResetMaxAggregateInputType
  }

  export type PasswordResetGroupByOutputType = {
    id: number
    userId: number
    token: string
    createdAt: Date
    expiresAt: Date
    _count: PasswordResetCountAggregateOutputType | null
    _avg: PasswordResetAvgAggregateOutputType | null
    _sum: PasswordResetSumAggregateOutputType | null
    _min: PasswordResetMinAggregateOutputType | null
    _max: PasswordResetMaxAggregateOutputType | null
  }

  type GetPasswordResetGroupByPayload<T extends PasswordResetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type PasswordResetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "createdAt" | "expiresAt", ExtArgs["result"]["passwordReset"]>
  export type PasswordResetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordReset"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      token: string
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["passwordReset"]>
    composites: {}
  }

  type PasswordResetGetPayload<S extends boolean | null | undefined | PasswordResetDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetPayload, S>

  type PasswordResetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetCountAggregateInputType | true
    }

  export interface PasswordResetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordReset'], meta: { name: 'PasswordReset' } }
    /**
     * Find zero or one PasswordReset that matches the filter.
     * @param {PasswordResetFindUniqueArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetFindUniqueArgs>(args: SelectSubset<T, PasswordResetFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordReset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetFindUniqueOrThrowArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordReset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindFirstArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetFindFirstArgs>(args?: SelectSubset<T, PasswordResetFindFirstArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordReset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindFirstOrThrowArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResets
     * const passwordResets = await prisma.passwordReset.findMany()
     * 
     * // Get first 10 PasswordResets
     * const passwordResets = await prisma.passwordReset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetFindManyArgs>(args?: SelectSubset<T, PasswordResetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordReset.
     * @param {PasswordResetCreateArgs} args - Arguments to create a PasswordReset.
     * @example
     * // Create one PasswordReset
     * const PasswordReset = await prisma.passwordReset.create({
     *   data: {
     *     // ... data to create a PasswordReset
     *   }
     * })
     * 
     */
    create<T extends PasswordResetCreateArgs>(args: SelectSubset<T, PasswordResetCreateArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResets.
     * @param {PasswordResetCreateManyArgs} args - Arguments to create many PasswordResets.
     * @example
     * // Create many PasswordResets
     * const passwordReset = await prisma.passwordReset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetCreateManyArgs>(args?: SelectSubset<T, PasswordResetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResets and returns the data saved in the database.
     * @param {PasswordResetCreateManyAndReturnArgs} args - Arguments to create many PasswordResets.
     * @example
     * // Create many PasswordResets
     * const passwordReset = await prisma.passwordReset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResets and only return the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordReset.
     * @param {PasswordResetDeleteArgs} args - Arguments to delete one PasswordReset.
     * @example
     * // Delete one PasswordReset
     * const PasswordReset = await prisma.passwordReset.delete({
     *   where: {
     *     // ... filter to delete one PasswordReset
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetDeleteArgs>(args: SelectSubset<T, PasswordResetDeleteArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordReset.
     * @param {PasswordResetUpdateArgs} args - Arguments to update one PasswordReset.
     * @example
     * // Update one PasswordReset
     * const passwordReset = await prisma.passwordReset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetUpdateArgs>(args: SelectSubset<T, PasswordResetUpdateArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResets.
     * @param {PasswordResetDeleteManyArgs} args - Arguments to filter PasswordResets to delete.
     * @example
     * // Delete a few PasswordResets
     * const { count } = await prisma.passwordReset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetDeleteManyArgs>(args?: SelectSubset<T, PasswordResetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResets
     * const passwordReset = await prisma.passwordReset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetUpdateManyArgs>(args: SelectSubset<T, PasswordResetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResets and returns the data updated in the database.
     * @param {PasswordResetUpdateManyAndReturnArgs} args - Arguments to update many PasswordResets.
     * @example
     * // Update many PasswordResets
     * const passwordReset = await prisma.passwordReset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResets and only return the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordReset.
     * @param {PasswordResetUpsertArgs} args - Arguments to update or create a PasswordReset.
     * @example
     * // Update or create a PasswordReset
     * const passwordReset = await prisma.passwordReset.upsert({
     *   create: {
     *     // ... data to create a PasswordReset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordReset we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetUpsertArgs>(args: SelectSubset<T, PasswordResetUpsertArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetCountArgs} args - Arguments to filter PasswordResets to count.
     * @example
     * // Count the number of PasswordResets
     * const count = await prisma.passwordReset.count({
     *   where: {
     *     // ... the filter for the PasswordResets we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetCountArgs>(
      args?: Subset<T, PasswordResetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetAggregateArgs>(args: Subset<T, PasswordResetAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetAggregateType<T>>

    /**
     * Group by PasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordReset model
   */
  readonly fields: PasswordResetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordReset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordReset model
   */
  interface PasswordResetFieldRefs {
    readonly id: FieldRef<"PasswordReset", 'Int'>
    readonly userId: FieldRef<"PasswordReset", 'Int'>
    readonly token: FieldRef<"PasswordReset", 'String'>
    readonly createdAt: FieldRef<"PasswordReset", 'DateTime'>
    readonly expiresAt: FieldRef<"PasswordReset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordReset findUnique
   */
  export type PasswordResetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset findUniqueOrThrow
   */
  export type PasswordResetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset findFirst
   */
  export type PasswordResetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResets.
     */
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset findFirstOrThrow
   */
  export type PasswordResetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResets.
     */
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset findMany
   */
  export type PasswordResetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResets to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset create
   */
  export type PasswordResetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordReset.
     */
    data: XOR<PasswordResetCreateInput, PasswordResetUncheckedCreateInput>
  }

  /**
   * PasswordReset createMany
   */
  export type PasswordResetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResets.
     */
    data: PasswordResetCreateManyInput | PasswordResetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordReset createManyAndReturn
   */
  export type PasswordResetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResets.
     */
    data: PasswordResetCreateManyInput | PasswordResetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordReset update
   */
  export type PasswordResetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordReset.
     */
    data: XOR<PasswordResetUpdateInput, PasswordResetUncheckedUpdateInput>
    /**
     * Choose, which PasswordReset to update.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset updateMany
   */
  export type PasswordResetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResets.
     */
    data: XOR<PasswordResetUpdateManyMutationInput, PasswordResetUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResets to update
     */
    where?: PasswordResetWhereInput
    /**
     * Limit how many PasswordResets to update.
     */
    limit?: number
  }

  /**
   * PasswordReset updateManyAndReturn
   */
  export type PasswordResetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResets.
     */
    data: XOR<PasswordResetUpdateManyMutationInput, PasswordResetUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResets to update
     */
    where?: PasswordResetWhereInput
    /**
     * Limit how many PasswordResets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordReset upsert
   */
  export type PasswordResetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordReset to update in case it exists.
     */
    where: PasswordResetWhereUniqueInput
    /**
     * In case the PasswordReset found by the `where` argument doesn't exist, create a new PasswordReset with this data.
     */
    create: XOR<PasswordResetCreateInput, PasswordResetUncheckedCreateInput>
    /**
     * In case the PasswordReset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetUpdateInput, PasswordResetUncheckedUpdateInput>
  }

  /**
   * PasswordReset delete
   */
  export type PasswordResetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter which PasswordReset to delete.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset deleteMany
   */
  export type PasswordResetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResets to delete
     */
    where?: PasswordResetWhereInput
    /**
     * Limit how many PasswordResets to delete.
     */
    limit?: number
  }

  /**
   * PasswordReset without action
   */
  export type PasswordResetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
  }


  /**
   * Model Friendship
   */

  export type AggregateFriendship = {
    _count: FriendshipCountAggregateOutputType | null
    _avg: FriendshipAvgAggregateOutputType | null
    _sum: FriendshipSumAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  export type FriendshipAvgAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
  }

  export type FriendshipSumAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
  }

  export type FriendshipMinAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
    status: $Enums.FriendshipStatus | null
    createdAt: Date | null
  }

  export type FriendshipMaxAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
    status: $Enums.FriendshipStatus | null
    createdAt: Date | null
  }

  export type FriendshipCountAggregateOutputType = {
    id: number
    senderId: number
    receiverId: number
    status: number
    createdAt: number
    _all: number
  }


  export type FriendshipAvgAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
  }

  export type FriendshipSumAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
  }

  export type FriendshipMinAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    status?: true
    createdAt?: true
  }

  export type FriendshipMaxAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    status?: true
    createdAt?: true
  }

  export type FriendshipCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type FriendshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friendship to aggregate.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Friendships
    **/
    _count?: true | FriendshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FriendshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FriendshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendshipMaxAggregateInputType
  }

  export type GetFriendshipAggregateType<T extends FriendshipAggregateArgs> = {
        [P in keyof T & keyof AggregateFriendship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriendship[P]>
      : GetScalarType<T[P], AggregateFriendship[P]>
  }




  export type FriendshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithAggregationInput | FriendshipOrderByWithAggregationInput[]
    by: FriendshipScalarFieldEnum[] | FriendshipScalarFieldEnum
    having?: FriendshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendshipCountAggregateInputType | true
    _avg?: FriendshipAvgAggregateInputType
    _sum?: FriendshipSumAggregateInputType
    _min?: FriendshipMinAggregateInputType
    _max?: FriendshipMaxAggregateInputType
  }

  export type FriendshipGroupByOutputType = {
    id: number
    senderId: number
    receiverId: number
    status: $Enums.FriendshipStatus
    createdAt: Date
    _count: FriendshipCountAggregateOutputType | null
    _avg: FriendshipAvgAggregateOutputType | null
    _sum: FriendshipSumAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  type GetFriendshipGroupByPayload<T extends FriendshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FriendshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
            : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
        }
      >
    >


  export type FriendshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    status?: boolean
    createdAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type FriendshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    status?: boolean
    createdAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type FriendshipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    status?: boolean
    createdAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type FriendshipSelectScalar = {
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type FriendshipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "senderId" | "receiverId" | "status" | "createdAt", ExtArgs["result"]["friendship"]>
  export type FriendshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FriendshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FriendshipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FriendshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Friendship"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      receiver: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      senderId: number
      receiverId: number
      status: $Enums.FriendshipStatus
      createdAt: Date
    }, ExtArgs["result"]["friendship"]>
    composites: {}
  }

  type FriendshipGetPayload<S extends boolean | null | undefined | FriendshipDefaultArgs> = $Result.GetResult<Prisma.$FriendshipPayload, S>

  type FriendshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FriendshipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FriendshipCountAggregateInputType | true
    }

  export interface FriendshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Friendship'], meta: { name: 'Friendship' } }
    /**
     * Find zero or one Friendship that matches the filter.
     * @param {FriendshipFindUniqueArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FriendshipFindUniqueArgs>(args: SelectSubset<T, FriendshipFindUniqueArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Friendship that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FriendshipFindUniqueOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FriendshipFindUniqueOrThrowArgs>(args: SelectSubset<T, FriendshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Friendship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindFirstArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FriendshipFindFirstArgs>(args?: SelectSubset<T, FriendshipFindFirstArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Friendship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindFirstOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FriendshipFindFirstOrThrowArgs>(args?: SelectSubset<T, FriendshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Friendships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Friendships
     * const friendships = await prisma.friendship.findMany()
     * 
     * // Get first 10 Friendships
     * const friendships = await prisma.friendship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendshipWithIdOnly = await prisma.friendship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FriendshipFindManyArgs>(args?: SelectSubset<T, FriendshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Friendship.
     * @param {FriendshipCreateArgs} args - Arguments to create a Friendship.
     * @example
     * // Create one Friendship
     * const Friendship = await prisma.friendship.create({
     *   data: {
     *     // ... data to create a Friendship
     *   }
     * })
     * 
     */
    create<T extends FriendshipCreateArgs>(args: SelectSubset<T, FriendshipCreateArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Friendships.
     * @param {FriendshipCreateManyArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FriendshipCreateManyArgs>(args?: SelectSubset<T, FriendshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Friendships and returns the data saved in the database.
     * @param {FriendshipCreateManyAndReturnArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Friendships and only return the `id`
     * const friendshipWithIdOnly = await prisma.friendship.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FriendshipCreateManyAndReturnArgs>(args?: SelectSubset<T, FriendshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Friendship.
     * @param {FriendshipDeleteArgs} args - Arguments to delete one Friendship.
     * @example
     * // Delete one Friendship
     * const Friendship = await prisma.friendship.delete({
     *   where: {
     *     // ... filter to delete one Friendship
     *   }
     * })
     * 
     */
    delete<T extends FriendshipDeleteArgs>(args: SelectSubset<T, FriendshipDeleteArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Friendship.
     * @param {FriendshipUpdateArgs} args - Arguments to update one Friendship.
     * @example
     * // Update one Friendship
     * const friendship = await prisma.friendship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FriendshipUpdateArgs>(args: SelectSubset<T, FriendshipUpdateArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Friendships.
     * @param {FriendshipDeleteManyArgs} args - Arguments to filter Friendships to delete.
     * @example
     * // Delete a few Friendships
     * const { count } = await prisma.friendship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FriendshipDeleteManyArgs>(args?: SelectSubset<T, FriendshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Friendships
     * const friendship = await prisma.friendship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FriendshipUpdateManyArgs>(args: SelectSubset<T, FriendshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friendships and returns the data updated in the database.
     * @param {FriendshipUpdateManyAndReturnArgs} args - Arguments to update many Friendships.
     * @example
     * // Update many Friendships
     * const friendship = await prisma.friendship.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Friendships and only return the `id`
     * const friendshipWithIdOnly = await prisma.friendship.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FriendshipUpdateManyAndReturnArgs>(args: SelectSubset<T, FriendshipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Friendship.
     * @param {FriendshipUpsertArgs} args - Arguments to update or create a Friendship.
     * @example
     * // Update or create a Friendship
     * const friendship = await prisma.friendship.upsert({
     *   create: {
     *     // ... data to create a Friendship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Friendship we want to update
     *   }
     * })
     */
    upsert<T extends FriendshipUpsertArgs>(args: SelectSubset<T, FriendshipUpsertArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipCountArgs} args - Arguments to filter Friendships to count.
     * @example
     * // Count the number of Friendships
     * const count = await prisma.friendship.count({
     *   where: {
     *     // ... the filter for the Friendships we want to count
     *   }
     * })
    **/
    count<T extends FriendshipCountArgs>(
      args?: Subset<T, FriendshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendshipAggregateArgs>(args: Subset<T, FriendshipAggregateArgs>): Prisma.PrismaPromise<GetFriendshipAggregateType<T>>

    /**
     * Group by Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendshipGroupByArgs['orderBy'] }
        : { orderBy?: FriendshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Friendship model
   */
  readonly fields: FriendshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Friendship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FriendshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Friendship model
   */
  interface FriendshipFieldRefs {
    readonly id: FieldRef<"Friendship", 'Int'>
    readonly senderId: FieldRef<"Friendship", 'Int'>
    readonly receiverId: FieldRef<"Friendship", 'Int'>
    readonly status: FieldRef<"Friendship", 'FriendshipStatus'>
    readonly createdAt: FieldRef<"Friendship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Friendship findUnique
   */
  export type FriendshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship findUniqueOrThrow
   */
  export type FriendshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship findFirst
   */
  export type FriendshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship findFirstOrThrow
   */
  export type FriendshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship findMany
   */
  export type FriendshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendships to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship create
   */
  export type FriendshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Friendship.
     */
    data: XOR<FriendshipCreateInput, FriendshipUncheckedCreateInput>
  }

  /**
   * Friendship createMany
   */
  export type FriendshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Friendships.
     */
    data: FriendshipCreateManyInput | FriendshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Friendship createManyAndReturn
   */
  export type FriendshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * The data used to create many Friendships.
     */
    data: FriendshipCreateManyInput | FriendshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Friendship update
   */
  export type FriendshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Friendship.
     */
    data: XOR<FriendshipUpdateInput, FriendshipUncheckedUpdateInput>
    /**
     * Choose, which Friendship to update.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship updateMany
   */
  export type FriendshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Friendships.
     */
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyInput>
    /**
     * Filter which Friendships to update
     */
    where?: FriendshipWhereInput
    /**
     * Limit how many Friendships to update.
     */
    limit?: number
  }

  /**
   * Friendship updateManyAndReturn
   */
  export type FriendshipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * The data used to update Friendships.
     */
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyInput>
    /**
     * Filter which Friendships to update
     */
    where?: FriendshipWhereInput
    /**
     * Limit how many Friendships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Friendship upsert
   */
  export type FriendshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Friendship to update in case it exists.
     */
    where: FriendshipWhereUniqueInput
    /**
     * In case the Friendship found by the `where` argument doesn't exist, create a new Friendship with this data.
     */
    create: XOR<FriendshipCreateInput, FriendshipUncheckedCreateInput>
    /**
     * In case the Friendship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FriendshipUpdateInput, FriendshipUncheckedUpdateInput>
  }

  /**
   * Friendship delete
   */
  export type FriendshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter which Friendship to delete.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship deleteMany
   */
  export type FriendshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friendships to delete
     */
    where?: FriendshipWhereInput
    /**
     * Limit how many Friendships to delete.
     */
    limit?: number
  }

  /**
   * Friendship without action
   */
  export type FriendshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
  }


  /**
   * Model UserGroup
   */

  export type AggregateUserGroup = {
    _count: UserGroupCountAggregateOutputType | null
    _avg: UserGroupAvgAggregateOutputType | null
    _sum: UserGroupSumAggregateOutputType | null
    _min: UserGroupMinAggregateOutputType | null
    _max: UserGroupMaxAggregateOutputType | null
  }

  export type UserGroupAvgAggregateOutputType = {
    id: number | null
  }

  export type UserGroupSumAggregateOutputType = {
    id: number | null
  }

  export type UserGroupMinAggregateOutputType = {
    id: number | null
    name: string | null
    role: string | null
  }

  export type UserGroupMaxAggregateOutputType = {
    id: number | null
    name: string | null
    role: string | null
  }

  export type UserGroupCountAggregateOutputType = {
    id: number
    name: number
    role: number
    _all: number
  }


  export type UserGroupAvgAggregateInputType = {
    id?: true
  }

  export type UserGroupSumAggregateInputType = {
    id?: true
  }

  export type UserGroupMinAggregateInputType = {
    id?: true
    name?: true
    role?: true
  }

  export type UserGroupMaxAggregateInputType = {
    id?: true
    name?: true
    role?: true
  }

  export type UserGroupCountAggregateInputType = {
    id?: true
    name?: true
    role?: true
    _all?: true
  }

  export type UserGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserGroup to aggregate.
     */
    where?: UserGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     */
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserGroups
    **/
    _count?: true | UserGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserGroupMaxAggregateInputType
  }

  export type GetUserGroupAggregateType<T extends UserGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateUserGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserGroup[P]>
      : GetScalarType<T[P], AggregateUserGroup[P]>
  }




  export type UserGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGroupWhereInput
    orderBy?: UserGroupOrderByWithAggregationInput | UserGroupOrderByWithAggregationInput[]
    by: UserGroupScalarFieldEnum[] | UserGroupScalarFieldEnum
    having?: UserGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserGroupCountAggregateInputType | true
    _avg?: UserGroupAvgAggregateInputType
    _sum?: UserGroupSumAggregateInputType
    _min?: UserGroupMinAggregateInputType
    _max?: UserGroupMaxAggregateInputType
  }

  export type UserGroupGroupByOutputType = {
    id: number
    name: string
    role: string
    _count: UserGroupCountAggregateOutputType | null
    _avg: UserGroupAvgAggregateOutputType | null
    _sum: UserGroupSumAggregateOutputType | null
    _min: UserGroupMinAggregateOutputType | null
    _max: UserGroupMaxAggregateOutputType | null
  }

  type GetUserGroupGroupByPayload<T extends UserGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupGroupByOutputType[P]>
        }
      >
    >


  export type UserGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    users?: boolean | UserGroup$usersArgs<ExtArgs>
    _count?: boolean | UserGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userGroup"]>

  export type UserGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
  }, ExtArgs["result"]["userGroup"]>

  export type UserGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
  }, ExtArgs["result"]["userGroup"]>

  export type UserGroupSelectScalar = {
    id?: boolean
    name?: boolean
    role?: boolean
  }

  export type UserGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "role", ExtArgs["result"]["userGroup"]>
  export type UserGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserGroup$usersArgs<ExtArgs>
    _count?: boolean | UserGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserGroup"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      role: string
    }, ExtArgs["result"]["userGroup"]>
    composites: {}
  }

  type UserGroupGetPayload<S extends boolean | null | undefined | UserGroupDefaultArgs> = $Result.GetResult<Prisma.$UserGroupPayload, S>

  type UserGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserGroupCountAggregateInputType | true
    }

  export interface UserGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserGroup'], meta: { name: 'UserGroup' } }
    /**
     * Find zero or one UserGroup that matches the filter.
     * @param {UserGroupFindUniqueArgs} args - Arguments to find a UserGroup
     * @example
     * // Get one UserGroup
     * const userGroup = await prisma.userGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserGroupFindUniqueArgs>(args: SelectSubset<T, UserGroupFindUniqueArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserGroupFindUniqueOrThrowArgs} args - Arguments to find a UserGroup
     * @example
     * // Get one UserGroup
     * const userGroup = await prisma.userGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, UserGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupFindFirstArgs} args - Arguments to find a UserGroup
     * @example
     * // Get one UserGroup
     * const userGroup = await prisma.userGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserGroupFindFirstArgs>(args?: SelectSubset<T, UserGroupFindFirstArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupFindFirstOrThrowArgs} args - Arguments to find a UserGroup
     * @example
     * // Get one UserGroup
     * const userGroup = await prisma.userGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, UserGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserGroups
     * const userGroups = await prisma.userGroup.findMany()
     * 
     * // Get first 10 UserGroups
     * const userGroups = await prisma.userGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userGroupWithIdOnly = await prisma.userGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserGroupFindManyArgs>(args?: SelectSubset<T, UserGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserGroup.
     * @param {UserGroupCreateArgs} args - Arguments to create a UserGroup.
     * @example
     * // Create one UserGroup
     * const UserGroup = await prisma.userGroup.create({
     *   data: {
     *     // ... data to create a UserGroup
     *   }
     * })
     * 
     */
    create<T extends UserGroupCreateArgs>(args: SelectSubset<T, UserGroupCreateArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserGroups.
     * @param {UserGroupCreateManyArgs} args - Arguments to create many UserGroups.
     * @example
     * // Create many UserGroups
     * const userGroup = await prisma.userGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserGroupCreateManyArgs>(args?: SelectSubset<T, UserGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserGroups and returns the data saved in the database.
     * @param {UserGroupCreateManyAndReturnArgs} args - Arguments to create many UserGroups.
     * @example
     * // Create many UserGroups
     * const userGroup = await prisma.userGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserGroups and only return the `id`
     * const userGroupWithIdOnly = await prisma.userGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, UserGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserGroup.
     * @param {UserGroupDeleteArgs} args - Arguments to delete one UserGroup.
     * @example
     * // Delete one UserGroup
     * const UserGroup = await prisma.userGroup.delete({
     *   where: {
     *     // ... filter to delete one UserGroup
     *   }
     * })
     * 
     */
    delete<T extends UserGroupDeleteArgs>(args: SelectSubset<T, UserGroupDeleteArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserGroup.
     * @param {UserGroupUpdateArgs} args - Arguments to update one UserGroup.
     * @example
     * // Update one UserGroup
     * const userGroup = await prisma.userGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserGroupUpdateArgs>(args: SelectSubset<T, UserGroupUpdateArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserGroups.
     * @param {UserGroupDeleteManyArgs} args - Arguments to filter UserGroups to delete.
     * @example
     * // Delete a few UserGroups
     * const { count } = await prisma.userGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserGroupDeleteManyArgs>(args?: SelectSubset<T, UserGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserGroups
     * const userGroup = await prisma.userGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserGroupUpdateManyArgs>(args: SelectSubset<T, UserGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGroups and returns the data updated in the database.
     * @param {UserGroupUpdateManyAndReturnArgs} args - Arguments to update many UserGroups.
     * @example
     * // Update many UserGroups
     * const userGroup = await prisma.userGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserGroups and only return the `id`
     * const userGroupWithIdOnly = await prisma.userGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, UserGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserGroup.
     * @param {UserGroupUpsertArgs} args - Arguments to update or create a UserGroup.
     * @example
     * // Update or create a UserGroup
     * const userGroup = await prisma.userGroup.upsert({
     *   create: {
     *     // ... data to create a UserGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserGroup we want to update
     *   }
     * })
     */
    upsert<T extends UserGroupUpsertArgs>(args: SelectSubset<T, UserGroupUpsertArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupCountArgs} args - Arguments to filter UserGroups to count.
     * @example
     * // Count the number of UserGroups
     * const count = await prisma.userGroup.count({
     *   where: {
     *     // ... the filter for the UserGroups we want to count
     *   }
     * })
    **/
    count<T extends UserGroupCountArgs>(
      args?: Subset<T, UserGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserGroupAggregateArgs>(args: Subset<T, UserGroupAggregateArgs>): Prisma.PrismaPromise<GetUserGroupAggregateType<T>>

    /**
     * Group by UserGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserGroup model
   */
  readonly fields: UserGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UserGroup$usersArgs<ExtArgs> = {}>(args?: Subset<T, UserGroup$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserGroup model
   */
  interface UserGroupFieldRefs {
    readonly id: FieldRef<"UserGroup", 'Int'>
    readonly name: FieldRef<"UserGroup", 'String'>
    readonly role: FieldRef<"UserGroup", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserGroup findUnique
   */
  export type UserGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter, which UserGroup to fetch.
     */
    where: UserGroupWhereUniqueInput
  }

  /**
   * UserGroup findUniqueOrThrow
   */
  export type UserGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter, which UserGroup to fetch.
     */
    where: UserGroupWhereUniqueInput
  }

  /**
   * UserGroup findFirst
   */
  export type UserGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter, which UserGroup to fetch.
     */
    where?: UserGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     */
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGroups.
     */
    cursor?: UserGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGroups.
     */
    distinct?: UserGroupScalarFieldEnum | UserGroupScalarFieldEnum[]
  }

  /**
   * UserGroup findFirstOrThrow
   */
  export type UserGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter, which UserGroup to fetch.
     */
    where?: UserGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     */
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGroups.
     */
    cursor?: UserGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGroups.
     */
    distinct?: UserGroupScalarFieldEnum | UserGroupScalarFieldEnum[]
  }

  /**
   * UserGroup findMany
   */
  export type UserGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter, which UserGroups to fetch.
     */
    where?: UserGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     */
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserGroups.
     */
    cursor?: UserGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     */
    skip?: number
    distinct?: UserGroupScalarFieldEnum | UserGroupScalarFieldEnum[]
  }

  /**
   * UserGroup create
   */
  export type UserGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a UserGroup.
     */
    data: XOR<UserGroupCreateInput, UserGroupUncheckedCreateInput>
  }

  /**
   * UserGroup createMany
   */
  export type UserGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserGroups.
     */
    data: UserGroupCreateManyInput | UserGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserGroup createManyAndReturn
   */
  export type UserGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * The data used to create many UserGroups.
     */
    data: UserGroupCreateManyInput | UserGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserGroup update
   */
  export type UserGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a UserGroup.
     */
    data: XOR<UserGroupUpdateInput, UserGroupUncheckedUpdateInput>
    /**
     * Choose, which UserGroup to update.
     */
    where: UserGroupWhereUniqueInput
  }

  /**
   * UserGroup updateMany
   */
  export type UserGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserGroups.
     */
    data: XOR<UserGroupUpdateManyMutationInput, UserGroupUncheckedUpdateManyInput>
    /**
     * Filter which UserGroups to update
     */
    where?: UserGroupWhereInput
    /**
     * Limit how many UserGroups to update.
     */
    limit?: number
  }

  /**
   * UserGroup updateManyAndReturn
   */
  export type UserGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * The data used to update UserGroups.
     */
    data: XOR<UserGroupUpdateManyMutationInput, UserGroupUncheckedUpdateManyInput>
    /**
     * Filter which UserGroups to update
     */
    where?: UserGroupWhereInput
    /**
     * Limit how many UserGroups to update.
     */
    limit?: number
  }

  /**
   * UserGroup upsert
   */
  export type UserGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the UserGroup to update in case it exists.
     */
    where: UserGroupWhereUniqueInput
    /**
     * In case the UserGroup found by the `where` argument doesn't exist, create a new UserGroup with this data.
     */
    create: XOR<UserGroupCreateInput, UserGroupUncheckedCreateInput>
    /**
     * In case the UserGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserGroupUpdateInput, UserGroupUncheckedUpdateInput>
  }

  /**
   * UserGroup delete
   */
  export type UserGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter which UserGroup to delete.
     */
    where: UserGroupWhereUniqueInput
  }

  /**
   * UserGroup deleteMany
   */
  export type UserGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserGroups to delete
     */
    where?: UserGroupWhereInput
    /**
     * Limit how many UserGroups to delete.
     */
    limit?: number
  }

  /**
   * UserGroup.users
   */
  export type UserGroup$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * UserGroup without action
   */
  export type UserGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
  }


  /**
   * Model Genre
   */

  export type AggregateGenre = {
    _count: GenreCountAggregateOutputType | null
    _avg: GenreAvgAggregateOutputType | null
    _sum: GenreSumAggregateOutputType | null
    _min: GenreMinAggregateOutputType | null
    _max: GenreMaxAggregateOutputType | null
  }

  export type GenreAvgAggregateOutputType = {
    id: number | null
  }

  export type GenreSumAggregateOutputType = {
    id: number | null
  }

  export type GenreMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type GenreMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type GenreCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type GenreAvgAggregateInputType = {
    id?: true
  }

  export type GenreSumAggregateInputType = {
    id?: true
  }

  export type GenreMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type GenreMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type GenreCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type GenreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genre to aggregate.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Genres
    **/
    _count?: true | GenreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GenreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GenreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenreMaxAggregateInputType
  }

  export type GetGenreAggregateType<T extends GenreAggregateArgs> = {
        [P in keyof T & keyof AggregateGenre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenre[P]>
      : GetScalarType<T[P], AggregateGenre[P]>
  }




  export type GenreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenreWhereInput
    orderBy?: GenreOrderByWithAggregationInput | GenreOrderByWithAggregationInput[]
    by: GenreScalarFieldEnum[] | GenreScalarFieldEnum
    having?: GenreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenreCountAggregateInputType | true
    _avg?: GenreAvgAggregateInputType
    _sum?: GenreSumAggregateInputType
    _min?: GenreMinAggregateInputType
    _max?: GenreMaxAggregateInputType
  }

  export type GenreGroupByOutputType = {
    id: number
    name: string
    _count: GenreCountAggregateOutputType | null
    _avg: GenreAvgAggregateOutputType | null
    _sum: GenreSumAggregateOutputType | null
    _min: GenreMinAggregateOutputType | null
    _max: GenreMaxAggregateOutputType | null
  }

  type GetGenreGroupByPayload<T extends GenreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenreGroupByOutputType[P]>
            : GetScalarType<T[P], GenreGroupByOutputType[P]>
        }
      >
    >


  export type GenreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    games?: boolean | Genre$gamesArgs<ExtArgs>
    _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type GenreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["genre"]>
  export type GenreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | Genre$gamesArgs<ExtArgs>
    _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GenreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GenreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GenrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Genre"
    objects: {
      games: Prisma.$GamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["genre"]>
    composites: {}
  }

  type GenreGetPayload<S extends boolean | null | undefined | GenreDefaultArgs> = $Result.GetResult<Prisma.$GenrePayload, S>

  type GenreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GenreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GenreCountAggregateInputType | true
    }

  export interface GenreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Genre'], meta: { name: 'Genre' } }
    /**
     * Find zero or one Genre that matches the filter.
     * @param {GenreFindUniqueArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GenreFindUniqueArgs>(args: SelectSubset<T, GenreFindUniqueArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Genre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GenreFindUniqueOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GenreFindUniqueOrThrowArgs>(args: SelectSubset<T, GenreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Genre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindFirstArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GenreFindFirstArgs>(args?: SelectSubset<T, GenreFindFirstArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Genre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindFirstOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GenreFindFirstOrThrowArgs>(args?: SelectSubset<T, GenreFindFirstOrThrowArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genres
     * const genres = await prisma.genre.findMany()
     * 
     * // Get first 10 Genres
     * const genres = await prisma.genre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genreWithIdOnly = await prisma.genre.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GenreFindManyArgs>(args?: SelectSubset<T, GenreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Genre.
     * @param {GenreCreateArgs} args - Arguments to create a Genre.
     * @example
     * // Create one Genre
     * const Genre = await prisma.genre.create({
     *   data: {
     *     // ... data to create a Genre
     *   }
     * })
     * 
     */
    create<T extends GenreCreateArgs>(args: SelectSubset<T, GenreCreateArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Genres.
     * @param {GenreCreateManyArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GenreCreateManyArgs>(args?: SelectSubset<T, GenreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Genres and returns the data saved in the database.
     * @param {GenreCreateManyAndReturnArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Genres and only return the `id`
     * const genreWithIdOnly = await prisma.genre.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GenreCreateManyAndReturnArgs>(args?: SelectSubset<T, GenreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Genre.
     * @param {GenreDeleteArgs} args - Arguments to delete one Genre.
     * @example
     * // Delete one Genre
     * const Genre = await prisma.genre.delete({
     *   where: {
     *     // ... filter to delete one Genre
     *   }
     * })
     * 
     */
    delete<T extends GenreDeleteArgs>(args: SelectSubset<T, GenreDeleteArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Genre.
     * @param {GenreUpdateArgs} args - Arguments to update one Genre.
     * @example
     * // Update one Genre
     * const genre = await prisma.genre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GenreUpdateArgs>(args: SelectSubset<T, GenreUpdateArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Genres.
     * @param {GenreDeleteManyArgs} args - Arguments to filter Genres to delete.
     * @example
     * // Delete a few Genres
     * const { count } = await prisma.genre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GenreDeleteManyArgs>(args?: SelectSubset<T, GenreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GenreUpdateManyArgs>(args: SelectSubset<T, GenreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres and returns the data updated in the database.
     * @param {GenreUpdateManyAndReturnArgs} args - Arguments to update many Genres.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Genres and only return the `id`
     * const genreWithIdOnly = await prisma.genre.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GenreUpdateManyAndReturnArgs>(args: SelectSubset<T, GenreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Genre.
     * @param {GenreUpsertArgs} args - Arguments to update or create a Genre.
     * @example
     * // Update or create a Genre
     * const genre = await prisma.genre.upsert({
     *   create: {
     *     // ... data to create a Genre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Genre we want to update
     *   }
     * })
     */
    upsert<T extends GenreUpsertArgs>(args: SelectSubset<T, GenreUpsertArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreCountArgs} args - Arguments to filter Genres to count.
     * @example
     * // Count the number of Genres
     * const count = await prisma.genre.count({
     *   where: {
     *     // ... the filter for the Genres we want to count
     *   }
     * })
    **/
    count<T extends GenreCountArgs>(
      args?: Subset<T, GenreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenreAggregateArgs>(args: Subset<T, GenreAggregateArgs>): Prisma.PrismaPromise<GetGenreAggregateType<T>>

    /**
     * Group by Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenreGroupByArgs['orderBy'] }
        : { orderBy?: GenreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Genre model
   */
  readonly fields: GenreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Genre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    games<T extends Genre$gamesArgs<ExtArgs> = {}>(args?: Subset<T, Genre$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Genre model
   */
  interface GenreFieldRefs {
    readonly id: FieldRef<"Genre", 'Int'>
    readonly name: FieldRef<"Genre", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Genre findUnique
   */
  export type GenreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre findUniqueOrThrow
   */
  export type GenreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre findFirst
   */
  export type GenreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre findFirstOrThrow
   */
  export type GenreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre findMany
   */
  export type GenreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genres to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre create
   */
  export type GenreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The data needed to create a Genre.
     */
    data: XOR<GenreCreateInput, GenreUncheckedCreateInput>
  }

  /**
   * Genre createMany
   */
  export type GenreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Genres.
     */
    data: GenreCreateManyInput | GenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genre createManyAndReturn
   */
  export type GenreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * The data used to create many Genres.
     */
    data: GenreCreateManyInput | GenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genre update
   */
  export type GenreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The data needed to update a Genre.
     */
    data: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>
    /**
     * Choose, which Genre to update.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre updateMany
   */
  export type GenreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Genres.
     */
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyInput>
    /**
     * Filter which Genres to update
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to update.
     */
    limit?: number
  }

  /**
   * Genre updateManyAndReturn
   */
  export type GenreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * The data used to update Genres.
     */
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyInput>
    /**
     * Filter which Genres to update
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to update.
     */
    limit?: number
  }

  /**
   * Genre upsert
   */
  export type GenreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The filter to search for the Genre to update in case it exists.
     */
    where: GenreWhereUniqueInput
    /**
     * In case the Genre found by the `where` argument doesn't exist, create a new Genre with this data.
     */
    create: XOR<GenreCreateInput, GenreUncheckedCreateInput>
    /**
     * In case the Genre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>
  }

  /**
   * Genre delete
   */
  export type GenreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter which Genre to delete.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre deleteMany
   */
  export type GenreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genres to delete
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to delete.
     */
    limit?: number
  }

  /**
   * Genre.games
   */
  export type Genre$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Genre without action
   */
  export type GenreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
  }


  /**
   * Model Platform
   */

  export type AggregatePlatform = {
    _count: PlatformCountAggregateOutputType | null
    _avg: PlatformAvgAggregateOutputType | null
    _sum: PlatformSumAggregateOutputType | null
    _min: PlatformMinAggregateOutputType | null
    _max: PlatformMaxAggregateOutputType | null
  }

  export type PlatformAvgAggregateOutputType = {
    id: number | null
  }

  export type PlatformSumAggregateOutputType = {
    id: number | null
  }

  export type PlatformMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type PlatformMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type PlatformCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type PlatformAvgAggregateInputType = {
    id?: true
  }

  export type PlatformSumAggregateInputType = {
    id?: true
  }

  export type PlatformMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type PlatformMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type PlatformCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type PlatformAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Platform to aggregate.
     */
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     */
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Platforms
    **/
    _count?: true | PlatformCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlatformAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlatformSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformMaxAggregateInputType
  }

  export type GetPlatformAggregateType<T extends PlatformAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatform]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatform[P]>
      : GetScalarType<T[P], AggregatePlatform[P]>
  }




  export type PlatformGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformWhereInput
    orderBy?: PlatformOrderByWithAggregationInput | PlatformOrderByWithAggregationInput[]
    by: PlatformScalarFieldEnum[] | PlatformScalarFieldEnum
    having?: PlatformScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformCountAggregateInputType | true
    _avg?: PlatformAvgAggregateInputType
    _sum?: PlatformSumAggregateInputType
    _min?: PlatformMinAggregateInputType
    _max?: PlatformMaxAggregateInputType
  }

  export type PlatformGroupByOutputType = {
    id: number
    name: string
    _count: PlatformCountAggregateOutputType | null
    _avg: PlatformAvgAggregateOutputType | null
    _sum: PlatformSumAggregateOutputType | null
    _min: PlatformMinAggregateOutputType | null
    _max: PlatformMaxAggregateOutputType | null
  }

  type GetPlatformGroupByPayload<T extends PlatformGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlatformGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformGroupByOutputType[P]>
        }
      >
    >


  export type PlatformSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    games?: boolean | Platform$gamesArgs<ExtArgs>
    _count?: boolean | PlatformCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platform"]>

  export type PlatformSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["platform"]>

  export type PlatformSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["platform"]>

  export type PlatformSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type PlatformOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["platform"]>
  export type PlatformInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | Platform$gamesArgs<ExtArgs>
    _count?: boolean | PlatformCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlatformIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PlatformIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlatformPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Platform"
    objects: {
      games: Prisma.$GamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["platform"]>
    composites: {}
  }

  type PlatformGetPayload<S extends boolean | null | undefined | PlatformDefaultArgs> = $Result.GetResult<Prisma.$PlatformPayload, S>

  type PlatformCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlatformFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlatformCountAggregateInputType | true
    }

  export interface PlatformDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Platform'], meta: { name: 'Platform' } }
    /**
     * Find zero or one Platform that matches the filter.
     * @param {PlatformFindUniqueArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlatformFindUniqueArgs>(args: SelectSubset<T, PlatformFindUniqueArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Platform that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlatformFindUniqueOrThrowArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlatformFindUniqueOrThrowArgs>(args: SelectSubset<T, PlatformFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Platform that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformFindFirstArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlatformFindFirstArgs>(args?: SelectSubset<T, PlatformFindFirstArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Platform that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformFindFirstOrThrowArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlatformFindFirstOrThrowArgs>(args?: SelectSubset<T, PlatformFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Platforms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Platforms
     * const platforms = await prisma.platform.findMany()
     * 
     * // Get first 10 Platforms
     * const platforms = await prisma.platform.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const platformWithIdOnly = await prisma.platform.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlatformFindManyArgs>(args?: SelectSubset<T, PlatformFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Platform.
     * @param {PlatformCreateArgs} args - Arguments to create a Platform.
     * @example
     * // Create one Platform
     * const Platform = await prisma.platform.create({
     *   data: {
     *     // ... data to create a Platform
     *   }
     * })
     * 
     */
    create<T extends PlatformCreateArgs>(args: SelectSubset<T, PlatformCreateArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Platforms.
     * @param {PlatformCreateManyArgs} args - Arguments to create many Platforms.
     * @example
     * // Create many Platforms
     * const platform = await prisma.platform.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlatformCreateManyArgs>(args?: SelectSubset<T, PlatformCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Platforms and returns the data saved in the database.
     * @param {PlatformCreateManyAndReturnArgs} args - Arguments to create many Platforms.
     * @example
     * // Create many Platforms
     * const platform = await prisma.platform.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Platforms and only return the `id`
     * const platformWithIdOnly = await prisma.platform.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlatformCreateManyAndReturnArgs>(args?: SelectSubset<T, PlatformCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Platform.
     * @param {PlatformDeleteArgs} args - Arguments to delete one Platform.
     * @example
     * // Delete one Platform
     * const Platform = await prisma.platform.delete({
     *   where: {
     *     // ... filter to delete one Platform
     *   }
     * })
     * 
     */
    delete<T extends PlatformDeleteArgs>(args: SelectSubset<T, PlatformDeleteArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Platform.
     * @param {PlatformUpdateArgs} args - Arguments to update one Platform.
     * @example
     * // Update one Platform
     * const platform = await prisma.platform.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlatformUpdateArgs>(args: SelectSubset<T, PlatformUpdateArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Platforms.
     * @param {PlatformDeleteManyArgs} args - Arguments to filter Platforms to delete.
     * @example
     * // Delete a few Platforms
     * const { count } = await prisma.platform.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlatformDeleteManyArgs>(args?: SelectSubset<T, PlatformDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Platforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Platforms
     * const platform = await prisma.platform.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlatformUpdateManyArgs>(args: SelectSubset<T, PlatformUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Platforms and returns the data updated in the database.
     * @param {PlatformUpdateManyAndReturnArgs} args - Arguments to update many Platforms.
     * @example
     * // Update many Platforms
     * const platform = await prisma.platform.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Platforms and only return the `id`
     * const platformWithIdOnly = await prisma.platform.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlatformUpdateManyAndReturnArgs>(args: SelectSubset<T, PlatformUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Platform.
     * @param {PlatformUpsertArgs} args - Arguments to update or create a Platform.
     * @example
     * // Update or create a Platform
     * const platform = await prisma.platform.upsert({
     *   create: {
     *     // ... data to create a Platform
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Platform we want to update
     *   }
     * })
     */
    upsert<T extends PlatformUpsertArgs>(args: SelectSubset<T, PlatformUpsertArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Platforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformCountArgs} args - Arguments to filter Platforms to count.
     * @example
     * // Count the number of Platforms
     * const count = await prisma.platform.count({
     *   where: {
     *     // ... the filter for the Platforms we want to count
     *   }
     * })
    **/
    count<T extends PlatformCountArgs>(
      args?: Subset<T, PlatformCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Platform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformAggregateArgs>(args: Subset<T, PlatformAggregateArgs>): Prisma.PrismaPromise<GetPlatformAggregateType<T>>

    /**
     * Group by Platform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlatformGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlatformGroupByArgs['orderBy'] }
        : { orderBy?: PlatformGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlatformGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Platform model
   */
  readonly fields: PlatformFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Platform.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlatformClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    games<T extends Platform$gamesArgs<ExtArgs> = {}>(args?: Subset<T, Platform$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Platform model
   */
  interface PlatformFieldRefs {
    readonly id: FieldRef<"Platform", 'Int'>
    readonly name: FieldRef<"Platform", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Platform findUnique
   */
  export type PlatformFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter, which Platform to fetch.
     */
    where: PlatformWhereUniqueInput
  }

  /**
   * Platform findUniqueOrThrow
   */
  export type PlatformFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter, which Platform to fetch.
     */
    where: PlatformWhereUniqueInput
  }

  /**
   * Platform findFirst
   */
  export type PlatformFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter, which Platform to fetch.
     */
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     */
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Platforms.
     */
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Platforms.
     */
    distinct?: PlatformScalarFieldEnum | PlatformScalarFieldEnum[]
  }

  /**
   * Platform findFirstOrThrow
   */
  export type PlatformFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter, which Platform to fetch.
     */
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     */
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Platforms.
     */
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Platforms.
     */
    distinct?: PlatformScalarFieldEnum | PlatformScalarFieldEnum[]
  }

  /**
   * Platform findMany
   */
  export type PlatformFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter, which Platforms to fetch.
     */
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     */
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Platforms.
     */
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     */
    skip?: number
    distinct?: PlatformScalarFieldEnum | PlatformScalarFieldEnum[]
  }

  /**
   * Platform create
   */
  export type PlatformCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * The data needed to create a Platform.
     */
    data: XOR<PlatformCreateInput, PlatformUncheckedCreateInput>
  }

  /**
   * Platform createMany
   */
  export type PlatformCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Platforms.
     */
    data: PlatformCreateManyInput | PlatformCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Platform createManyAndReturn
   */
  export type PlatformCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * The data used to create many Platforms.
     */
    data: PlatformCreateManyInput | PlatformCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Platform update
   */
  export type PlatformUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * The data needed to update a Platform.
     */
    data: XOR<PlatformUpdateInput, PlatformUncheckedUpdateInput>
    /**
     * Choose, which Platform to update.
     */
    where: PlatformWhereUniqueInput
  }

  /**
   * Platform updateMany
   */
  export type PlatformUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Platforms.
     */
    data: XOR<PlatformUpdateManyMutationInput, PlatformUncheckedUpdateManyInput>
    /**
     * Filter which Platforms to update
     */
    where?: PlatformWhereInput
    /**
     * Limit how many Platforms to update.
     */
    limit?: number
  }

  /**
   * Platform updateManyAndReturn
   */
  export type PlatformUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * The data used to update Platforms.
     */
    data: XOR<PlatformUpdateManyMutationInput, PlatformUncheckedUpdateManyInput>
    /**
     * Filter which Platforms to update
     */
    where?: PlatformWhereInput
    /**
     * Limit how many Platforms to update.
     */
    limit?: number
  }

  /**
   * Platform upsert
   */
  export type PlatformUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * The filter to search for the Platform to update in case it exists.
     */
    where: PlatformWhereUniqueInput
    /**
     * In case the Platform found by the `where` argument doesn't exist, create a new Platform with this data.
     */
    create: XOR<PlatformCreateInput, PlatformUncheckedCreateInput>
    /**
     * In case the Platform was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlatformUpdateInput, PlatformUncheckedUpdateInput>
  }

  /**
   * Platform delete
   */
  export type PlatformDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter which Platform to delete.
     */
    where: PlatformWhereUniqueInput
  }

  /**
   * Platform deleteMany
   */
  export type PlatformDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Platforms to delete
     */
    where?: PlatformWhereInput
    /**
     * Limit how many Platforms to delete.
     */
    limit?: number
  }

  /**
   * Platform.games
   */
  export type Platform$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Platform without action
   */
  export type PlatformDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    googleId: 'googleId',
    displayName: 'displayName',
    profilePictureId: 'profilePictureId',
    emailVerified: 'emailVerified',
    birthDate: 'birthDate',
    registrationDate: 'registrationDate'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const GameScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    releaseDate: 'releaseDate',
    coverImageId: 'coverImageId',
    userId: 'userId'
  };

  export type GameScalarFieldEnum = (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum]


  export const ImageScalarFieldEnum: {
    id: 'id',
    url: 'url',
    checksum: 'checksum',
    width: 'width',
    height: 'height',
    uploadedAt: 'uploadedAt',
    uploadedById: 'uploadedById'
  };

  export type ImageScalarFieldEnum = (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    rating: 'rating',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    gameId: 'gameId'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const ReviewCommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    reviewId: 'reviewId',
    userId: 'userId'
  };

  export type ReviewCommentScalarFieldEnum = (typeof ReviewCommentScalarFieldEnum)[keyof typeof ReviewCommentScalarFieldEnum]


  export const GameUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    gameId: 'gameId',
    progress: 'progress'
  };

  export type GameUserScalarFieldEnum = (typeof GameUserScalarFieldEnum)[keyof typeof GameUserScalarFieldEnum]


  export const GameStatusScalarFieldEnum: {
    id: 'id',
    type: 'type',
    userId: 'userId'
  };

  export type GameStatusScalarFieldEnum = (typeof GameStatusScalarFieldEnum)[keyof typeof GameStatusScalarFieldEnum]


  export const UserTagScalarFieldEnum: {
    id: 'id',
    label: 'label'
  };

  export type UserTagScalarFieldEnum = (typeof UserTagScalarFieldEnum)[keyof typeof UserTagScalarFieldEnum]


  export const GameTagScalarFieldEnum: {
    id: 'id',
    label: 'label'
  };

  export type GameTagScalarFieldEnum = (typeof GameTagScalarFieldEnum)[keyof typeof GameTagScalarFieldEnum]


  export const ReviewUserTagScalarFieldEnum: {
    id: 'id',
    label: 'label',
    reviewId: 'reviewId',
    userId: 'userId'
  };

  export type ReviewUserTagScalarFieldEnum = (typeof ReviewUserTagScalarFieldEnum)[keyof typeof ReviewUserTagScalarFieldEnum]


  export const DeveloperScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type DeveloperScalarFieldEnum = (typeof DeveloperScalarFieldEnum)[keyof typeof DeveloperScalarFieldEnum]


  export const PublisherScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type PublisherScalarFieldEnum = (typeof PublisherScalarFieldEnum)[keyof typeof PublisherScalarFieldEnum]


  export const GameImageScalarFieldEnum: {
    id: 'id',
    url: 'url',
    gameId: 'gameId'
  };

  export type GameImageScalarFieldEnum = (typeof GameImageScalarFieldEnum)[keyof typeof GameImageScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    gameId: 'gameId'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const AchievementUnlockScalarFieldEnum: {
    id: 'id',
    unlockedAt: 'unlockedAt',
    userId: 'userId',
    achievementId: 'achievementId'
  };

  export type AchievementUnlockScalarFieldEnum = (typeof AchievementUnlockScalarFieldEnum)[keyof typeof AchievementUnlockScalarFieldEnum]


  export const EmailChangeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    newEmail: 'newEmail',
    token: 'token',
    createdAt: 'createdAt'
  };

  export type EmailChangeScalarFieldEnum = (typeof EmailChangeScalarFieldEnum)[keyof typeof EmailChangeScalarFieldEnum]


  export const EmailVerificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type EmailVerificationScalarFieldEnum = (typeof EmailVerificationScalarFieldEnum)[keyof typeof EmailVerificationScalarFieldEnum]


  export const PasswordResetScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type PasswordResetScalarFieldEnum = (typeof PasswordResetScalarFieldEnum)[keyof typeof PasswordResetScalarFieldEnum]


  export const FriendshipScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type FriendshipScalarFieldEnum = (typeof FriendshipScalarFieldEnum)[keyof typeof FriendshipScalarFieldEnum]


  export const UserGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role'
  };

  export type UserGroupScalarFieldEnum = (typeof UserGroupScalarFieldEnum)[keyof typeof UserGroupScalarFieldEnum]


  export const GenreScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type GenreScalarFieldEnum = (typeof GenreScalarFieldEnum)[keyof typeof GenreScalarFieldEnum]


  export const PlatformScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type PlatformScalarFieldEnum = (typeof PlatformScalarFieldEnum)[keyof typeof PlatformScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ProgressStatus'
   */
  export type EnumProgressStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProgressStatus'>
    


  /**
   * Reference to a field of type 'ProgressStatus[]'
   */
  export type ListEnumProgressStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProgressStatus[]'>
    


  /**
   * Reference to a field of type 'GameStatusType'
   */
  export type EnumGameStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameStatusType'>
    


  /**
   * Reference to a field of type 'GameStatusType[]'
   */
  export type ListEnumGameStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameStatusType[]'>
    


  /**
   * Reference to a field of type 'FriendshipStatus'
   */
  export type EnumFriendshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FriendshipStatus'>
    


  /**
   * Reference to a field of type 'FriendshipStatus[]'
   */
  export type ListEnumFriendshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FriendshipStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    googleId?: StringNullableFilter<"User"> | string | null
    displayName?: StringFilter<"User"> | string
    profilePictureId?: IntNullableFilter<"User"> | number | null
    emailVerified?: BoolFilter<"User"> | boolean
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    registrationDate?: DateTimeFilter<"User"> | Date | string
    profilePicture?: XOR<ImageNullableScalarRelationFilter, ImageWhereInput> | null
    emailChanges?: EmailChangeListRelationFilter
    emailVerifications?: EmailVerificationListRelationFilter
    passwordResets?: PasswordResetListRelationFilter
    playedGames?: GameListRelationFilter
    favourites?: GameListRelationFilter
    sentFriendRequests?: FriendshipListRelationFilter
    receivedFriendRequests?: FriendshipListRelationFilter
    groups?: UserGroupListRelationFilter
    reviews?: ReviewListRelationFilter
    reviewTags?: ReviewUserTagListRelationFilter
    userTags?: UserTagListRelationFilter
    gameStatuses?: GameStatusListRelationFilter
    achievements?: AchievementUnlockListRelationFilter
    uploadedImages?: ImageListRelationFilter
    ReviewComment?: ReviewCommentListRelationFilter
    GameUser?: GameUserListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    displayName?: SortOrder
    profilePictureId?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    registrationDate?: SortOrder
    profilePicture?: ImageOrderByWithRelationInput
    emailChanges?: EmailChangeOrderByRelationAggregateInput
    emailVerifications?: EmailVerificationOrderByRelationAggregateInput
    passwordResets?: PasswordResetOrderByRelationAggregateInput
    playedGames?: GameOrderByRelationAggregateInput
    favourites?: GameOrderByRelationAggregateInput
    sentFriendRequests?: FriendshipOrderByRelationAggregateInput
    receivedFriendRequests?: FriendshipOrderByRelationAggregateInput
    groups?: UserGroupOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    reviewTags?: ReviewUserTagOrderByRelationAggregateInput
    userTags?: UserTagOrderByRelationAggregateInput
    gameStatuses?: GameStatusOrderByRelationAggregateInput
    achievements?: AchievementUnlockOrderByRelationAggregateInput
    uploadedImages?: ImageOrderByRelationAggregateInput
    ReviewComment?: ReviewCommentOrderByRelationAggregateInput
    GameUser?: GameUserOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    googleId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringNullableFilter<"User"> | string | null
    displayName?: StringFilter<"User"> | string
    profilePictureId?: IntNullableFilter<"User"> | number | null
    emailVerified?: BoolFilter<"User"> | boolean
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    registrationDate?: DateTimeFilter<"User"> | Date | string
    profilePicture?: XOR<ImageNullableScalarRelationFilter, ImageWhereInput> | null
    emailChanges?: EmailChangeListRelationFilter
    emailVerifications?: EmailVerificationListRelationFilter
    passwordResets?: PasswordResetListRelationFilter
    playedGames?: GameListRelationFilter
    favourites?: GameListRelationFilter
    sentFriendRequests?: FriendshipListRelationFilter
    receivedFriendRequests?: FriendshipListRelationFilter
    groups?: UserGroupListRelationFilter
    reviews?: ReviewListRelationFilter
    reviewTags?: ReviewUserTagListRelationFilter
    userTags?: UserTagListRelationFilter
    gameStatuses?: GameStatusListRelationFilter
    achievements?: AchievementUnlockListRelationFilter
    uploadedImages?: ImageListRelationFilter
    ReviewComment?: ReviewCommentListRelationFilter
    GameUser?: GameUserListRelationFilter
  }, "id" | "email" | "googleId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    displayName?: SortOrder
    profilePictureId?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    registrationDate?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    displayName?: StringWithAggregatesFilter<"User"> | string
    profilePictureId?: IntNullableWithAggregatesFilter<"User"> | number | null
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    birthDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    registrationDate?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type GameWhereInput = {
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    id?: IntFilter<"Game"> | number
    title?: StringFilter<"Game"> | string
    description?: StringNullableFilter<"Game"> | string | null
    releaseDate?: DateTimeNullableFilter<"Game"> | Date | string | null
    coverImageId?: IntNullableFilter<"Game"> | number | null
    userId?: IntNullableFilter<"Game"> | number | null
    coverImage?: XOR<ImageNullableScalarRelationFilter, ImageWhereInput> | null
    reviews?: ReviewListRelationFilter
    users?: GameUserListRelationFilter
    favouritedBy?: UserListRelationFilter
    genres?: GenreListRelationFilter
    platforms?: PlatformListRelationFilter
    tags?: GameTagListRelationFilter
    statuses?: GameStatusListRelationFilter
    developers?: DeveloperListRelationFilter
    publishers?: PublisherListRelationFilter
    images?: GameImageListRelationFilter
    achievements?: AchievementListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type GameOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    releaseDate?: SortOrderInput | SortOrder
    coverImageId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    coverImage?: ImageOrderByWithRelationInput
    reviews?: ReviewOrderByRelationAggregateInput
    users?: GameUserOrderByRelationAggregateInput
    favouritedBy?: UserOrderByRelationAggregateInput
    genres?: GenreOrderByRelationAggregateInput
    platforms?: PlatformOrderByRelationAggregateInput
    tags?: GameTagOrderByRelationAggregateInput
    statuses?: GameStatusOrderByRelationAggregateInput
    developers?: DeveloperOrderByRelationAggregateInput
    publishers?: PublisherOrderByRelationAggregateInput
    images?: GameImageOrderByRelationAggregateInput
    achievements?: AchievementOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
  }

  export type GameWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title_releaseDate?: GameTitleReleaseDateCompoundUniqueInput
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    title?: StringFilter<"Game"> | string
    description?: StringNullableFilter<"Game"> | string | null
    releaseDate?: DateTimeNullableFilter<"Game"> | Date | string | null
    coverImageId?: IntNullableFilter<"Game"> | number | null
    userId?: IntNullableFilter<"Game"> | number | null
    coverImage?: XOR<ImageNullableScalarRelationFilter, ImageWhereInput> | null
    reviews?: ReviewListRelationFilter
    users?: GameUserListRelationFilter
    favouritedBy?: UserListRelationFilter
    genres?: GenreListRelationFilter
    platforms?: PlatformListRelationFilter
    tags?: GameTagListRelationFilter
    statuses?: GameStatusListRelationFilter
    developers?: DeveloperListRelationFilter
    publishers?: PublisherListRelationFilter
    images?: GameImageListRelationFilter
    achievements?: AchievementListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "title_releaseDate">

  export type GameOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    releaseDate?: SortOrderInput | SortOrder
    coverImageId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: GameCountOrderByAggregateInput
    _avg?: GameAvgOrderByAggregateInput
    _max?: GameMaxOrderByAggregateInput
    _min?: GameMinOrderByAggregateInput
    _sum?: GameSumOrderByAggregateInput
  }

  export type GameScalarWhereWithAggregatesInput = {
    AND?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    OR?: GameScalarWhereWithAggregatesInput[]
    NOT?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Game"> | number
    title?: StringWithAggregatesFilter<"Game"> | string
    description?: StringNullableWithAggregatesFilter<"Game"> | string | null
    releaseDate?: DateTimeNullableWithAggregatesFilter<"Game"> | Date | string | null
    coverImageId?: IntNullableWithAggregatesFilter<"Game"> | number | null
    userId?: IntNullableWithAggregatesFilter<"Game"> | number | null
  }

  export type ImageWhereInput = {
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    id?: IntFilter<"Image"> | number
    url?: StringFilter<"Image"> | string
    checksum?: StringFilter<"Image"> | string
    width?: IntNullableFilter<"Image"> | number | null
    height?: IntNullableFilter<"Image"> | number | null
    uploadedAt?: DateTimeFilter<"Image"> | Date | string
    uploadedById?: IntNullableFilter<"Image"> | number | null
    uploadedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    games?: GameListRelationFilter
    User?: UserListRelationFilter
  }

  export type ImageOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    checksum?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    uploadedById?: SortOrderInput | SortOrder
    uploadedBy?: UserOrderByWithRelationInput
    games?: GameOrderByRelationAggregateInput
    User?: UserOrderByRelationAggregateInput
  }

  export type ImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    checksum?: string
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    url?: StringFilter<"Image"> | string
    width?: IntNullableFilter<"Image"> | number | null
    height?: IntNullableFilter<"Image"> | number | null
    uploadedAt?: DateTimeFilter<"Image"> | Date | string
    uploadedById?: IntNullableFilter<"Image"> | number | null
    uploadedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    games?: GameListRelationFilter
    User?: UserListRelationFilter
  }, "id" | "checksum">

  export type ImageOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    checksum?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    uploadedById?: SortOrderInput | SortOrder
    _count?: ImageCountOrderByAggregateInput
    _avg?: ImageAvgOrderByAggregateInput
    _max?: ImageMaxOrderByAggregateInput
    _min?: ImageMinOrderByAggregateInput
    _sum?: ImageSumOrderByAggregateInput
  }

  export type ImageScalarWhereWithAggregatesInput = {
    AND?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    OR?: ImageScalarWhereWithAggregatesInput[]
    NOT?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Image"> | number
    url?: StringWithAggregatesFilter<"Image"> | string
    checksum?: StringWithAggregatesFilter<"Image"> | string
    width?: IntNullableWithAggregatesFilter<"Image"> | number | null
    height?: IntNullableWithAggregatesFilter<"Image"> | number | null
    uploadedAt?: DateTimeWithAggregatesFilter<"Image"> | Date | string
    uploadedById?: IntNullableWithAggregatesFilter<"Image"> | number | null
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: IntFilter<"Review"> | number
    rating?: IntFilter<"Review"> | number
    content?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    userId?: IntFilter<"Review"> | number
    gameId?: IntFilter<"Review"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    tags?: ReviewUserTagListRelationFilter
    comments?: ReviewCommentListRelationFilter
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    rating?: SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    user?: UserOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
    tags?: ReviewUserTagOrderByRelationAggregateInput
    comments?: ReviewCommentOrderByRelationAggregateInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_gameId?: ReviewUserIdGameIdCompoundUniqueInput
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    rating?: IntFilter<"Review"> | number
    content?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    userId?: IntFilter<"Review"> | number
    gameId?: IntFilter<"Review"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    tags?: ReviewUserTagListRelationFilter
    comments?: ReviewCommentListRelationFilter
  }, "id" | "userId_gameId">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    rating?: SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Review"> | number
    rating?: IntWithAggregatesFilter<"Review"> | number
    content?: StringNullableWithAggregatesFilter<"Review"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    userId?: IntWithAggregatesFilter<"Review"> | number
    gameId?: IntWithAggregatesFilter<"Review"> | number
  }

  export type ReviewCommentWhereInput = {
    AND?: ReviewCommentWhereInput | ReviewCommentWhereInput[]
    OR?: ReviewCommentWhereInput[]
    NOT?: ReviewCommentWhereInput | ReviewCommentWhereInput[]
    id?: IntFilter<"ReviewComment"> | number
    content?: StringFilter<"ReviewComment"> | string
    createdAt?: DateTimeFilter<"ReviewComment"> | Date | string
    reviewId?: IntFilter<"ReviewComment"> | number
    userId?: IntFilter<"ReviewComment"> | number
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReviewCommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    review?: ReviewOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReviewCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReviewCommentWhereInput | ReviewCommentWhereInput[]
    OR?: ReviewCommentWhereInput[]
    NOT?: ReviewCommentWhereInput | ReviewCommentWhereInput[]
    content?: StringFilter<"ReviewComment"> | string
    createdAt?: DateTimeFilter<"ReviewComment"> | Date | string
    reviewId?: IntFilter<"ReviewComment"> | number
    userId?: IntFilter<"ReviewComment"> | number
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ReviewCommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    _count?: ReviewCommentCountOrderByAggregateInput
    _avg?: ReviewCommentAvgOrderByAggregateInput
    _max?: ReviewCommentMaxOrderByAggregateInput
    _min?: ReviewCommentMinOrderByAggregateInput
    _sum?: ReviewCommentSumOrderByAggregateInput
  }

  export type ReviewCommentScalarWhereWithAggregatesInput = {
    AND?: ReviewCommentScalarWhereWithAggregatesInput | ReviewCommentScalarWhereWithAggregatesInput[]
    OR?: ReviewCommentScalarWhereWithAggregatesInput[]
    NOT?: ReviewCommentScalarWhereWithAggregatesInput | ReviewCommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReviewComment"> | number
    content?: StringWithAggregatesFilter<"ReviewComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReviewComment"> | Date | string
    reviewId?: IntWithAggregatesFilter<"ReviewComment"> | number
    userId?: IntWithAggregatesFilter<"ReviewComment"> | number
  }

  export type GameUserWhereInput = {
    AND?: GameUserWhereInput | GameUserWhereInput[]
    OR?: GameUserWhereInput[]
    NOT?: GameUserWhereInput | GameUserWhereInput[]
    id?: IntFilter<"GameUser"> | number
    userId?: IntFilter<"GameUser"> | number
    gameId?: IntFilter<"GameUser"> | number
    progress?: EnumProgressStatusFilter<"GameUser"> | $Enums.ProgressStatus
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
  }

  export type GameUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    progress?: SortOrder
    user?: UserOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
  }

  export type GameUserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_gameId?: GameUserUserIdGameIdCompoundUniqueInput
    AND?: GameUserWhereInput | GameUserWhereInput[]
    OR?: GameUserWhereInput[]
    NOT?: GameUserWhereInput | GameUserWhereInput[]
    userId?: IntFilter<"GameUser"> | number
    gameId?: IntFilter<"GameUser"> | number
    progress?: EnumProgressStatusFilter<"GameUser"> | $Enums.ProgressStatus
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
  }, "id" | "userId_gameId">

  export type GameUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    progress?: SortOrder
    _count?: GameUserCountOrderByAggregateInput
    _avg?: GameUserAvgOrderByAggregateInput
    _max?: GameUserMaxOrderByAggregateInput
    _min?: GameUserMinOrderByAggregateInput
    _sum?: GameUserSumOrderByAggregateInput
  }

  export type GameUserScalarWhereWithAggregatesInput = {
    AND?: GameUserScalarWhereWithAggregatesInput | GameUserScalarWhereWithAggregatesInput[]
    OR?: GameUserScalarWhereWithAggregatesInput[]
    NOT?: GameUserScalarWhereWithAggregatesInput | GameUserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GameUser"> | number
    userId?: IntWithAggregatesFilter<"GameUser"> | number
    gameId?: IntWithAggregatesFilter<"GameUser"> | number
    progress?: EnumProgressStatusWithAggregatesFilter<"GameUser"> | $Enums.ProgressStatus
  }

  export type GameStatusWhereInput = {
    AND?: GameStatusWhereInput | GameStatusWhereInput[]
    OR?: GameStatusWhereInput[]
    NOT?: GameStatusWhereInput | GameStatusWhereInput[]
    id?: IntFilter<"GameStatus"> | number
    type?: EnumGameStatusTypeFilter<"GameStatus"> | $Enums.GameStatusType
    userId?: IntFilter<"GameStatus"> | number
    games?: GameListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GameStatusOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    games?: GameOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type GameStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_type?: GameStatusUserIdTypeCompoundUniqueInput
    AND?: GameStatusWhereInput | GameStatusWhereInput[]
    OR?: GameStatusWhereInput[]
    NOT?: GameStatusWhereInput | GameStatusWhereInput[]
    type?: EnumGameStatusTypeFilter<"GameStatus"> | $Enums.GameStatusType
    userId?: IntFilter<"GameStatus"> | number
    games?: GameListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_type">

  export type GameStatusOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    _count?: GameStatusCountOrderByAggregateInput
    _avg?: GameStatusAvgOrderByAggregateInput
    _max?: GameStatusMaxOrderByAggregateInput
    _min?: GameStatusMinOrderByAggregateInput
    _sum?: GameStatusSumOrderByAggregateInput
  }

  export type GameStatusScalarWhereWithAggregatesInput = {
    AND?: GameStatusScalarWhereWithAggregatesInput | GameStatusScalarWhereWithAggregatesInput[]
    OR?: GameStatusScalarWhereWithAggregatesInput[]
    NOT?: GameStatusScalarWhereWithAggregatesInput | GameStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GameStatus"> | number
    type?: EnumGameStatusTypeWithAggregatesFilter<"GameStatus"> | $Enums.GameStatusType
    userId?: IntWithAggregatesFilter<"GameStatus"> | number
  }

  export type UserTagWhereInput = {
    AND?: UserTagWhereInput | UserTagWhereInput[]
    OR?: UserTagWhereInput[]
    NOT?: UserTagWhereInput | UserTagWhereInput[]
    id?: IntFilter<"UserTag"> | number
    label?: StringFilter<"UserTag"> | string
    users?: UserListRelationFilter
  }

  export type UserTagOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type UserTagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    label?: string
    AND?: UserTagWhereInput | UserTagWhereInput[]
    OR?: UserTagWhereInput[]
    NOT?: UserTagWhereInput | UserTagWhereInput[]
    users?: UserListRelationFilter
  }, "id" | "label">

  export type UserTagOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    _count?: UserTagCountOrderByAggregateInput
    _avg?: UserTagAvgOrderByAggregateInput
    _max?: UserTagMaxOrderByAggregateInput
    _min?: UserTagMinOrderByAggregateInput
    _sum?: UserTagSumOrderByAggregateInput
  }

  export type UserTagScalarWhereWithAggregatesInput = {
    AND?: UserTagScalarWhereWithAggregatesInput | UserTagScalarWhereWithAggregatesInput[]
    OR?: UserTagScalarWhereWithAggregatesInput[]
    NOT?: UserTagScalarWhereWithAggregatesInput | UserTagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserTag"> | number
    label?: StringWithAggregatesFilter<"UserTag"> | string
  }

  export type GameTagWhereInput = {
    AND?: GameTagWhereInput | GameTagWhereInput[]
    OR?: GameTagWhereInput[]
    NOT?: GameTagWhereInput | GameTagWhereInput[]
    id?: IntFilter<"GameTag"> | number
    label?: StringFilter<"GameTag"> | string
    games?: GameListRelationFilter
  }

  export type GameTagOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    games?: GameOrderByRelationAggregateInput
  }

  export type GameTagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    label?: string
    AND?: GameTagWhereInput | GameTagWhereInput[]
    OR?: GameTagWhereInput[]
    NOT?: GameTagWhereInput | GameTagWhereInput[]
    games?: GameListRelationFilter
  }, "id" | "label">

  export type GameTagOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    _count?: GameTagCountOrderByAggregateInput
    _avg?: GameTagAvgOrderByAggregateInput
    _max?: GameTagMaxOrderByAggregateInput
    _min?: GameTagMinOrderByAggregateInput
    _sum?: GameTagSumOrderByAggregateInput
  }

  export type GameTagScalarWhereWithAggregatesInput = {
    AND?: GameTagScalarWhereWithAggregatesInput | GameTagScalarWhereWithAggregatesInput[]
    OR?: GameTagScalarWhereWithAggregatesInput[]
    NOT?: GameTagScalarWhereWithAggregatesInput | GameTagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GameTag"> | number
    label?: StringWithAggregatesFilter<"GameTag"> | string
  }

  export type ReviewUserTagWhereInput = {
    AND?: ReviewUserTagWhereInput | ReviewUserTagWhereInput[]
    OR?: ReviewUserTagWhereInput[]
    NOT?: ReviewUserTagWhereInput | ReviewUserTagWhereInput[]
    id?: IntFilter<"ReviewUserTag"> | number
    label?: StringFilter<"ReviewUserTag"> | string
    reviewId?: IntFilter<"ReviewUserTag"> | number
    userId?: IntFilter<"ReviewUserTag"> | number
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReviewUserTagOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    review?: ReviewOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReviewUserTagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    reviewId_userId_label?: ReviewUserTagReviewIdUserIdLabelCompoundUniqueInput
    AND?: ReviewUserTagWhereInput | ReviewUserTagWhereInput[]
    OR?: ReviewUserTagWhereInput[]
    NOT?: ReviewUserTagWhereInput | ReviewUserTagWhereInput[]
    label?: StringFilter<"ReviewUserTag"> | string
    reviewId?: IntFilter<"ReviewUserTag"> | number
    userId?: IntFilter<"ReviewUserTag"> | number
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "reviewId_userId_label">

  export type ReviewUserTagOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    _count?: ReviewUserTagCountOrderByAggregateInput
    _avg?: ReviewUserTagAvgOrderByAggregateInput
    _max?: ReviewUserTagMaxOrderByAggregateInput
    _min?: ReviewUserTagMinOrderByAggregateInput
    _sum?: ReviewUserTagSumOrderByAggregateInput
  }

  export type ReviewUserTagScalarWhereWithAggregatesInput = {
    AND?: ReviewUserTagScalarWhereWithAggregatesInput | ReviewUserTagScalarWhereWithAggregatesInput[]
    OR?: ReviewUserTagScalarWhereWithAggregatesInput[]
    NOT?: ReviewUserTagScalarWhereWithAggregatesInput | ReviewUserTagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReviewUserTag"> | number
    label?: StringWithAggregatesFilter<"ReviewUserTag"> | string
    reviewId?: IntWithAggregatesFilter<"ReviewUserTag"> | number
    userId?: IntWithAggregatesFilter<"ReviewUserTag"> | number
  }

  export type DeveloperWhereInput = {
    AND?: DeveloperWhereInput | DeveloperWhereInput[]
    OR?: DeveloperWhereInput[]
    NOT?: DeveloperWhereInput | DeveloperWhereInput[]
    id?: IntFilter<"Developer"> | number
    name?: StringFilter<"Developer"> | string
    games?: GameListRelationFilter
  }

  export type DeveloperOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    games?: GameOrderByRelationAggregateInput
  }

  export type DeveloperWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: DeveloperWhereInput | DeveloperWhereInput[]
    OR?: DeveloperWhereInput[]
    NOT?: DeveloperWhereInput | DeveloperWhereInput[]
    games?: GameListRelationFilter
  }, "id" | "name">

  export type DeveloperOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: DeveloperCountOrderByAggregateInput
    _avg?: DeveloperAvgOrderByAggregateInput
    _max?: DeveloperMaxOrderByAggregateInput
    _min?: DeveloperMinOrderByAggregateInput
    _sum?: DeveloperSumOrderByAggregateInput
  }

  export type DeveloperScalarWhereWithAggregatesInput = {
    AND?: DeveloperScalarWhereWithAggregatesInput | DeveloperScalarWhereWithAggregatesInput[]
    OR?: DeveloperScalarWhereWithAggregatesInput[]
    NOT?: DeveloperScalarWhereWithAggregatesInput | DeveloperScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Developer"> | number
    name?: StringWithAggregatesFilter<"Developer"> | string
  }

  export type PublisherWhereInput = {
    AND?: PublisherWhereInput | PublisherWhereInput[]
    OR?: PublisherWhereInput[]
    NOT?: PublisherWhereInput | PublisherWhereInput[]
    id?: IntFilter<"Publisher"> | number
    name?: StringFilter<"Publisher"> | string
    games?: GameListRelationFilter
  }

  export type PublisherOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    games?: GameOrderByRelationAggregateInput
  }

  export type PublisherWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: PublisherWhereInput | PublisherWhereInput[]
    OR?: PublisherWhereInput[]
    NOT?: PublisherWhereInput | PublisherWhereInput[]
    games?: GameListRelationFilter
  }, "id" | "name">

  export type PublisherOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: PublisherCountOrderByAggregateInput
    _avg?: PublisherAvgOrderByAggregateInput
    _max?: PublisherMaxOrderByAggregateInput
    _min?: PublisherMinOrderByAggregateInput
    _sum?: PublisherSumOrderByAggregateInput
  }

  export type PublisherScalarWhereWithAggregatesInput = {
    AND?: PublisherScalarWhereWithAggregatesInput | PublisherScalarWhereWithAggregatesInput[]
    OR?: PublisherScalarWhereWithAggregatesInput[]
    NOT?: PublisherScalarWhereWithAggregatesInput | PublisherScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Publisher"> | number
    name?: StringWithAggregatesFilter<"Publisher"> | string
  }

  export type GameImageWhereInput = {
    AND?: GameImageWhereInput | GameImageWhereInput[]
    OR?: GameImageWhereInput[]
    NOT?: GameImageWhereInput | GameImageWhereInput[]
    id?: IntFilter<"GameImage"> | number
    url?: StringFilter<"GameImage"> | string
    gameId?: IntFilter<"GameImage"> | number
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
  }

  export type GameImageOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    gameId?: SortOrder
    game?: GameOrderByWithRelationInput
  }

  export type GameImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GameImageWhereInput | GameImageWhereInput[]
    OR?: GameImageWhereInput[]
    NOT?: GameImageWhereInput | GameImageWhereInput[]
    url?: StringFilter<"GameImage"> | string
    gameId?: IntFilter<"GameImage"> | number
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
  }, "id">

  export type GameImageOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    gameId?: SortOrder
    _count?: GameImageCountOrderByAggregateInput
    _avg?: GameImageAvgOrderByAggregateInput
    _max?: GameImageMaxOrderByAggregateInput
    _min?: GameImageMinOrderByAggregateInput
    _sum?: GameImageSumOrderByAggregateInput
  }

  export type GameImageScalarWhereWithAggregatesInput = {
    AND?: GameImageScalarWhereWithAggregatesInput | GameImageScalarWhereWithAggregatesInput[]
    OR?: GameImageScalarWhereWithAggregatesInput[]
    NOT?: GameImageScalarWhereWithAggregatesInput | GameImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GameImage"> | number
    url?: StringWithAggregatesFilter<"GameImage"> | string
    gameId?: IntWithAggregatesFilter<"GameImage"> | number
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: IntFilter<"Achievement"> | number
    title?: StringFilter<"Achievement"> | string
    description?: StringNullableFilter<"Achievement"> | string | null
    gameId?: IntFilter<"Achievement"> | number
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    unlocks?: AchievementUnlockListRelationFilter
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    gameId?: SortOrder
    game?: GameOrderByWithRelationInput
    unlocks?: AchievementUnlockOrderByRelationAggregateInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    gameId_title?: AchievementGameIdTitleCompoundUniqueInput
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    title?: StringFilter<"Achievement"> | string
    description?: StringNullableFilter<"Achievement"> | string | null
    gameId?: IntFilter<"Achievement"> | number
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    unlocks?: AchievementUnlockListRelationFilter
  }, "id" | "gameId_title">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    gameId?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Achievement"> | number
    title?: StringWithAggregatesFilter<"Achievement"> | string
    description?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    gameId?: IntWithAggregatesFilter<"Achievement"> | number
  }

  export type AchievementUnlockWhereInput = {
    AND?: AchievementUnlockWhereInput | AchievementUnlockWhereInput[]
    OR?: AchievementUnlockWhereInput[]
    NOT?: AchievementUnlockWhereInput | AchievementUnlockWhereInput[]
    id?: IntFilter<"AchievementUnlock"> | number
    unlockedAt?: DateTimeFilter<"AchievementUnlock"> | Date | string
    userId?: IntFilter<"AchievementUnlock"> | number
    achievementId?: IntFilter<"AchievementUnlock"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    achievement?: XOR<AchievementScalarRelationFilter, AchievementWhereInput>
  }

  export type AchievementUnlockOrderByWithRelationInput = {
    id?: SortOrder
    unlockedAt?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    user?: UserOrderByWithRelationInput
    achievement?: AchievementOrderByWithRelationInput
  }

  export type AchievementUnlockWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_achievementId?: AchievementUnlockUserIdAchievementIdCompoundUniqueInput
    AND?: AchievementUnlockWhereInput | AchievementUnlockWhereInput[]
    OR?: AchievementUnlockWhereInput[]
    NOT?: AchievementUnlockWhereInput | AchievementUnlockWhereInput[]
    unlockedAt?: DateTimeFilter<"AchievementUnlock"> | Date | string
    userId?: IntFilter<"AchievementUnlock"> | number
    achievementId?: IntFilter<"AchievementUnlock"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    achievement?: XOR<AchievementScalarRelationFilter, AchievementWhereInput>
  }, "id" | "userId_achievementId">

  export type AchievementUnlockOrderByWithAggregationInput = {
    id?: SortOrder
    unlockedAt?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    _count?: AchievementUnlockCountOrderByAggregateInput
    _avg?: AchievementUnlockAvgOrderByAggregateInput
    _max?: AchievementUnlockMaxOrderByAggregateInput
    _min?: AchievementUnlockMinOrderByAggregateInput
    _sum?: AchievementUnlockSumOrderByAggregateInput
  }

  export type AchievementUnlockScalarWhereWithAggregatesInput = {
    AND?: AchievementUnlockScalarWhereWithAggregatesInput | AchievementUnlockScalarWhereWithAggregatesInput[]
    OR?: AchievementUnlockScalarWhereWithAggregatesInput[]
    NOT?: AchievementUnlockScalarWhereWithAggregatesInput | AchievementUnlockScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AchievementUnlock"> | number
    unlockedAt?: DateTimeWithAggregatesFilter<"AchievementUnlock"> | Date | string
    userId?: IntWithAggregatesFilter<"AchievementUnlock"> | number
    achievementId?: IntWithAggregatesFilter<"AchievementUnlock"> | number
  }

  export type EmailChangeWhereInput = {
    AND?: EmailChangeWhereInput | EmailChangeWhereInput[]
    OR?: EmailChangeWhereInput[]
    NOT?: EmailChangeWhereInput | EmailChangeWhereInput[]
    id?: IntFilter<"EmailChange"> | number
    userId?: IntFilter<"EmailChange"> | number
    newEmail?: StringFilter<"EmailChange"> | string
    token?: StringFilter<"EmailChange"> | string
    createdAt?: DateTimeFilter<"EmailChange"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EmailChangeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    newEmail?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EmailChangeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: EmailChangeWhereInput | EmailChangeWhereInput[]
    OR?: EmailChangeWhereInput[]
    NOT?: EmailChangeWhereInput | EmailChangeWhereInput[]
    userId?: IntFilter<"EmailChange"> | number
    newEmail?: StringFilter<"EmailChange"> | string
    createdAt?: DateTimeFilter<"EmailChange"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type EmailChangeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    newEmail?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    _count?: EmailChangeCountOrderByAggregateInput
    _avg?: EmailChangeAvgOrderByAggregateInput
    _max?: EmailChangeMaxOrderByAggregateInput
    _min?: EmailChangeMinOrderByAggregateInput
    _sum?: EmailChangeSumOrderByAggregateInput
  }

  export type EmailChangeScalarWhereWithAggregatesInput = {
    AND?: EmailChangeScalarWhereWithAggregatesInput | EmailChangeScalarWhereWithAggregatesInput[]
    OR?: EmailChangeScalarWhereWithAggregatesInput[]
    NOT?: EmailChangeScalarWhereWithAggregatesInput | EmailChangeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmailChange"> | number
    userId?: IntWithAggregatesFilter<"EmailChange"> | number
    newEmail?: StringWithAggregatesFilter<"EmailChange"> | string
    token?: StringWithAggregatesFilter<"EmailChange"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailChange"> | Date | string
  }

  export type EmailVerificationWhereInput = {
    AND?: EmailVerificationWhereInput | EmailVerificationWhereInput[]
    OR?: EmailVerificationWhereInput[]
    NOT?: EmailVerificationWhereInput | EmailVerificationWhereInput[]
    id?: IntFilter<"EmailVerification"> | number
    userId?: IntFilter<"EmailVerification"> | number
    token?: StringFilter<"EmailVerification"> | string
    createdAt?: DateTimeFilter<"EmailVerification"> | Date | string
    expiresAt?: DateTimeFilter<"EmailVerification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EmailVerificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EmailVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: EmailVerificationWhereInput | EmailVerificationWhereInput[]
    OR?: EmailVerificationWhereInput[]
    NOT?: EmailVerificationWhereInput | EmailVerificationWhereInput[]
    userId?: IntFilter<"EmailVerification"> | number
    createdAt?: DateTimeFilter<"EmailVerification"> | Date | string
    expiresAt?: DateTimeFilter<"EmailVerification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type EmailVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: EmailVerificationCountOrderByAggregateInput
    _avg?: EmailVerificationAvgOrderByAggregateInput
    _max?: EmailVerificationMaxOrderByAggregateInput
    _min?: EmailVerificationMinOrderByAggregateInput
    _sum?: EmailVerificationSumOrderByAggregateInput
  }

  export type EmailVerificationScalarWhereWithAggregatesInput = {
    AND?: EmailVerificationScalarWhereWithAggregatesInput | EmailVerificationScalarWhereWithAggregatesInput[]
    OR?: EmailVerificationScalarWhereWithAggregatesInput[]
    NOT?: EmailVerificationScalarWhereWithAggregatesInput | EmailVerificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmailVerification"> | number
    userId?: IntWithAggregatesFilter<"EmailVerification"> | number
    token?: StringWithAggregatesFilter<"EmailVerification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailVerification"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"EmailVerification"> | Date | string
  }

  export type PasswordResetWhereInput = {
    AND?: PasswordResetWhereInput | PasswordResetWhereInput[]
    OR?: PasswordResetWhereInput[]
    NOT?: PasswordResetWhereInput | PasswordResetWhereInput[]
    id?: IntFilter<"PasswordReset"> | number
    userId?: IntFilter<"PasswordReset"> | number
    token?: StringFilter<"PasswordReset"> | string
    createdAt?: DateTimeFilter<"PasswordReset"> | Date | string
    expiresAt?: DateTimeFilter<"PasswordReset"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: PasswordResetWhereInput | PasswordResetWhereInput[]
    OR?: PasswordResetWhereInput[]
    NOT?: PasswordResetWhereInput | PasswordResetWhereInput[]
    userId?: IntFilter<"PasswordReset"> | number
    createdAt?: DateTimeFilter<"PasswordReset"> | Date | string
    expiresAt?: DateTimeFilter<"PasswordReset"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type PasswordResetOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: PasswordResetCountOrderByAggregateInput
    _avg?: PasswordResetAvgOrderByAggregateInput
    _max?: PasswordResetMaxOrderByAggregateInput
    _min?: PasswordResetMinOrderByAggregateInput
    _sum?: PasswordResetSumOrderByAggregateInput
  }

  export type PasswordResetScalarWhereWithAggregatesInput = {
    AND?: PasswordResetScalarWhereWithAggregatesInput | PasswordResetScalarWhereWithAggregatesInput[]
    OR?: PasswordResetScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetScalarWhereWithAggregatesInput | PasswordResetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PasswordReset"> | number
    userId?: IntWithAggregatesFilter<"PasswordReset"> | number
    token?: StringWithAggregatesFilter<"PasswordReset"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PasswordReset"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordReset"> | Date | string
  }

  export type FriendshipWhereInput = {
    AND?: FriendshipWhereInput | FriendshipWhereInput[]
    OR?: FriendshipWhereInput[]
    NOT?: FriendshipWhereInput | FriendshipWhereInput[]
    id?: IntFilter<"Friendship"> | number
    senderId?: IntFilter<"Friendship"> | number
    receiverId?: IntFilter<"Friendship"> | number
    status?: EnumFriendshipStatusFilter<"Friendship"> | $Enums.FriendshipStatus
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FriendshipOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    sender?: UserOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
  }

  export type FriendshipWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    senderId_receiverId?: FriendshipSenderIdReceiverIdCompoundUniqueInput
    AND?: FriendshipWhereInput | FriendshipWhereInput[]
    OR?: FriendshipWhereInput[]
    NOT?: FriendshipWhereInput | FriendshipWhereInput[]
    senderId?: IntFilter<"Friendship"> | number
    receiverId?: IntFilter<"Friendship"> | number
    status?: EnumFriendshipStatusFilter<"Friendship"> | $Enums.FriendshipStatus
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "senderId_receiverId">

  export type FriendshipOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: FriendshipCountOrderByAggregateInput
    _avg?: FriendshipAvgOrderByAggregateInput
    _max?: FriendshipMaxOrderByAggregateInput
    _min?: FriendshipMinOrderByAggregateInput
    _sum?: FriendshipSumOrderByAggregateInput
  }

  export type FriendshipScalarWhereWithAggregatesInput = {
    AND?: FriendshipScalarWhereWithAggregatesInput | FriendshipScalarWhereWithAggregatesInput[]
    OR?: FriendshipScalarWhereWithAggregatesInput[]
    NOT?: FriendshipScalarWhereWithAggregatesInput | FriendshipScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Friendship"> | number
    senderId?: IntWithAggregatesFilter<"Friendship"> | number
    receiverId?: IntWithAggregatesFilter<"Friendship"> | number
    status?: EnumFriendshipStatusWithAggregatesFilter<"Friendship"> | $Enums.FriendshipStatus
    createdAt?: DateTimeWithAggregatesFilter<"Friendship"> | Date | string
  }

  export type UserGroupWhereInput = {
    AND?: UserGroupWhereInput | UserGroupWhereInput[]
    OR?: UserGroupWhereInput[]
    NOT?: UserGroupWhereInput | UserGroupWhereInput[]
    id?: IntFilter<"UserGroup"> | number
    name?: StringFilter<"UserGroup"> | string
    role?: StringFilter<"UserGroup"> | string
    users?: UserListRelationFilter
  }

  export type UserGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type UserGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: UserGroupWhereInput | UserGroupWhereInput[]
    OR?: UserGroupWhereInput[]
    NOT?: UserGroupWhereInput | UserGroupWhereInput[]
    role?: StringFilter<"UserGroup"> | string
    users?: UserListRelationFilter
  }, "id" | "name">

  export type UserGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    _count?: UserGroupCountOrderByAggregateInput
    _avg?: UserGroupAvgOrderByAggregateInput
    _max?: UserGroupMaxOrderByAggregateInput
    _min?: UserGroupMinOrderByAggregateInput
    _sum?: UserGroupSumOrderByAggregateInput
  }

  export type UserGroupScalarWhereWithAggregatesInput = {
    AND?: UserGroupScalarWhereWithAggregatesInput | UserGroupScalarWhereWithAggregatesInput[]
    OR?: UserGroupScalarWhereWithAggregatesInput[]
    NOT?: UserGroupScalarWhereWithAggregatesInput | UserGroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserGroup"> | number
    name?: StringWithAggregatesFilter<"UserGroup"> | string
    role?: StringWithAggregatesFilter<"UserGroup"> | string
  }

  export type GenreWhereInput = {
    AND?: GenreWhereInput | GenreWhereInput[]
    OR?: GenreWhereInput[]
    NOT?: GenreWhereInput | GenreWhereInput[]
    id?: IntFilter<"Genre"> | number
    name?: StringFilter<"Genre"> | string
    games?: GameListRelationFilter
  }

  export type GenreOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    games?: GameOrderByRelationAggregateInput
  }

  export type GenreWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: GenreWhereInput | GenreWhereInput[]
    OR?: GenreWhereInput[]
    NOT?: GenreWhereInput | GenreWhereInput[]
    games?: GameListRelationFilter
  }, "id" | "name">

  export type GenreOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: GenreCountOrderByAggregateInput
    _avg?: GenreAvgOrderByAggregateInput
    _max?: GenreMaxOrderByAggregateInput
    _min?: GenreMinOrderByAggregateInput
    _sum?: GenreSumOrderByAggregateInput
  }

  export type GenreScalarWhereWithAggregatesInput = {
    AND?: GenreScalarWhereWithAggregatesInput | GenreScalarWhereWithAggregatesInput[]
    OR?: GenreScalarWhereWithAggregatesInput[]
    NOT?: GenreScalarWhereWithAggregatesInput | GenreScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Genre"> | number
    name?: StringWithAggregatesFilter<"Genre"> | string
  }

  export type PlatformWhereInput = {
    AND?: PlatformWhereInput | PlatformWhereInput[]
    OR?: PlatformWhereInput[]
    NOT?: PlatformWhereInput | PlatformWhereInput[]
    id?: IntFilter<"Platform"> | number
    name?: StringFilter<"Platform"> | string
    games?: GameListRelationFilter
  }

  export type PlatformOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    games?: GameOrderByRelationAggregateInput
  }

  export type PlatformWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: PlatformWhereInput | PlatformWhereInput[]
    OR?: PlatformWhereInput[]
    NOT?: PlatformWhereInput | PlatformWhereInput[]
    games?: GameListRelationFilter
  }, "id" | "name">

  export type PlatformOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: PlatformCountOrderByAggregateInput
    _avg?: PlatformAvgOrderByAggregateInput
    _max?: PlatformMaxOrderByAggregateInput
    _min?: PlatformMinOrderByAggregateInput
    _sum?: PlatformSumOrderByAggregateInput
  }

  export type PlatformScalarWhereWithAggregatesInput = {
    AND?: PlatformScalarWhereWithAggregatesInput | PlatformScalarWhereWithAggregatesInput[]
    OR?: PlatformScalarWhereWithAggregatesInput[]
    NOT?: PlatformScalarWhereWithAggregatesInput | PlatformScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Platform"> | number
    name?: StringWithAggregatesFilter<"Platform"> | string
  }

  export type UserCreateInput = {
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    profilePicture?: ImageCreateNestedOneWithoutUserInput
    emailChanges?: EmailChangeCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    playedGames?: GameCreateNestedManyWithoutUserInput
    favourites?: GameCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipCreateNestedManyWithoutReceiverInput
    groups?: UserGroupCreateNestedManyWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagCreateNestedManyWithoutUserInput
    userTags?: UserTagCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockCreateNestedManyWithoutUserInput
    uploadedImages?: ImageCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentCreateNestedManyWithoutUserInput
    GameUser?: GameUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    profilePictureId?: number | null
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    emailChanges?: EmailChangeUncheckedCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    playedGames?: GameUncheckedCreateNestedManyWithoutUserInput
    favourites?: GameUncheckedCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutReceiverInput
    groups?: UserGroupUncheckedCreateNestedManyWithoutUsersInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagUncheckedCreateNestedManyWithoutUserInput
    userTags?: UserTagUncheckedCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutUserInput
    uploadedImages?: ImageUncheckedCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    GameUser?: GameUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: ImageUpdateOneWithoutUserNestedInput
    emailChanges?: EmailChangeUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    playedGames?: GameUpdateManyWithoutUserNestedInput
    favourites?: GameUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUpdateManyWithoutUserNestedInput
    userTags?: UserTagUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    profilePictureId?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    emailChanges?: EmailChangeUncheckedUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    playedGames?: GameUncheckedUpdateManyWithoutUserNestedInput
    favourites?: GameUncheckedUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUncheckedUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUncheckedUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUncheckedUpdateManyWithoutUserNestedInput
    userTags?: UserTagUncheckedUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUncheckedUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    profilePictureId?: number | null
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    profilePictureId?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCreateInput = {
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImage?: ImageCreateNestedOneWithoutGamesInput
    reviews?: ReviewCreateNestedManyWithoutGameInput
    users?: GameUserCreateNestedManyWithoutGameInput
    favouritedBy?: UserCreateNestedManyWithoutFavouritesInput
    genres?: GenreCreateNestedManyWithoutGamesInput
    platforms?: PlatformCreateNestedManyWithoutGamesInput
    tags?: GameTagCreateNestedManyWithoutGamesInput
    statuses?: GameStatusCreateNestedManyWithoutGamesInput
    developers?: DeveloperCreateNestedManyWithoutGamesInput
    publishers?: PublisherCreateNestedManyWithoutGamesInput
    images?: GameImageCreateNestedManyWithoutGameInput
    achievements?: AchievementCreateNestedManyWithoutGameInput
    User?: UserCreateNestedOneWithoutPlayedGamesInput
  }

  export type GameUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImageId?: number | null
    userId?: number | null
    reviews?: ReviewUncheckedCreateNestedManyWithoutGameInput
    users?: GameUserUncheckedCreateNestedManyWithoutGameInput
    favouritedBy?: UserUncheckedCreateNestedManyWithoutFavouritesInput
    genres?: GenreUncheckedCreateNestedManyWithoutGamesInput
    platforms?: PlatformUncheckedCreateNestedManyWithoutGamesInput
    tags?: GameTagUncheckedCreateNestedManyWithoutGamesInput
    statuses?: GameStatusUncheckedCreateNestedManyWithoutGamesInput
    developers?: DeveloperUncheckedCreateNestedManyWithoutGamesInput
    publishers?: PublisherUncheckedCreateNestedManyWithoutGamesInput
    images?: GameImageUncheckedCreateNestedManyWithoutGameInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: ImageUpdateOneWithoutGamesNestedInput
    reviews?: ReviewUpdateManyWithoutGameNestedInput
    users?: GameUserUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUpdateManyWithoutGamesNestedInput
    tags?: GameTagUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUpdateManyWithoutGamesNestedInput
    images?: GameImageUpdateManyWithoutGameNestedInput
    achievements?: AchievementUpdateManyWithoutGameNestedInput
    User?: UserUpdateOneWithoutPlayedGamesNestedInput
  }

  export type GameUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: ReviewUncheckedUpdateManyWithoutGameNestedInput
    users?: GameUserUncheckedUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUncheckedUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUncheckedUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUncheckedUpdateManyWithoutGamesNestedInput
    tags?: GameTagUncheckedUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUncheckedUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUncheckedUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUncheckedUpdateManyWithoutGamesNestedInput
    images?: GameImageUncheckedUpdateManyWithoutGameNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImageId?: number | null
    userId?: number | null
  }

  export type GameUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ImageCreateInput = {
    url: string
    checksum: string
    width?: number | null
    height?: number | null
    uploadedAt?: Date | string
    uploadedBy?: UserCreateNestedOneWithoutUploadedImagesInput
    games?: GameCreateNestedManyWithoutCoverImageInput
    User?: UserCreateNestedManyWithoutProfilePictureInput
  }

  export type ImageUncheckedCreateInput = {
    id?: number
    url: string
    checksum: string
    width?: number | null
    height?: number | null
    uploadedAt?: Date | string
    uploadedById?: number | null
    games?: GameUncheckedCreateNestedManyWithoutCoverImageInput
    User?: UserUncheckedCreateNestedManyWithoutProfilePictureInput
  }

  export type ImageUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneWithoutUploadedImagesNestedInput
    games?: GameUpdateManyWithoutCoverImageNestedInput
    User?: UserUpdateManyWithoutProfilePictureNestedInput
  }

  export type ImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: NullableIntFieldUpdateOperationsInput | number | null
    games?: GameUncheckedUpdateManyWithoutCoverImageNestedInput
    User?: UserUncheckedUpdateManyWithoutProfilePictureNestedInput
  }

  export type ImageCreateManyInput = {
    id?: number
    url: string
    checksum: string
    width?: number | null
    height?: number | null
    uploadedAt?: Date | string
    uploadedById?: number | null
  }

  export type ImageUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReviewCreateInput = {
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    game: GameCreateNestedOneWithoutReviewsInput
    tags?: ReviewUserTagCreateNestedManyWithoutReviewInput
    comments?: ReviewCommentCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: number
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    gameId: number
    tags?: ReviewUserTagUncheckedCreateNestedManyWithoutReviewInput
    comments?: ReviewCommentUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewUpdateInput = {
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    game?: GameUpdateOneRequiredWithoutReviewsNestedInput
    tags?: ReviewUserTagUpdateManyWithoutReviewNestedInput
    comments?: ReviewCommentUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    tags?: ReviewUserTagUncheckedUpdateManyWithoutReviewNestedInput
    comments?: ReviewCommentUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewCreateManyInput = {
    id?: number
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    gameId: number
  }

  export type ReviewUpdateManyMutationInput = {
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewCommentCreateInput = {
    content: string
    createdAt?: Date | string
    review: ReviewCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutReviewCommentInput
  }

  export type ReviewCommentUncheckedCreateInput = {
    id?: number
    content: string
    createdAt?: Date | string
    reviewId: number
    userId: number
  }

  export type ReviewCommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutReviewCommentNestedInput
  }

  export type ReviewCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewCommentCreateManyInput = {
    id?: number
    content: string
    createdAt?: Date | string
    reviewId: number
    userId: number
  }

  export type ReviewCommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type GameUserCreateInput = {
    progress?: $Enums.ProgressStatus
    user: UserCreateNestedOneWithoutGameUserInput
    game: GameCreateNestedOneWithoutUsersInput
  }

  export type GameUserUncheckedCreateInput = {
    id?: number
    userId: number
    gameId: number
    progress?: $Enums.ProgressStatus
  }

  export type GameUserUpdateInput = {
    progress?: EnumProgressStatusFieldUpdateOperationsInput | $Enums.ProgressStatus
    user?: UserUpdateOneRequiredWithoutGameUserNestedInput
    game?: GameUpdateOneRequiredWithoutUsersNestedInput
  }

  export type GameUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    progress?: EnumProgressStatusFieldUpdateOperationsInput | $Enums.ProgressStatus
  }

  export type GameUserCreateManyInput = {
    id?: number
    userId: number
    gameId: number
    progress?: $Enums.ProgressStatus
  }

  export type GameUserUpdateManyMutationInput = {
    progress?: EnumProgressStatusFieldUpdateOperationsInput | $Enums.ProgressStatus
  }

  export type GameUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    progress?: EnumProgressStatusFieldUpdateOperationsInput | $Enums.ProgressStatus
  }

  export type GameStatusCreateInput = {
    type: $Enums.GameStatusType
    games?: GameCreateNestedManyWithoutStatusesInput
    user: UserCreateNestedOneWithoutGameStatusesInput
  }

  export type GameStatusUncheckedCreateInput = {
    id?: number
    type: $Enums.GameStatusType
    userId: number
    games?: GameUncheckedCreateNestedManyWithoutStatusesInput
  }

  export type GameStatusUpdateInput = {
    type?: EnumGameStatusTypeFieldUpdateOperationsInput | $Enums.GameStatusType
    games?: GameUpdateManyWithoutStatusesNestedInput
    user?: UserUpdateOneRequiredWithoutGameStatusesNestedInput
  }

  export type GameStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumGameStatusTypeFieldUpdateOperationsInput | $Enums.GameStatusType
    userId?: IntFieldUpdateOperationsInput | number
    games?: GameUncheckedUpdateManyWithoutStatusesNestedInput
  }

  export type GameStatusCreateManyInput = {
    id?: number
    type: $Enums.GameStatusType
    userId: number
  }

  export type GameStatusUpdateManyMutationInput = {
    type?: EnumGameStatusTypeFieldUpdateOperationsInput | $Enums.GameStatusType
  }

  export type GameStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumGameStatusTypeFieldUpdateOperationsInput | $Enums.GameStatusType
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserTagCreateInput = {
    label: string
    users?: UserCreateNestedManyWithoutUserTagsInput
  }

  export type UserTagUncheckedCreateInput = {
    id?: number
    label: string
    users?: UserUncheckedCreateNestedManyWithoutUserTagsInput
  }

  export type UserTagUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutUserTagsNestedInput
  }

  export type UserTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutUserTagsNestedInput
  }

  export type UserTagCreateManyInput = {
    id?: number
    label: string
  }

  export type UserTagUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
  }

  export type UserTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
  }

  export type GameTagCreateInput = {
    label: string
    games?: GameCreateNestedManyWithoutTagsInput
  }

  export type GameTagUncheckedCreateInput = {
    id?: number
    label: string
    games?: GameUncheckedCreateNestedManyWithoutTagsInput
  }

  export type GameTagUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    games?: GameUpdateManyWithoutTagsNestedInput
  }

  export type GameTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    games?: GameUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type GameTagCreateManyInput = {
    id?: number
    label: string
  }

  export type GameTagUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
  }

  export type GameTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewUserTagCreateInput = {
    label: string
    review: ReviewCreateNestedOneWithoutTagsInput
    user: UserCreateNestedOneWithoutReviewTagsInput
  }

  export type ReviewUserTagUncheckedCreateInput = {
    id?: number
    label: string
    reviewId: number
    userId: number
  }

  export type ReviewUserTagUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    review?: ReviewUpdateOneRequiredWithoutTagsNestedInput
    user?: UserUpdateOneRequiredWithoutReviewTagsNestedInput
  }

  export type ReviewUserTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    reviewId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewUserTagCreateManyInput = {
    id?: number
    label: string
    reviewId: number
    userId: number
  }

  export type ReviewUserTagUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewUserTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    reviewId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type DeveloperCreateInput = {
    name: string
    games?: GameCreateNestedManyWithoutDevelopersInput
  }

  export type DeveloperUncheckedCreateInput = {
    id?: number
    name: string
    games?: GameUncheckedCreateNestedManyWithoutDevelopersInput
  }

  export type DeveloperUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    games?: GameUpdateManyWithoutDevelopersNestedInput
  }

  export type DeveloperUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    games?: GameUncheckedUpdateManyWithoutDevelopersNestedInput
  }

  export type DeveloperCreateManyInput = {
    id?: number
    name: string
  }

  export type DeveloperUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeveloperUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PublisherCreateInput = {
    name: string
    games?: GameCreateNestedManyWithoutPublishersInput
  }

  export type PublisherUncheckedCreateInput = {
    id?: number
    name: string
    games?: GameUncheckedCreateNestedManyWithoutPublishersInput
  }

  export type PublisherUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    games?: GameUpdateManyWithoutPublishersNestedInput
  }

  export type PublisherUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    games?: GameUncheckedUpdateManyWithoutPublishersNestedInput
  }

  export type PublisherCreateManyInput = {
    id?: number
    name: string
  }

  export type PublisherUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PublisherUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GameImageCreateInput = {
    url: string
    game: GameCreateNestedOneWithoutImagesInput
  }

  export type GameImageUncheckedCreateInput = {
    id?: number
    url: string
    gameId: number
  }

  export type GameImageUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    game?: GameUpdateOneRequiredWithoutImagesNestedInput
  }

  export type GameImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    gameId?: IntFieldUpdateOperationsInput | number
  }

  export type GameImageCreateManyInput = {
    id?: number
    url: string
    gameId: number
  }

  export type GameImageUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
  }

  export type GameImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    gameId?: IntFieldUpdateOperationsInput | number
  }

  export type AchievementCreateInput = {
    title: string
    description?: string | null
    game: GameCreateNestedOneWithoutAchievementsInput
    unlocks?: AchievementUnlockCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    gameId: number
    unlocks?: AchievementUnlockUncheckedCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    game?: GameUpdateOneRequiredWithoutAchievementsNestedInput
    unlocks?: AchievementUnlockUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: IntFieldUpdateOperationsInput | number
    unlocks?: AchievementUnlockUncheckedUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    gameId: number
  }

  export type AchievementUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: IntFieldUpdateOperationsInput | number
  }

  export type AchievementUnlockCreateInput = {
    unlockedAt?: Date | string
    user: UserCreateNestedOneWithoutAchievementsInput
    achievement: AchievementCreateNestedOneWithoutUnlocksInput
  }

  export type AchievementUnlockUncheckedCreateInput = {
    id?: number
    unlockedAt?: Date | string
    userId: number
    achievementId: number
  }

  export type AchievementUnlockUpdateInput = {
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutUnlocksNestedInput
  }

  export type AchievementUnlockUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    achievementId?: IntFieldUpdateOperationsInput | number
  }

  export type AchievementUnlockCreateManyInput = {
    id?: number
    unlockedAt?: Date | string
    userId: number
    achievementId: number
  }

  export type AchievementUnlockUpdateManyMutationInput = {
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUnlockUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    achievementId?: IntFieldUpdateOperationsInput | number
  }

  export type EmailChangeCreateInput = {
    newEmail: string
    token: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEmailChangesInput
  }

  export type EmailChangeUncheckedCreateInput = {
    id?: number
    userId: number
    newEmail: string
    token: string
    createdAt?: Date | string
  }

  export type EmailChangeUpdateInput = {
    newEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailChangesNestedInput
  }

  export type EmailChangeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    newEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailChangeCreateManyInput = {
    id?: number
    userId: number
    newEmail: string
    token: string
    createdAt?: Date | string
  }

  export type EmailChangeUpdateManyMutationInput = {
    newEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailChangeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    newEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationCreateInput = {
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutEmailVerificationsInput
  }

  export type EmailVerificationUncheckedCreateInput = {
    id?: number
    userId: number
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type EmailVerificationUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailVerificationsNestedInput
  }

  export type EmailVerificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationCreateManyInput = {
    id?: number
    userId: number
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type EmailVerificationUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetCreateInput = {
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutPasswordResetsInput
  }

  export type PasswordResetUncheckedCreateInput = {
    id?: number
    userId: number
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type PasswordResetUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetsNestedInput
  }

  export type PasswordResetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetCreateManyInput = {
    id?: number
    userId: number
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type PasswordResetUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipCreateInput = {
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentFriendRequestsInput
    receiver: UserCreateNestedOneWithoutReceivedFriendRequestsInput
  }

  export type FriendshipUncheckedCreateInput = {
    id?: number
    senderId: number
    receiverId: number
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
  }

  export type FriendshipUpdateInput = {
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentFriendRequestsNestedInput
    receiver?: UserUpdateOneRequiredWithoutReceivedFriendRequestsNestedInput
  }

  export type FriendshipUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipCreateManyInput = {
    id?: number
    senderId: number
    receiverId: number
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
  }

  export type FriendshipUpdateManyMutationInput = {
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupCreateInput = {
    name: string
    role?: string
    users?: UserCreateNestedManyWithoutGroupsInput
  }

  export type UserGroupUncheckedCreateInput = {
    id?: number
    name: string
    role?: string
    users?: UserUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type UserGroupUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutGroupsNestedInput
  }

  export type UserGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type UserGroupCreateManyInput = {
    id?: number
    name: string
    role?: string
  }

  export type UserGroupUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UserGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type GenreCreateInput = {
    name: string
    games?: GameCreateNestedManyWithoutGenresInput
  }

  export type GenreUncheckedCreateInput = {
    id?: number
    name: string
    games?: GameUncheckedCreateNestedManyWithoutGenresInput
  }

  export type GenreUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    games?: GameUpdateManyWithoutGenresNestedInput
  }

  export type GenreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    games?: GameUncheckedUpdateManyWithoutGenresNestedInput
  }

  export type GenreCreateManyInput = {
    id?: number
    name: string
  }

  export type GenreUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GenreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PlatformCreateInput = {
    name: string
    games?: GameCreateNestedManyWithoutPlatformsInput
  }

  export type PlatformUncheckedCreateInput = {
    id?: number
    name: string
    games?: GameUncheckedCreateNestedManyWithoutPlatformsInput
  }

  export type PlatformUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    games?: GameUpdateManyWithoutPlatformsNestedInput
  }

  export type PlatformUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    games?: GameUncheckedUpdateManyWithoutPlatformsNestedInput
  }

  export type PlatformCreateManyInput = {
    id?: number
    name: string
  }

  export type PlatformUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PlatformUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ImageNullableScalarRelationFilter = {
    is?: ImageWhereInput | null
    isNot?: ImageWhereInput | null
  }

  export type EmailChangeListRelationFilter = {
    every?: EmailChangeWhereInput
    some?: EmailChangeWhereInput
    none?: EmailChangeWhereInput
  }

  export type EmailVerificationListRelationFilter = {
    every?: EmailVerificationWhereInput
    some?: EmailVerificationWhereInput
    none?: EmailVerificationWhereInput
  }

  export type PasswordResetListRelationFilter = {
    every?: PasswordResetWhereInput
    some?: PasswordResetWhereInput
    none?: PasswordResetWhereInput
  }

  export type GameListRelationFilter = {
    every?: GameWhereInput
    some?: GameWhereInput
    none?: GameWhereInput
  }

  export type FriendshipListRelationFilter = {
    every?: FriendshipWhereInput
    some?: FriendshipWhereInput
    none?: FriendshipWhereInput
  }

  export type UserGroupListRelationFilter = {
    every?: UserGroupWhereInput
    some?: UserGroupWhereInput
    none?: UserGroupWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type ReviewUserTagListRelationFilter = {
    every?: ReviewUserTagWhereInput
    some?: ReviewUserTagWhereInput
    none?: ReviewUserTagWhereInput
  }

  export type UserTagListRelationFilter = {
    every?: UserTagWhereInput
    some?: UserTagWhereInput
    none?: UserTagWhereInput
  }

  export type GameStatusListRelationFilter = {
    every?: GameStatusWhereInput
    some?: GameStatusWhereInput
    none?: GameStatusWhereInput
  }

  export type AchievementUnlockListRelationFilter = {
    every?: AchievementUnlockWhereInput
    some?: AchievementUnlockWhereInput
    none?: AchievementUnlockWhereInput
  }

  export type ImageListRelationFilter = {
    every?: ImageWhereInput
    some?: ImageWhereInput
    none?: ImageWhereInput
  }

  export type ReviewCommentListRelationFilter = {
    every?: ReviewCommentWhereInput
    some?: ReviewCommentWhereInput
    none?: ReviewCommentWhereInput
  }

  export type GameUserListRelationFilter = {
    every?: GameUserWhereInput
    some?: GameUserWhereInput
    none?: GameUserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EmailChangeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailVerificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FriendshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewUserTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameStatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AchievementUnlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    googleId?: SortOrder
    displayName?: SortOrder
    profilePictureId?: SortOrder
    emailVerified?: SortOrder
    birthDate?: SortOrder
    registrationDate?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    profilePictureId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    googleId?: SortOrder
    displayName?: SortOrder
    profilePictureId?: SortOrder
    emailVerified?: SortOrder
    birthDate?: SortOrder
    registrationDate?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    googleId?: SortOrder
    displayName?: SortOrder
    profilePictureId?: SortOrder
    emailVerified?: SortOrder
    birthDate?: SortOrder
    registrationDate?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    profilePictureId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type GenreListRelationFilter = {
    every?: GenreWhereInput
    some?: GenreWhereInput
    none?: GenreWhereInput
  }

  export type PlatformListRelationFilter = {
    every?: PlatformWhereInput
    some?: PlatformWhereInput
    none?: PlatformWhereInput
  }

  export type GameTagListRelationFilter = {
    every?: GameTagWhereInput
    some?: GameTagWhereInput
    none?: GameTagWhereInput
  }

  export type DeveloperListRelationFilter = {
    every?: DeveloperWhereInput
    some?: DeveloperWhereInput
    none?: DeveloperWhereInput
  }

  export type PublisherListRelationFilter = {
    every?: PublisherWhereInput
    some?: PublisherWhereInput
    none?: PublisherWhereInput
  }

  export type GameImageListRelationFilter = {
    every?: GameImageWhereInput
    some?: GameImageWhereInput
    none?: GameImageWhereInput
  }

  export type AchievementListRelationFilter = {
    every?: AchievementWhereInput
    some?: AchievementWhereInput
    none?: AchievementWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GenreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlatformOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeveloperOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PublisherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameTitleReleaseDateCompoundUniqueInput = {
    title: string
    releaseDate: Date | string
  }

  export type GameCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    releaseDate?: SortOrder
    coverImageId?: SortOrder
    userId?: SortOrder
  }

  export type GameAvgOrderByAggregateInput = {
    id?: SortOrder
    coverImageId?: SortOrder
    userId?: SortOrder
  }

  export type GameMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    releaseDate?: SortOrder
    coverImageId?: SortOrder
    userId?: SortOrder
  }

  export type GameMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    releaseDate?: SortOrder
    coverImageId?: SortOrder
    userId?: SortOrder
  }

  export type GameSumOrderByAggregateInput = {
    id?: SortOrder
    coverImageId?: SortOrder
    userId?: SortOrder
  }

  export type ImageCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    checksum?: SortOrder
    width?: SortOrder
    height?: SortOrder
    uploadedAt?: SortOrder
    uploadedById?: SortOrder
  }

  export type ImageAvgOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    uploadedById?: SortOrder
  }

  export type ImageMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    checksum?: SortOrder
    width?: SortOrder
    height?: SortOrder
    uploadedAt?: SortOrder
    uploadedById?: SortOrder
  }

  export type ImageMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    checksum?: SortOrder
    width?: SortOrder
    height?: SortOrder
    uploadedAt?: SortOrder
    uploadedById?: SortOrder
  }

  export type ImageSumOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    uploadedById?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type GameScalarRelationFilter = {
    is?: GameWhereInput
    isNot?: GameWhereInput
  }

  export type ReviewUserIdGameIdCompoundUniqueInput = {
    userId: number
    gameId: number
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
  }

  export type ReviewScalarRelationFilter = {
    is?: ReviewWhereInput
    isNot?: ReviewWhereInput
  }

  export type ReviewCommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
  }

  export type ReviewCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
  }

  export type ReviewCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
  }

  export type ReviewCommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
  }

  export type ReviewCommentSumOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
  }

  export type EnumProgressStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProgressStatus | EnumProgressStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProgressStatus[] | ListEnumProgressStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProgressStatus[] | ListEnumProgressStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProgressStatusFilter<$PrismaModel> | $Enums.ProgressStatus
  }

  export type GameUserUserIdGameIdCompoundUniqueInput = {
    userId: number
    gameId: number
  }

  export type GameUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    progress?: SortOrder
  }

  export type GameUserAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
  }

  export type GameUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    progress?: SortOrder
  }

  export type GameUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    progress?: SortOrder
  }

  export type GameUserSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
  }

  export type EnumProgressStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProgressStatus | EnumProgressStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProgressStatus[] | ListEnumProgressStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProgressStatus[] | ListEnumProgressStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProgressStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProgressStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProgressStatusFilter<$PrismaModel>
    _max?: NestedEnumProgressStatusFilter<$PrismaModel>
  }

  export type EnumGameStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatusType | EnumGameStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatusType[] | ListEnumGameStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatusType[] | ListEnumGameStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusTypeFilter<$PrismaModel> | $Enums.GameStatusType
  }

  export type GameStatusUserIdTypeCompoundUniqueInput = {
    userId: number
    type: $Enums.GameStatusType
  }

  export type GameStatusCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
  }

  export type GameStatusAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type GameStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
  }

  export type GameStatusMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
  }

  export type GameStatusSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumGameStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatusType | EnumGameStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatusType[] | ListEnumGameStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatusType[] | ListEnumGameStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.GameStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumGameStatusTypeFilter<$PrismaModel>
  }

  export type UserTagCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
  }

  export type UserTagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserTagMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
  }

  export type UserTagMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
  }

  export type UserTagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GameTagCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
  }

  export type GameTagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GameTagMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
  }

  export type GameTagMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
  }

  export type GameTagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReviewUserTagReviewIdUserIdLabelCompoundUniqueInput = {
    reviewId: number
    userId: number
    label: string
  }

  export type ReviewUserTagCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
  }

  export type ReviewUserTagAvgOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
  }

  export type ReviewUserTagMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
  }

  export type ReviewUserTagMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
  }

  export type ReviewUserTagSumOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
  }

  export type DeveloperCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DeveloperAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeveloperMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DeveloperMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DeveloperSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PublisherCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PublisherAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PublisherMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PublisherMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PublisherSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GameImageCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    gameId?: SortOrder
  }

  export type GameImageAvgOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
  }

  export type GameImageMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    gameId?: SortOrder
  }

  export type GameImageMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    gameId?: SortOrder
  }

  export type GameImageSumOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
  }

  export type AchievementGameIdTitleCompoundUniqueInput = {
    gameId: number
    title: string
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    gameId?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    gameId?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    gameId?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
  }

  export type AchievementScalarRelationFilter = {
    is?: AchievementWhereInput
    isNot?: AchievementWhereInput
  }

  export type AchievementUnlockUserIdAchievementIdCompoundUniqueInput = {
    userId: number
    achievementId: number
  }

  export type AchievementUnlockCountOrderByAggregateInput = {
    id?: SortOrder
    unlockedAt?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
  }

  export type AchievementUnlockAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
  }

  export type AchievementUnlockMaxOrderByAggregateInput = {
    id?: SortOrder
    unlockedAt?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
  }

  export type AchievementUnlockMinOrderByAggregateInput = {
    id?: SortOrder
    unlockedAt?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
  }

  export type AchievementUnlockSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
  }

  export type EmailChangeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    newEmail?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailChangeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EmailChangeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    newEmail?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailChangeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    newEmail?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailChangeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EmailVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EmailVerificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EmailVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EmailVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EmailVerificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PasswordResetCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type PasswordResetAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PasswordResetMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type PasswordResetMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type PasswordResetSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumFriendshipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusFilter<$PrismaModel> | $Enums.FriendshipStatus
  }

  export type FriendshipSenderIdReceiverIdCompoundUniqueInput = {
    senderId: number
    receiverId: number
  }

  export type FriendshipCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type FriendshipAvgOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
  }

  export type FriendshipMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type FriendshipMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type FriendshipSumOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
  }

  export type EnumFriendshipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusWithAggregatesFilter<$PrismaModel> | $Enums.FriendshipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFriendshipStatusFilter<$PrismaModel>
    _max?: NestedEnumFriendshipStatusFilter<$PrismaModel>
  }

  export type UserGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
  }

  export type UserGroupAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
  }

  export type UserGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
  }

  export type UserGroupSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GenreCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type GenreAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GenreMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type GenreMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type GenreSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PlatformCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PlatformAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PlatformMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PlatformMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PlatformSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ImageCreateNestedOneWithoutUserInput = {
    create?: XOR<ImageCreateWithoutUserInput, ImageUncheckedCreateWithoutUserInput>
    connectOrCreate?: ImageCreateOrConnectWithoutUserInput
    connect?: ImageWhereUniqueInput
  }

  export type EmailChangeCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailChangeCreateWithoutUserInput, EmailChangeUncheckedCreateWithoutUserInput> | EmailChangeCreateWithoutUserInput[] | EmailChangeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailChangeCreateOrConnectWithoutUserInput | EmailChangeCreateOrConnectWithoutUserInput[]
    createMany?: EmailChangeCreateManyUserInputEnvelope
    connect?: EmailChangeWhereUniqueInput | EmailChangeWhereUniqueInput[]
  }

  export type EmailVerificationCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailVerificationCreateWithoutUserInput, EmailVerificationUncheckedCreateWithoutUserInput> | EmailVerificationCreateWithoutUserInput[] | EmailVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailVerificationCreateOrConnectWithoutUserInput | EmailVerificationCreateOrConnectWithoutUserInput[]
    createMany?: EmailVerificationCreateManyUserInputEnvelope
    connect?: EmailVerificationWhereUniqueInput | EmailVerificationWhereUniqueInput[]
  }

  export type PasswordResetCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
  }

  export type GameCreateNestedManyWithoutUserInput = {
    create?: XOR<GameCreateWithoutUserInput, GameUncheckedCreateWithoutUserInput> | GameCreateWithoutUserInput[] | GameUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameCreateOrConnectWithoutUserInput | GameCreateOrConnectWithoutUserInput[]
    createMany?: GameCreateManyUserInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type GameCreateNestedManyWithoutFavouritedByInput = {
    create?: XOR<GameCreateWithoutFavouritedByInput, GameUncheckedCreateWithoutFavouritedByInput> | GameCreateWithoutFavouritedByInput[] | GameUncheckedCreateWithoutFavouritedByInput[]
    connectOrCreate?: GameCreateOrConnectWithoutFavouritedByInput | GameCreateOrConnectWithoutFavouritedByInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type FriendshipCreateNestedManyWithoutSenderInput = {
    create?: XOR<FriendshipCreateWithoutSenderInput, FriendshipUncheckedCreateWithoutSenderInput> | FriendshipCreateWithoutSenderInput[] | FriendshipUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutSenderInput | FriendshipCreateOrConnectWithoutSenderInput[]
    createMany?: FriendshipCreateManySenderInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type FriendshipCreateNestedManyWithoutReceiverInput = {
    create?: XOR<FriendshipCreateWithoutReceiverInput, FriendshipUncheckedCreateWithoutReceiverInput> | FriendshipCreateWithoutReceiverInput[] | FriendshipUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutReceiverInput | FriendshipCreateOrConnectWithoutReceiverInput[]
    createMany?: FriendshipCreateManyReceiverInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type UserGroupCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserGroupCreateWithoutUsersInput, UserGroupUncheckedCreateWithoutUsersInput> | UserGroupCreateWithoutUsersInput[] | UserGroupUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutUsersInput | UserGroupCreateOrConnectWithoutUsersInput[]
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReviewUserTagCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewUserTagCreateWithoutUserInput, ReviewUserTagUncheckedCreateWithoutUserInput> | ReviewUserTagCreateWithoutUserInput[] | ReviewUserTagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewUserTagCreateOrConnectWithoutUserInput | ReviewUserTagCreateOrConnectWithoutUserInput[]
    createMany?: ReviewUserTagCreateManyUserInputEnvelope
    connect?: ReviewUserTagWhereUniqueInput | ReviewUserTagWhereUniqueInput[]
  }

  export type UserTagCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserTagCreateWithoutUsersInput, UserTagUncheckedCreateWithoutUsersInput> | UserTagCreateWithoutUsersInput[] | UserTagUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserTagCreateOrConnectWithoutUsersInput | UserTagCreateOrConnectWithoutUsersInput[]
    connect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
  }

  export type GameStatusCreateNestedManyWithoutUserInput = {
    create?: XOR<GameStatusCreateWithoutUserInput, GameStatusUncheckedCreateWithoutUserInput> | GameStatusCreateWithoutUserInput[] | GameStatusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameStatusCreateOrConnectWithoutUserInput | GameStatusCreateOrConnectWithoutUserInput[]
    createMany?: GameStatusCreateManyUserInputEnvelope
    connect?: GameStatusWhereUniqueInput | GameStatusWhereUniqueInput[]
  }

  export type AchievementUnlockCreateNestedManyWithoutUserInput = {
    create?: XOR<AchievementUnlockCreateWithoutUserInput, AchievementUnlockUncheckedCreateWithoutUserInput> | AchievementUnlockCreateWithoutUserInput[] | AchievementUnlockUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementUnlockCreateOrConnectWithoutUserInput | AchievementUnlockCreateOrConnectWithoutUserInput[]
    createMany?: AchievementUnlockCreateManyUserInputEnvelope
    connect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
  }

  export type ImageCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<ImageCreateWithoutUploadedByInput, ImageUncheckedCreateWithoutUploadedByInput> | ImageCreateWithoutUploadedByInput[] | ImageUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutUploadedByInput | ImageCreateOrConnectWithoutUploadedByInput[]
    createMany?: ImageCreateManyUploadedByInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type ReviewCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCommentCreateWithoutUserInput, ReviewCommentUncheckedCreateWithoutUserInput> | ReviewCommentCreateWithoutUserInput[] | ReviewCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCommentCreateOrConnectWithoutUserInput | ReviewCommentCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCommentCreateManyUserInputEnvelope
    connect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
  }

  export type GameUserCreateNestedManyWithoutUserInput = {
    create?: XOR<GameUserCreateWithoutUserInput, GameUserUncheckedCreateWithoutUserInput> | GameUserCreateWithoutUserInput[] | GameUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameUserCreateOrConnectWithoutUserInput | GameUserCreateOrConnectWithoutUserInput[]
    createMany?: GameUserCreateManyUserInputEnvelope
    connect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
  }

  export type EmailChangeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailChangeCreateWithoutUserInput, EmailChangeUncheckedCreateWithoutUserInput> | EmailChangeCreateWithoutUserInput[] | EmailChangeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailChangeCreateOrConnectWithoutUserInput | EmailChangeCreateOrConnectWithoutUserInput[]
    createMany?: EmailChangeCreateManyUserInputEnvelope
    connect?: EmailChangeWhereUniqueInput | EmailChangeWhereUniqueInput[]
  }

  export type EmailVerificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailVerificationCreateWithoutUserInput, EmailVerificationUncheckedCreateWithoutUserInput> | EmailVerificationCreateWithoutUserInput[] | EmailVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailVerificationCreateOrConnectWithoutUserInput | EmailVerificationCreateOrConnectWithoutUserInput[]
    createMany?: EmailVerificationCreateManyUserInputEnvelope
    connect?: EmailVerificationWhereUniqueInput | EmailVerificationWhereUniqueInput[]
  }

  export type PasswordResetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GameCreateWithoutUserInput, GameUncheckedCreateWithoutUserInput> | GameCreateWithoutUserInput[] | GameUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameCreateOrConnectWithoutUserInput | GameCreateOrConnectWithoutUserInput[]
    createMany?: GameCreateManyUserInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutFavouritedByInput = {
    create?: XOR<GameCreateWithoutFavouritedByInput, GameUncheckedCreateWithoutFavouritedByInput> | GameCreateWithoutFavouritedByInput[] | GameUncheckedCreateWithoutFavouritedByInput[]
    connectOrCreate?: GameCreateOrConnectWithoutFavouritedByInput | GameCreateOrConnectWithoutFavouritedByInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type FriendshipUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<FriendshipCreateWithoutSenderInput, FriendshipUncheckedCreateWithoutSenderInput> | FriendshipCreateWithoutSenderInput[] | FriendshipUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutSenderInput | FriendshipCreateOrConnectWithoutSenderInput[]
    createMany?: FriendshipCreateManySenderInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type FriendshipUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<FriendshipCreateWithoutReceiverInput, FriendshipUncheckedCreateWithoutReceiverInput> | FriendshipCreateWithoutReceiverInput[] | FriendshipUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutReceiverInput | FriendshipCreateOrConnectWithoutReceiverInput[]
    createMany?: FriendshipCreateManyReceiverInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type UserGroupUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserGroupCreateWithoutUsersInput, UserGroupUncheckedCreateWithoutUsersInput> | UserGroupCreateWithoutUsersInput[] | UserGroupUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutUsersInput | UserGroupCreateOrConnectWithoutUsersInput[]
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReviewUserTagUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewUserTagCreateWithoutUserInput, ReviewUserTagUncheckedCreateWithoutUserInput> | ReviewUserTagCreateWithoutUserInput[] | ReviewUserTagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewUserTagCreateOrConnectWithoutUserInput | ReviewUserTagCreateOrConnectWithoutUserInput[]
    createMany?: ReviewUserTagCreateManyUserInputEnvelope
    connect?: ReviewUserTagWhereUniqueInput | ReviewUserTagWhereUniqueInput[]
  }

  export type UserTagUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserTagCreateWithoutUsersInput, UserTagUncheckedCreateWithoutUsersInput> | UserTagCreateWithoutUsersInput[] | UserTagUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserTagCreateOrConnectWithoutUsersInput | UserTagCreateOrConnectWithoutUsersInput[]
    connect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
  }

  export type GameStatusUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GameStatusCreateWithoutUserInput, GameStatusUncheckedCreateWithoutUserInput> | GameStatusCreateWithoutUserInput[] | GameStatusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameStatusCreateOrConnectWithoutUserInput | GameStatusCreateOrConnectWithoutUserInput[]
    createMany?: GameStatusCreateManyUserInputEnvelope
    connect?: GameStatusWhereUniqueInput | GameStatusWhereUniqueInput[]
  }

  export type AchievementUnlockUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AchievementUnlockCreateWithoutUserInput, AchievementUnlockUncheckedCreateWithoutUserInput> | AchievementUnlockCreateWithoutUserInput[] | AchievementUnlockUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementUnlockCreateOrConnectWithoutUserInput | AchievementUnlockCreateOrConnectWithoutUserInput[]
    createMany?: AchievementUnlockCreateManyUserInputEnvelope
    connect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
  }

  export type ImageUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<ImageCreateWithoutUploadedByInput, ImageUncheckedCreateWithoutUploadedByInput> | ImageCreateWithoutUploadedByInput[] | ImageUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutUploadedByInput | ImageCreateOrConnectWithoutUploadedByInput[]
    createMany?: ImageCreateManyUploadedByInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type ReviewCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCommentCreateWithoutUserInput, ReviewCommentUncheckedCreateWithoutUserInput> | ReviewCommentCreateWithoutUserInput[] | ReviewCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCommentCreateOrConnectWithoutUserInput | ReviewCommentCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCommentCreateManyUserInputEnvelope
    connect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
  }

  export type GameUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GameUserCreateWithoutUserInput, GameUserUncheckedCreateWithoutUserInput> | GameUserCreateWithoutUserInput[] | GameUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameUserCreateOrConnectWithoutUserInput | GameUserCreateOrConnectWithoutUserInput[]
    createMany?: GameUserCreateManyUserInputEnvelope
    connect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ImageUpdateOneWithoutUserNestedInput = {
    create?: XOR<ImageCreateWithoutUserInput, ImageUncheckedCreateWithoutUserInput>
    connectOrCreate?: ImageCreateOrConnectWithoutUserInput
    upsert?: ImageUpsertWithoutUserInput
    disconnect?: ImageWhereInput | boolean
    delete?: ImageWhereInput | boolean
    connect?: ImageWhereUniqueInput
    update?: XOR<XOR<ImageUpdateToOneWithWhereWithoutUserInput, ImageUpdateWithoutUserInput>, ImageUncheckedUpdateWithoutUserInput>
  }

  export type EmailChangeUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailChangeCreateWithoutUserInput, EmailChangeUncheckedCreateWithoutUserInput> | EmailChangeCreateWithoutUserInput[] | EmailChangeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailChangeCreateOrConnectWithoutUserInput | EmailChangeCreateOrConnectWithoutUserInput[]
    upsert?: EmailChangeUpsertWithWhereUniqueWithoutUserInput | EmailChangeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailChangeCreateManyUserInputEnvelope
    set?: EmailChangeWhereUniqueInput | EmailChangeWhereUniqueInput[]
    disconnect?: EmailChangeWhereUniqueInput | EmailChangeWhereUniqueInput[]
    delete?: EmailChangeWhereUniqueInput | EmailChangeWhereUniqueInput[]
    connect?: EmailChangeWhereUniqueInput | EmailChangeWhereUniqueInput[]
    update?: EmailChangeUpdateWithWhereUniqueWithoutUserInput | EmailChangeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailChangeUpdateManyWithWhereWithoutUserInput | EmailChangeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailChangeScalarWhereInput | EmailChangeScalarWhereInput[]
  }

  export type EmailVerificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailVerificationCreateWithoutUserInput, EmailVerificationUncheckedCreateWithoutUserInput> | EmailVerificationCreateWithoutUserInput[] | EmailVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailVerificationCreateOrConnectWithoutUserInput | EmailVerificationCreateOrConnectWithoutUserInput[]
    upsert?: EmailVerificationUpsertWithWhereUniqueWithoutUserInput | EmailVerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailVerificationCreateManyUserInputEnvelope
    set?: EmailVerificationWhereUniqueInput | EmailVerificationWhereUniqueInput[]
    disconnect?: EmailVerificationWhereUniqueInput | EmailVerificationWhereUniqueInput[]
    delete?: EmailVerificationWhereUniqueInput | EmailVerificationWhereUniqueInput[]
    connect?: EmailVerificationWhereUniqueInput | EmailVerificationWhereUniqueInput[]
    update?: EmailVerificationUpdateWithWhereUniqueWithoutUserInput | EmailVerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailVerificationUpdateManyWithWhereWithoutUserInput | EmailVerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailVerificationScalarWhereInput | EmailVerificationScalarWhereInput[]
  }

  export type PasswordResetUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetUpsertWithWhereUniqueWithoutUserInput | PasswordResetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    set?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    disconnect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    delete?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    update?: PasswordResetUpdateWithWhereUniqueWithoutUserInput | PasswordResetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetUpdateManyWithWhereWithoutUserInput | PasswordResetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
  }

  export type GameUpdateManyWithoutUserNestedInput = {
    create?: XOR<GameCreateWithoutUserInput, GameUncheckedCreateWithoutUserInput> | GameCreateWithoutUserInput[] | GameUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameCreateOrConnectWithoutUserInput | GameCreateOrConnectWithoutUserInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutUserInput | GameUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GameCreateManyUserInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutUserInput | GameUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GameUpdateManyWithWhereWithoutUserInput | GameUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type GameUpdateManyWithoutFavouritedByNestedInput = {
    create?: XOR<GameCreateWithoutFavouritedByInput, GameUncheckedCreateWithoutFavouritedByInput> | GameCreateWithoutFavouritedByInput[] | GameUncheckedCreateWithoutFavouritedByInput[]
    connectOrCreate?: GameCreateOrConnectWithoutFavouritedByInput | GameCreateOrConnectWithoutFavouritedByInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutFavouritedByInput | GameUpsertWithWhereUniqueWithoutFavouritedByInput[]
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutFavouritedByInput | GameUpdateWithWhereUniqueWithoutFavouritedByInput[]
    updateMany?: GameUpdateManyWithWhereWithoutFavouritedByInput | GameUpdateManyWithWhereWithoutFavouritedByInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type FriendshipUpdateManyWithoutSenderNestedInput = {
    create?: XOR<FriendshipCreateWithoutSenderInput, FriendshipUncheckedCreateWithoutSenderInput> | FriendshipCreateWithoutSenderInput[] | FriendshipUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutSenderInput | FriendshipCreateOrConnectWithoutSenderInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutSenderInput | FriendshipUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: FriendshipCreateManySenderInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutSenderInput | FriendshipUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutSenderInput | FriendshipUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type FriendshipUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<FriendshipCreateWithoutReceiverInput, FriendshipUncheckedCreateWithoutReceiverInput> | FriendshipCreateWithoutReceiverInput[] | FriendshipUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutReceiverInput | FriendshipCreateOrConnectWithoutReceiverInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutReceiverInput | FriendshipUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: FriendshipCreateManyReceiverInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutReceiverInput | FriendshipUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutReceiverInput | FriendshipUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type UserGroupUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserGroupCreateWithoutUsersInput, UserGroupUncheckedCreateWithoutUsersInput> | UserGroupCreateWithoutUsersInput[] | UserGroupUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutUsersInput | UserGroupCreateOrConnectWithoutUsersInput[]
    upsert?: UserGroupUpsertWithWhereUniqueWithoutUsersInput | UserGroupUpsertWithWhereUniqueWithoutUsersInput[]
    set?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    disconnect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    delete?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    update?: UserGroupUpdateWithWhereUniqueWithoutUsersInput | UserGroupUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserGroupUpdateManyWithWhereWithoutUsersInput | UserGroupUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReviewUserTagUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewUserTagCreateWithoutUserInput, ReviewUserTagUncheckedCreateWithoutUserInput> | ReviewUserTagCreateWithoutUserInput[] | ReviewUserTagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewUserTagCreateOrConnectWithoutUserInput | ReviewUserTagCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUserTagUpsertWithWhereUniqueWithoutUserInput | ReviewUserTagUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewUserTagCreateManyUserInputEnvelope
    set?: ReviewUserTagWhereUniqueInput | ReviewUserTagWhereUniqueInput[]
    disconnect?: ReviewUserTagWhereUniqueInput | ReviewUserTagWhereUniqueInput[]
    delete?: ReviewUserTagWhereUniqueInput | ReviewUserTagWhereUniqueInput[]
    connect?: ReviewUserTagWhereUniqueInput | ReviewUserTagWhereUniqueInput[]
    update?: ReviewUserTagUpdateWithWhereUniqueWithoutUserInput | ReviewUserTagUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUserTagUpdateManyWithWhereWithoutUserInput | ReviewUserTagUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewUserTagScalarWhereInput | ReviewUserTagScalarWhereInput[]
  }

  export type UserTagUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserTagCreateWithoutUsersInput, UserTagUncheckedCreateWithoutUsersInput> | UserTagCreateWithoutUsersInput[] | UserTagUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserTagCreateOrConnectWithoutUsersInput | UserTagCreateOrConnectWithoutUsersInput[]
    upsert?: UserTagUpsertWithWhereUniqueWithoutUsersInput | UserTagUpsertWithWhereUniqueWithoutUsersInput[]
    set?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    disconnect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    delete?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    connect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    update?: UserTagUpdateWithWhereUniqueWithoutUsersInput | UserTagUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserTagUpdateManyWithWhereWithoutUsersInput | UserTagUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserTagScalarWhereInput | UserTagScalarWhereInput[]
  }

  export type GameStatusUpdateManyWithoutUserNestedInput = {
    create?: XOR<GameStatusCreateWithoutUserInput, GameStatusUncheckedCreateWithoutUserInput> | GameStatusCreateWithoutUserInput[] | GameStatusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameStatusCreateOrConnectWithoutUserInput | GameStatusCreateOrConnectWithoutUserInput[]
    upsert?: GameStatusUpsertWithWhereUniqueWithoutUserInput | GameStatusUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GameStatusCreateManyUserInputEnvelope
    set?: GameStatusWhereUniqueInput | GameStatusWhereUniqueInput[]
    disconnect?: GameStatusWhereUniqueInput | GameStatusWhereUniqueInput[]
    delete?: GameStatusWhereUniqueInput | GameStatusWhereUniqueInput[]
    connect?: GameStatusWhereUniqueInput | GameStatusWhereUniqueInput[]
    update?: GameStatusUpdateWithWhereUniqueWithoutUserInput | GameStatusUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GameStatusUpdateManyWithWhereWithoutUserInput | GameStatusUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GameStatusScalarWhereInput | GameStatusScalarWhereInput[]
  }

  export type AchievementUnlockUpdateManyWithoutUserNestedInput = {
    create?: XOR<AchievementUnlockCreateWithoutUserInput, AchievementUnlockUncheckedCreateWithoutUserInput> | AchievementUnlockCreateWithoutUserInput[] | AchievementUnlockUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementUnlockCreateOrConnectWithoutUserInput | AchievementUnlockCreateOrConnectWithoutUserInput[]
    upsert?: AchievementUnlockUpsertWithWhereUniqueWithoutUserInput | AchievementUnlockUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AchievementUnlockCreateManyUserInputEnvelope
    set?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    disconnect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    delete?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    connect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    update?: AchievementUnlockUpdateWithWhereUniqueWithoutUserInput | AchievementUnlockUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AchievementUnlockUpdateManyWithWhereWithoutUserInput | AchievementUnlockUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AchievementUnlockScalarWhereInput | AchievementUnlockScalarWhereInput[]
  }

  export type ImageUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<ImageCreateWithoutUploadedByInput, ImageUncheckedCreateWithoutUploadedByInput> | ImageCreateWithoutUploadedByInput[] | ImageUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutUploadedByInput | ImageCreateOrConnectWithoutUploadedByInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutUploadedByInput | ImageUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: ImageCreateManyUploadedByInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutUploadedByInput | ImageUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutUploadedByInput | ImageUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type ReviewCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCommentCreateWithoutUserInput, ReviewCommentUncheckedCreateWithoutUserInput> | ReviewCommentCreateWithoutUserInput[] | ReviewCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCommentCreateOrConnectWithoutUserInput | ReviewCommentCreateOrConnectWithoutUserInput[]
    upsert?: ReviewCommentUpsertWithWhereUniqueWithoutUserInput | ReviewCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCommentCreateManyUserInputEnvelope
    set?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    disconnect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    delete?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    connect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    update?: ReviewCommentUpdateWithWhereUniqueWithoutUserInput | ReviewCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewCommentUpdateManyWithWhereWithoutUserInput | ReviewCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewCommentScalarWhereInput | ReviewCommentScalarWhereInput[]
  }

  export type GameUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<GameUserCreateWithoutUserInput, GameUserUncheckedCreateWithoutUserInput> | GameUserCreateWithoutUserInput[] | GameUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameUserCreateOrConnectWithoutUserInput | GameUserCreateOrConnectWithoutUserInput[]
    upsert?: GameUserUpsertWithWhereUniqueWithoutUserInput | GameUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GameUserCreateManyUserInputEnvelope
    set?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    disconnect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    delete?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    connect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    update?: GameUserUpdateWithWhereUniqueWithoutUserInput | GameUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GameUserUpdateManyWithWhereWithoutUserInput | GameUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GameUserScalarWhereInput | GameUserScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmailChangeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailChangeCreateWithoutUserInput, EmailChangeUncheckedCreateWithoutUserInput> | EmailChangeCreateWithoutUserInput[] | EmailChangeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailChangeCreateOrConnectWithoutUserInput | EmailChangeCreateOrConnectWithoutUserInput[]
    upsert?: EmailChangeUpsertWithWhereUniqueWithoutUserInput | EmailChangeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailChangeCreateManyUserInputEnvelope
    set?: EmailChangeWhereUniqueInput | EmailChangeWhereUniqueInput[]
    disconnect?: EmailChangeWhereUniqueInput | EmailChangeWhereUniqueInput[]
    delete?: EmailChangeWhereUniqueInput | EmailChangeWhereUniqueInput[]
    connect?: EmailChangeWhereUniqueInput | EmailChangeWhereUniqueInput[]
    update?: EmailChangeUpdateWithWhereUniqueWithoutUserInput | EmailChangeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailChangeUpdateManyWithWhereWithoutUserInput | EmailChangeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailChangeScalarWhereInput | EmailChangeScalarWhereInput[]
  }

  export type EmailVerificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailVerificationCreateWithoutUserInput, EmailVerificationUncheckedCreateWithoutUserInput> | EmailVerificationCreateWithoutUserInput[] | EmailVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailVerificationCreateOrConnectWithoutUserInput | EmailVerificationCreateOrConnectWithoutUserInput[]
    upsert?: EmailVerificationUpsertWithWhereUniqueWithoutUserInput | EmailVerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailVerificationCreateManyUserInputEnvelope
    set?: EmailVerificationWhereUniqueInput | EmailVerificationWhereUniqueInput[]
    disconnect?: EmailVerificationWhereUniqueInput | EmailVerificationWhereUniqueInput[]
    delete?: EmailVerificationWhereUniqueInput | EmailVerificationWhereUniqueInput[]
    connect?: EmailVerificationWhereUniqueInput | EmailVerificationWhereUniqueInput[]
    update?: EmailVerificationUpdateWithWhereUniqueWithoutUserInput | EmailVerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailVerificationUpdateManyWithWhereWithoutUserInput | EmailVerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailVerificationScalarWhereInput | EmailVerificationScalarWhereInput[]
  }

  export type PasswordResetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetUpsertWithWhereUniqueWithoutUserInput | PasswordResetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    set?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    disconnect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    delete?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    update?: PasswordResetUpdateWithWhereUniqueWithoutUserInput | PasswordResetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetUpdateManyWithWhereWithoutUserInput | PasswordResetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GameCreateWithoutUserInput, GameUncheckedCreateWithoutUserInput> | GameCreateWithoutUserInput[] | GameUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameCreateOrConnectWithoutUserInput | GameCreateOrConnectWithoutUserInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutUserInput | GameUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GameCreateManyUserInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutUserInput | GameUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GameUpdateManyWithWhereWithoutUserInput | GameUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutFavouritedByNestedInput = {
    create?: XOR<GameCreateWithoutFavouritedByInput, GameUncheckedCreateWithoutFavouritedByInput> | GameCreateWithoutFavouritedByInput[] | GameUncheckedCreateWithoutFavouritedByInput[]
    connectOrCreate?: GameCreateOrConnectWithoutFavouritedByInput | GameCreateOrConnectWithoutFavouritedByInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutFavouritedByInput | GameUpsertWithWhereUniqueWithoutFavouritedByInput[]
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutFavouritedByInput | GameUpdateWithWhereUniqueWithoutFavouritedByInput[]
    updateMany?: GameUpdateManyWithWhereWithoutFavouritedByInput | GameUpdateManyWithWhereWithoutFavouritedByInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type FriendshipUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<FriendshipCreateWithoutSenderInput, FriendshipUncheckedCreateWithoutSenderInput> | FriendshipCreateWithoutSenderInput[] | FriendshipUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutSenderInput | FriendshipCreateOrConnectWithoutSenderInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutSenderInput | FriendshipUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: FriendshipCreateManySenderInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutSenderInput | FriendshipUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutSenderInput | FriendshipUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type FriendshipUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<FriendshipCreateWithoutReceiverInput, FriendshipUncheckedCreateWithoutReceiverInput> | FriendshipCreateWithoutReceiverInput[] | FriendshipUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutReceiverInput | FriendshipCreateOrConnectWithoutReceiverInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutReceiverInput | FriendshipUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: FriendshipCreateManyReceiverInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutReceiverInput | FriendshipUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutReceiverInput | FriendshipUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type UserGroupUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserGroupCreateWithoutUsersInput, UserGroupUncheckedCreateWithoutUsersInput> | UserGroupCreateWithoutUsersInput[] | UserGroupUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutUsersInput | UserGroupCreateOrConnectWithoutUsersInput[]
    upsert?: UserGroupUpsertWithWhereUniqueWithoutUsersInput | UserGroupUpsertWithWhereUniqueWithoutUsersInput[]
    set?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    disconnect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    delete?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    update?: UserGroupUpdateWithWhereUniqueWithoutUsersInput | UserGroupUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserGroupUpdateManyWithWhereWithoutUsersInput | UserGroupUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReviewUserTagUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewUserTagCreateWithoutUserInput, ReviewUserTagUncheckedCreateWithoutUserInput> | ReviewUserTagCreateWithoutUserInput[] | ReviewUserTagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewUserTagCreateOrConnectWithoutUserInput | ReviewUserTagCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUserTagUpsertWithWhereUniqueWithoutUserInput | ReviewUserTagUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewUserTagCreateManyUserInputEnvelope
    set?: ReviewUserTagWhereUniqueInput | ReviewUserTagWhereUniqueInput[]
    disconnect?: ReviewUserTagWhereUniqueInput | ReviewUserTagWhereUniqueInput[]
    delete?: ReviewUserTagWhereUniqueInput | ReviewUserTagWhereUniqueInput[]
    connect?: ReviewUserTagWhereUniqueInput | ReviewUserTagWhereUniqueInput[]
    update?: ReviewUserTagUpdateWithWhereUniqueWithoutUserInput | ReviewUserTagUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUserTagUpdateManyWithWhereWithoutUserInput | ReviewUserTagUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewUserTagScalarWhereInput | ReviewUserTagScalarWhereInput[]
  }

  export type UserTagUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserTagCreateWithoutUsersInput, UserTagUncheckedCreateWithoutUsersInput> | UserTagCreateWithoutUsersInput[] | UserTagUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserTagCreateOrConnectWithoutUsersInput | UserTagCreateOrConnectWithoutUsersInput[]
    upsert?: UserTagUpsertWithWhereUniqueWithoutUsersInput | UserTagUpsertWithWhereUniqueWithoutUsersInput[]
    set?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    disconnect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    delete?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    connect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    update?: UserTagUpdateWithWhereUniqueWithoutUsersInput | UserTagUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserTagUpdateManyWithWhereWithoutUsersInput | UserTagUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserTagScalarWhereInput | UserTagScalarWhereInput[]
  }

  export type GameStatusUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GameStatusCreateWithoutUserInput, GameStatusUncheckedCreateWithoutUserInput> | GameStatusCreateWithoutUserInput[] | GameStatusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameStatusCreateOrConnectWithoutUserInput | GameStatusCreateOrConnectWithoutUserInput[]
    upsert?: GameStatusUpsertWithWhereUniqueWithoutUserInput | GameStatusUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GameStatusCreateManyUserInputEnvelope
    set?: GameStatusWhereUniqueInput | GameStatusWhereUniqueInput[]
    disconnect?: GameStatusWhereUniqueInput | GameStatusWhereUniqueInput[]
    delete?: GameStatusWhereUniqueInput | GameStatusWhereUniqueInput[]
    connect?: GameStatusWhereUniqueInput | GameStatusWhereUniqueInput[]
    update?: GameStatusUpdateWithWhereUniqueWithoutUserInput | GameStatusUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GameStatusUpdateManyWithWhereWithoutUserInput | GameStatusUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GameStatusScalarWhereInput | GameStatusScalarWhereInput[]
  }

  export type AchievementUnlockUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AchievementUnlockCreateWithoutUserInput, AchievementUnlockUncheckedCreateWithoutUserInput> | AchievementUnlockCreateWithoutUserInput[] | AchievementUnlockUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementUnlockCreateOrConnectWithoutUserInput | AchievementUnlockCreateOrConnectWithoutUserInput[]
    upsert?: AchievementUnlockUpsertWithWhereUniqueWithoutUserInput | AchievementUnlockUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AchievementUnlockCreateManyUserInputEnvelope
    set?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    disconnect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    delete?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    connect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    update?: AchievementUnlockUpdateWithWhereUniqueWithoutUserInput | AchievementUnlockUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AchievementUnlockUpdateManyWithWhereWithoutUserInput | AchievementUnlockUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AchievementUnlockScalarWhereInput | AchievementUnlockScalarWhereInput[]
  }

  export type ImageUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<ImageCreateWithoutUploadedByInput, ImageUncheckedCreateWithoutUploadedByInput> | ImageCreateWithoutUploadedByInput[] | ImageUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutUploadedByInput | ImageCreateOrConnectWithoutUploadedByInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutUploadedByInput | ImageUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: ImageCreateManyUploadedByInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutUploadedByInput | ImageUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutUploadedByInput | ImageUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type ReviewCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCommentCreateWithoutUserInput, ReviewCommentUncheckedCreateWithoutUserInput> | ReviewCommentCreateWithoutUserInput[] | ReviewCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCommentCreateOrConnectWithoutUserInput | ReviewCommentCreateOrConnectWithoutUserInput[]
    upsert?: ReviewCommentUpsertWithWhereUniqueWithoutUserInput | ReviewCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCommentCreateManyUserInputEnvelope
    set?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    disconnect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    delete?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    connect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    update?: ReviewCommentUpdateWithWhereUniqueWithoutUserInput | ReviewCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewCommentUpdateManyWithWhereWithoutUserInput | ReviewCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewCommentScalarWhereInput | ReviewCommentScalarWhereInput[]
  }

  export type GameUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GameUserCreateWithoutUserInput, GameUserUncheckedCreateWithoutUserInput> | GameUserCreateWithoutUserInput[] | GameUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameUserCreateOrConnectWithoutUserInput | GameUserCreateOrConnectWithoutUserInput[]
    upsert?: GameUserUpsertWithWhereUniqueWithoutUserInput | GameUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GameUserCreateManyUserInputEnvelope
    set?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    disconnect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    delete?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    connect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    update?: GameUserUpdateWithWhereUniqueWithoutUserInput | GameUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GameUserUpdateManyWithWhereWithoutUserInput | GameUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GameUserScalarWhereInput | GameUserScalarWhereInput[]
  }

  export type ImageCreateNestedOneWithoutGamesInput = {
    create?: XOR<ImageCreateWithoutGamesInput, ImageUncheckedCreateWithoutGamesInput>
    connectOrCreate?: ImageCreateOrConnectWithoutGamesInput
    connect?: ImageWhereUniqueInput
  }

  export type ReviewCreateNestedManyWithoutGameInput = {
    create?: XOR<ReviewCreateWithoutGameInput, ReviewUncheckedCreateWithoutGameInput> | ReviewCreateWithoutGameInput[] | ReviewUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutGameInput | ReviewCreateOrConnectWithoutGameInput[]
    createMany?: ReviewCreateManyGameInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type GameUserCreateNestedManyWithoutGameInput = {
    create?: XOR<GameUserCreateWithoutGameInput, GameUserUncheckedCreateWithoutGameInput> | GameUserCreateWithoutGameInput[] | GameUserUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameUserCreateOrConnectWithoutGameInput | GameUserCreateOrConnectWithoutGameInput[]
    createMany?: GameUserCreateManyGameInputEnvelope
    connect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutFavouritesInput = {
    create?: XOR<UserCreateWithoutFavouritesInput, UserUncheckedCreateWithoutFavouritesInput> | UserCreateWithoutFavouritesInput[] | UserUncheckedCreateWithoutFavouritesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutFavouritesInput | UserCreateOrConnectWithoutFavouritesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type GenreCreateNestedManyWithoutGamesInput = {
    create?: XOR<GenreCreateWithoutGamesInput, GenreUncheckedCreateWithoutGamesInput> | GenreCreateWithoutGamesInput[] | GenreUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: GenreCreateOrConnectWithoutGamesInput | GenreCreateOrConnectWithoutGamesInput[]
    connect?: GenreWhereUniqueInput | GenreWhereUniqueInput[]
  }

  export type PlatformCreateNestedManyWithoutGamesInput = {
    create?: XOR<PlatformCreateWithoutGamesInput, PlatformUncheckedCreateWithoutGamesInput> | PlatformCreateWithoutGamesInput[] | PlatformUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: PlatformCreateOrConnectWithoutGamesInput | PlatformCreateOrConnectWithoutGamesInput[]
    connect?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
  }

  export type GameTagCreateNestedManyWithoutGamesInput = {
    create?: XOR<GameTagCreateWithoutGamesInput, GameTagUncheckedCreateWithoutGamesInput> | GameTagCreateWithoutGamesInput[] | GameTagUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: GameTagCreateOrConnectWithoutGamesInput | GameTagCreateOrConnectWithoutGamesInput[]
    connect?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
  }

  export type GameStatusCreateNestedManyWithoutGamesInput = {
    create?: XOR<GameStatusCreateWithoutGamesInput, GameStatusUncheckedCreateWithoutGamesInput> | GameStatusCreateWithoutGamesInput[] | GameStatusUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: GameStatusCreateOrConnectWithoutGamesInput | GameStatusCreateOrConnectWithoutGamesInput[]
    connect?: GameStatusWhereUniqueInput | GameStatusWhereUniqueInput[]
  }

  export type DeveloperCreateNestedManyWithoutGamesInput = {
    create?: XOR<DeveloperCreateWithoutGamesInput, DeveloperUncheckedCreateWithoutGamesInput> | DeveloperCreateWithoutGamesInput[] | DeveloperUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: DeveloperCreateOrConnectWithoutGamesInput | DeveloperCreateOrConnectWithoutGamesInput[]
    connect?: DeveloperWhereUniqueInput | DeveloperWhereUniqueInput[]
  }

  export type PublisherCreateNestedManyWithoutGamesInput = {
    create?: XOR<PublisherCreateWithoutGamesInput, PublisherUncheckedCreateWithoutGamesInput> | PublisherCreateWithoutGamesInput[] | PublisherUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: PublisherCreateOrConnectWithoutGamesInput | PublisherCreateOrConnectWithoutGamesInput[]
    connect?: PublisherWhereUniqueInput | PublisherWhereUniqueInput[]
  }

  export type GameImageCreateNestedManyWithoutGameInput = {
    create?: XOR<GameImageCreateWithoutGameInput, GameImageUncheckedCreateWithoutGameInput> | GameImageCreateWithoutGameInput[] | GameImageUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameImageCreateOrConnectWithoutGameInput | GameImageCreateOrConnectWithoutGameInput[]
    createMany?: GameImageCreateManyGameInputEnvelope
    connect?: GameImageWhereUniqueInput | GameImageWhereUniqueInput[]
  }

  export type AchievementCreateNestedManyWithoutGameInput = {
    create?: XOR<AchievementCreateWithoutGameInput, AchievementUncheckedCreateWithoutGameInput> | AchievementCreateWithoutGameInput[] | AchievementUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutGameInput | AchievementCreateOrConnectWithoutGameInput[]
    createMany?: AchievementCreateManyGameInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutPlayedGamesInput = {
    create?: XOR<UserCreateWithoutPlayedGamesInput, UserUncheckedCreateWithoutPlayedGamesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayedGamesInput
    connect?: UserWhereUniqueInput
  }

  export type ReviewUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<ReviewCreateWithoutGameInput, ReviewUncheckedCreateWithoutGameInput> | ReviewCreateWithoutGameInput[] | ReviewUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutGameInput | ReviewCreateOrConnectWithoutGameInput[]
    createMany?: ReviewCreateManyGameInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type GameUserUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<GameUserCreateWithoutGameInput, GameUserUncheckedCreateWithoutGameInput> | GameUserCreateWithoutGameInput[] | GameUserUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameUserCreateOrConnectWithoutGameInput | GameUserCreateOrConnectWithoutGameInput[]
    createMany?: GameUserCreateManyGameInputEnvelope
    connect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutFavouritesInput = {
    create?: XOR<UserCreateWithoutFavouritesInput, UserUncheckedCreateWithoutFavouritesInput> | UserCreateWithoutFavouritesInput[] | UserUncheckedCreateWithoutFavouritesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutFavouritesInput | UserCreateOrConnectWithoutFavouritesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type GenreUncheckedCreateNestedManyWithoutGamesInput = {
    create?: XOR<GenreCreateWithoutGamesInput, GenreUncheckedCreateWithoutGamesInput> | GenreCreateWithoutGamesInput[] | GenreUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: GenreCreateOrConnectWithoutGamesInput | GenreCreateOrConnectWithoutGamesInput[]
    connect?: GenreWhereUniqueInput | GenreWhereUniqueInput[]
  }

  export type PlatformUncheckedCreateNestedManyWithoutGamesInput = {
    create?: XOR<PlatformCreateWithoutGamesInput, PlatformUncheckedCreateWithoutGamesInput> | PlatformCreateWithoutGamesInput[] | PlatformUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: PlatformCreateOrConnectWithoutGamesInput | PlatformCreateOrConnectWithoutGamesInput[]
    connect?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
  }

  export type GameTagUncheckedCreateNestedManyWithoutGamesInput = {
    create?: XOR<GameTagCreateWithoutGamesInput, GameTagUncheckedCreateWithoutGamesInput> | GameTagCreateWithoutGamesInput[] | GameTagUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: GameTagCreateOrConnectWithoutGamesInput | GameTagCreateOrConnectWithoutGamesInput[]
    connect?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
  }

  export type GameStatusUncheckedCreateNestedManyWithoutGamesInput = {
    create?: XOR<GameStatusCreateWithoutGamesInput, GameStatusUncheckedCreateWithoutGamesInput> | GameStatusCreateWithoutGamesInput[] | GameStatusUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: GameStatusCreateOrConnectWithoutGamesInput | GameStatusCreateOrConnectWithoutGamesInput[]
    connect?: GameStatusWhereUniqueInput | GameStatusWhereUniqueInput[]
  }

  export type DeveloperUncheckedCreateNestedManyWithoutGamesInput = {
    create?: XOR<DeveloperCreateWithoutGamesInput, DeveloperUncheckedCreateWithoutGamesInput> | DeveloperCreateWithoutGamesInput[] | DeveloperUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: DeveloperCreateOrConnectWithoutGamesInput | DeveloperCreateOrConnectWithoutGamesInput[]
    connect?: DeveloperWhereUniqueInput | DeveloperWhereUniqueInput[]
  }

  export type PublisherUncheckedCreateNestedManyWithoutGamesInput = {
    create?: XOR<PublisherCreateWithoutGamesInput, PublisherUncheckedCreateWithoutGamesInput> | PublisherCreateWithoutGamesInput[] | PublisherUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: PublisherCreateOrConnectWithoutGamesInput | PublisherCreateOrConnectWithoutGamesInput[]
    connect?: PublisherWhereUniqueInput | PublisherWhereUniqueInput[]
  }

  export type GameImageUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<GameImageCreateWithoutGameInput, GameImageUncheckedCreateWithoutGameInput> | GameImageCreateWithoutGameInput[] | GameImageUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameImageCreateOrConnectWithoutGameInput | GameImageCreateOrConnectWithoutGameInput[]
    createMany?: GameImageCreateManyGameInputEnvelope
    connect?: GameImageWhereUniqueInput | GameImageWhereUniqueInput[]
  }

  export type AchievementUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<AchievementCreateWithoutGameInput, AchievementUncheckedCreateWithoutGameInput> | AchievementCreateWithoutGameInput[] | AchievementUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutGameInput | AchievementCreateOrConnectWithoutGameInput[]
    createMany?: AchievementCreateManyGameInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type ImageUpdateOneWithoutGamesNestedInput = {
    create?: XOR<ImageCreateWithoutGamesInput, ImageUncheckedCreateWithoutGamesInput>
    connectOrCreate?: ImageCreateOrConnectWithoutGamesInput
    upsert?: ImageUpsertWithoutGamesInput
    disconnect?: ImageWhereInput | boolean
    delete?: ImageWhereInput | boolean
    connect?: ImageWhereUniqueInput
    update?: XOR<XOR<ImageUpdateToOneWithWhereWithoutGamesInput, ImageUpdateWithoutGamesInput>, ImageUncheckedUpdateWithoutGamesInput>
  }

  export type ReviewUpdateManyWithoutGameNestedInput = {
    create?: XOR<ReviewCreateWithoutGameInput, ReviewUncheckedCreateWithoutGameInput> | ReviewCreateWithoutGameInput[] | ReviewUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutGameInput | ReviewCreateOrConnectWithoutGameInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutGameInput | ReviewUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: ReviewCreateManyGameInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutGameInput | ReviewUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutGameInput | ReviewUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type GameUserUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameUserCreateWithoutGameInput, GameUserUncheckedCreateWithoutGameInput> | GameUserCreateWithoutGameInput[] | GameUserUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameUserCreateOrConnectWithoutGameInput | GameUserCreateOrConnectWithoutGameInput[]
    upsert?: GameUserUpsertWithWhereUniqueWithoutGameInput | GameUserUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameUserCreateManyGameInputEnvelope
    set?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    disconnect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    delete?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    connect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    update?: GameUserUpdateWithWhereUniqueWithoutGameInput | GameUserUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameUserUpdateManyWithWhereWithoutGameInput | GameUserUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameUserScalarWhereInput | GameUserScalarWhereInput[]
  }

  export type UserUpdateManyWithoutFavouritesNestedInput = {
    create?: XOR<UserCreateWithoutFavouritesInput, UserUncheckedCreateWithoutFavouritesInput> | UserCreateWithoutFavouritesInput[] | UserUncheckedCreateWithoutFavouritesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutFavouritesInput | UserCreateOrConnectWithoutFavouritesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutFavouritesInput | UserUpsertWithWhereUniqueWithoutFavouritesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutFavouritesInput | UserUpdateWithWhereUniqueWithoutFavouritesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutFavouritesInput | UserUpdateManyWithWhereWithoutFavouritesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type GenreUpdateManyWithoutGamesNestedInput = {
    create?: XOR<GenreCreateWithoutGamesInput, GenreUncheckedCreateWithoutGamesInput> | GenreCreateWithoutGamesInput[] | GenreUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: GenreCreateOrConnectWithoutGamesInput | GenreCreateOrConnectWithoutGamesInput[]
    upsert?: GenreUpsertWithWhereUniqueWithoutGamesInput | GenreUpsertWithWhereUniqueWithoutGamesInput[]
    set?: GenreWhereUniqueInput | GenreWhereUniqueInput[]
    disconnect?: GenreWhereUniqueInput | GenreWhereUniqueInput[]
    delete?: GenreWhereUniqueInput | GenreWhereUniqueInput[]
    connect?: GenreWhereUniqueInput | GenreWhereUniqueInput[]
    update?: GenreUpdateWithWhereUniqueWithoutGamesInput | GenreUpdateWithWhereUniqueWithoutGamesInput[]
    updateMany?: GenreUpdateManyWithWhereWithoutGamesInput | GenreUpdateManyWithWhereWithoutGamesInput[]
    deleteMany?: GenreScalarWhereInput | GenreScalarWhereInput[]
  }

  export type PlatformUpdateManyWithoutGamesNestedInput = {
    create?: XOR<PlatformCreateWithoutGamesInput, PlatformUncheckedCreateWithoutGamesInput> | PlatformCreateWithoutGamesInput[] | PlatformUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: PlatformCreateOrConnectWithoutGamesInput | PlatformCreateOrConnectWithoutGamesInput[]
    upsert?: PlatformUpsertWithWhereUniqueWithoutGamesInput | PlatformUpsertWithWhereUniqueWithoutGamesInput[]
    set?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    disconnect?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    delete?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    connect?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    update?: PlatformUpdateWithWhereUniqueWithoutGamesInput | PlatformUpdateWithWhereUniqueWithoutGamesInput[]
    updateMany?: PlatformUpdateManyWithWhereWithoutGamesInput | PlatformUpdateManyWithWhereWithoutGamesInput[]
    deleteMany?: PlatformScalarWhereInput | PlatformScalarWhereInput[]
  }

  export type GameTagUpdateManyWithoutGamesNestedInput = {
    create?: XOR<GameTagCreateWithoutGamesInput, GameTagUncheckedCreateWithoutGamesInput> | GameTagCreateWithoutGamesInput[] | GameTagUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: GameTagCreateOrConnectWithoutGamesInput | GameTagCreateOrConnectWithoutGamesInput[]
    upsert?: GameTagUpsertWithWhereUniqueWithoutGamesInput | GameTagUpsertWithWhereUniqueWithoutGamesInput[]
    set?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    disconnect?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    delete?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    connect?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    update?: GameTagUpdateWithWhereUniqueWithoutGamesInput | GameTagUpdateWithWhereUniqueWithoutGamesInput[]
    updateMany?: GameTagUpdateManyWithWhereWithoutGamesInput | GameTagUpdateManyWithWhereWithoutGamesInput[]
    deleteMany?: GameTagScalarWhereInput | GameTagScalarWhereInput[]
  }

  export type GameStatusUpdateManyWithoutGamesNestedInput = {
    create?: XOR<GameStatusCreateWithoutGamesInput, GameStatusUncheckedCreateWithoutGamesInput> | GameStatusCreateWithoutGamesInput[] | GameStatusUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: GameStatusCreateOrConnectWithoutGamesInput | GameStatusCreateOrConnectWithoutGamesInput[]
    upsert?: GameStatusUpsertWithWhereUniqueWithoutGamesInput | GameStatusUpsertWithWhereUniqueWithoutGamesInput[]
    set?: GameStatusWhereUniqueInput | GameStatusWhereUniqueInput[]
    disconnect?: GameStatusWhereUniqueInput | GameStatusWhereUniqueInput[]
    delete?: GameStatusWhereUniqueInput | GameStatusWhereUniqueInput[]
    connect?: GameStatusWhereUniqueInput | GameStatusWhereUniqueInput[]
    update?: GameStatusUpdateWithWhereUniqueWithoutGamesInput | GameStatusUpdateWithWhereUniqueWithoutGamesInput[]
    updateMany?: GameStatusUpdateManyWithWhereWithoutGamesInput | GameStatusUpdateManyWithWhereWithoutGamesInput[]
    deleteMany?: GameStatusScalarWhereInput | GameStatusScalarWhereInput[]
  }

  export type DeveloperUpdateManyWithoutGamesNestedInput = {
    create?: XOR<DeveloperCreateWithoutGamesInput, DeveloperUncheckedCreateWithoutGamesInput> | DeveloperCreateWithoutGamesInput[] | DeveloperUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: DeveloperCreateOrConnectWithoutGamesInput | DeveloperCreateOrConnectWithoutGamesInput[]
    upsert?: DeveloperUpsertWithWhereUniqueWithoutGamesInput | DeveloperUpsertWithWhereUniqueWithoutGamesInput[]
    set?: DeveloperWhereUniqueInput | DeveloperWhereUniqueInput[]
    disconnect?: DeveloperWhereUniqueInput | DeveloperWhereUniqueInput[]
    delete?: DeveloperWhereUniqueInput | DeveloperWhereUniqueInput[]
    connect?: DeveloperWhereUniqueInput | DeveloperWhereUniqueInput[]
    update?: DeveloperUpdateWithWhereUniqueWithoutGamesInput | DeveloperUpdateWithWhereUniqueWithoutGamesInput[]
    updateMany?: DeveloperUpdateManyWithWhereWithoutGamesInput | DeveloperUpdateManyWithWhereWithoutGamesInput[]
    deleteMany?: DeveloperScalarWhereInput | DeveloperScalarWhereInput[]
  }

  export type PublisherUpdateManyWithoutGamesNestedInput = {
    create?: XOR<PublisherCreateWithoutGamesInput, PublisherUncheckedCreateWithoutGamesInput> | PublisherCreateWithoutGamesInput[] | PublisherUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: PublisherCreateOrConnectWithoutGamesInput | PublisherCreateOrConnectWithoutGamesInput[]
    upsert?: PublisherUpsertWithWhereUniqueWithoutGamesInput | PublisherUpsertWithWhereUniqueWithoutGamesInput[]
    set?: PublisherWhereUniqueInput | PublisherWhereUniqueInput[]
    disconnect?: PublisherWhereUniqueInput | PublisherWhereUniqueInput[]
    delete?: PublisherWhereUniqueInput | PublisherWhereUniqueInput[]
    connect?: PublisherWhereUniqueInput | PublisherWhereUniqueInput[]
    update?: PublisherUpdateWithWhereUniqueWithoutGamesInput | PublisherUpdateWithWhereUniqueWithoutGamesInput[]
    updateMany?: PublisherUpdateManyWithWhereWithoutGamesInput | PublisherUpdateManyWithWhereWithoutGamesInput[]
    deleteMany?: PublisherScalarWhereInput | PublisherScalarWhereInput[]
  }

  export type GameImageUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameImageCreateWithoutGameInput, GameImageUncheckedCreateWithoutGameInput> | GameImageCreateWithoutGameInput[] | GameImageUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameImageCreateOrConnectWithoutGameInput | GameImageCreateOrConnectWithoutGameInput[]
    upsert?: GameImageUpsertWithWhereUniqueWithoutGameInput | GameImageUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameImageCreateManyGameInputEnvelope
    set?: GameImageWhereUniqueInput | GameImageWhereUniqueInput[]
    disconnect?: GameImageWhereUniqueInput | GameImageWhereUniqueInput[]
    delete?: GameImageWhereUniqueInput | GameImageWhereUniqueInput[]
    connect?: GameImageWhereUniqueInput | GameImageWhereUniqueInput[]
    update?: GameImageUpdateWithWhereUniqueWithoutGameInput | GameImageUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameImageUpdateManyWithWhereWithoutGameInput | GameImageUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameImageScalarWhereInput | GameImageScalarWhereInput[]
  }

  export type AchievementUpdateManyWithoutGameNestedInput = {
    create?: XOR<AchievementCreateWithoutGameInput, AchievementUncheckedCreateWithoutGameInput> | AchievementCreateWithoutGameInput[] | AchievementUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutGameInput | AchievementCreateOrConnectWithoutGameInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutGameInput | AchievementUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: AchievementCreateManyGameInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutGameInput | AchievementUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutGameInput | AchievementUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type UserUpdateOneWithoutPlayedGamesNestedInput = {
    create?: XOR<UserCreateWithoutPlayedGamesInput, UserUncheckedCreateWithoutPlayedGamesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayedGamesInput
    upsert?: UserUpsertWithoutPlayedGamesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlayedGamesInput, UserUpdateWithoutPlayedGamesInput>, UserUncheckedUpdateWithoutPlayedGamesInput>
  }

  export type ReviewUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<ReviewCreateWithoutGameInput, ReviewUncheckedCreateWithoutGameInput> | ReviewCreateWithoutGameInput[] | ReviewUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutGameInput | ReviewCreateOrConnectWithoutGameInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutGameInput | ReviewUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: ReviewCreateManyGameInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutGameInput | ReviewUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutGameInput | ReviewUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type GameUserUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameUserCreateWithoutGameInput, GameUserUncheckedCreateWithoutGameInput> | GameUserCreateWithoutGameInput[] | GameUserUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameUserCreateOrConnectWithoutGameInput | GameUserCreateOrConnectWithoutGameInput[]
    upsert?: GameUserUpsertWithWhereUniqueWithoutGameInput | GameUserUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameUserCreateManyGameInputEnvelope
    set?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    disconnect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    delete?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    connect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    update?: GameUserUpdateWithWhereUniqueWithoutGameInput | GameUserUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameUserUpdateManyWithWhereWithoutGameInput | GameUserUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameUserScalarWhereInput | GameUserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutFavouritesNestedInput = {
    create?: XOR<UserCreateWithoutFavouritesInput, UserUncheckedCreateWithoutFavouritesInput> | UserCreateWithoutFavouritesInput[] | UserUncheckedCreateWithoutFavouritesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutFavouritesInput | UserCreateOrConnectWithoutFavouritesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutFavouritesInput | UserUpsertWithWhereUniqueWithoutFavouritesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutFavouritesInput | UserUpdateWithWhereUniqueWithoutFavouritesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutFavouritesInput | UserUpdateManyWithWhereWithoutFavouritesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type GenreUncheckedUpdateManyWithoutGamesNestedInput = {
    create?: XOR<GenreCreateWithoutGamesInput, GenreUncheckedCreateWithoutGamesInput> | GenreCreateWithoutGamesInput[] | GenreUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: GenreCreateOrConnectWithoutGamesInput | GenreCreateOrConnectWithoutGamesInput[]
    upsert?: GenreUpsertWithWhereUniqueWithoutGamesInput | GenreUpsertWithWhereUniqueWithoutGamesInput[]
    set?: GenreWhereUniqueInput | GenreWhereUniqueInput[]
    disconnect?: GenreWhereUniqueInput | GenreWhereUniqueInput[]
    delete?: GenreWhereUniqueInput | GenreWhereUniqueInput[]
    connect?: GenreWhereUniqueInput | GenreWhereUniqueInput[]
    update?: GenreUpdateWithWhereUniqueWithoutGamesInput | GenreUpdateWithWhereUniqueWithoutGamesInput[]
    updateMany?: GenreUpdateManyWithWhereWithoutGamesInput | GenreUpdateManyWithWhereWithoutGamesInput[]
    deleteMany?: GenreScalarWhereInput | GenreScalarWhereInput[]
  }

  export type PlatformUncheckedUpdateManyWithoutGamesNestedInput = {
    create?: XOR<PlatformCreateWithoutGamesInput, PlatformUncheckedCreateWithoutGamesInput> | PlatformCreateWithoutGamesInput[] | PlatformUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: PlatformCreateOrConnectWithoutGamesInput | PlatformCreateOrConnectWithoutGamesInput[]
    upsert?: PlatformUpsertWithWhereUniqueWithoutGamesInput | PlatformUpsertWithWhereUniqueWithoutGamesInput[]
    set?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    disconnect?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    delete?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    connect?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    update?: PlatformUpdateWithWhereUniqueWithoutGamesInput | PlatformUpdateWithWhereUniqueWithoutGamesInput[]
    updateMany?: PlatformUpdateManyWithWhereWithoutGamesInput | PlatformUpdateManyWithWhereWithoutGamesInput[]
    deleteMany?: PlatformScalarWhereInput | PlatformScalarWhereInput[]
  }

  export type GameTagUncheckedUpdateManyWithoutGamesNestedInput = {
    create?: XOR<GameTagCreateWithoutGamesInput, GameTagUncheckedCreateWithoutGamesInput> | GameTagCreateWithoutGamesInput[] | GameTagUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: GameTagCreateOrConnectWithoutGamesInput | GameTagCreateOrConnectWithoutGamesInput[]
    upsert?: GameTagUpsertWithWhereUniqueWithoutGamesInput | GameTagUpsertWithWhereUniqueWithoutGamesInput[]
    set?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    disconnect?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    delete?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    connect?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    update?: GameTagUpdateWithWhereUniqueWithoutGamesInput | GameTagUpdateWithWhereUniqueWithoutGamesInput[]
    updateMany?: GameTagUpdateManyWithWhereWithoutGamesInput | GameTagUpdateManyWithWhereWithoutGamesInput[]
    deleteMany?: GameTagScalarWhereInput | GameTagScalarWhereInput[]
  }

  export type GameStatusUncheckedUpdateManyWithoutGamesNestedInput = {
    create?: XOR<GameStatusCreateWithoutGamesInput, GameStatusUncheckedCreateWithoutGamesInput> | GameStatusCreateWithoutGamesInput[] | GameStatusUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: GameStatusCreateOrConnectWithoutGamesInput | GameStatusCreateOrConnectWithoutGamesInput[]
    upsert?: GameStatusUpsertWithWhereUniqueWithoutGamesInput | GameStatusUpsertWithWhereUniqueWithoutGamesInput[]
    set?: GameStatusWhereUniqueInput | GameStatusWhereUniqueInput[]
    disconnect?: GameStatusWhereUniqueInput | GameStatusWhereUniqueInput[]
    delete?: GameStatusWhereUniqueInput | GameStatusWhereUniqueInput[]
    connect?: GameStatusWhereUniqueInput | GameStatusWhereUniqueInput[]
    update?: GameStatusUpdateWithWhereUniqueWithoutGamesInput | GameStatusUpdateWithWhereUniqueWithoutGamesInput[]
    updateMany?: GameStatusUpdateManyWithWhereWithoutGamesInput | GameStatusUpdateManyWithWhereWithoutGamesInput[]
    deleteMany?: GameStatusScalarWhereInput | GameStatusScalarWhereInput[]
  }

  export type DeveloperUncheckedUpdateManyWithoutGamesNestedInput = {
    create?: XOR<DeveloperCreateWithoutGamesInput, DeveloperUncheckedCreateWithoutGamesInput> | DeveloperCreateWithoutGamesInput[] | DeveloperUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: DeveloperCreateOrConnectWithoutGamesInput | DeveloperCreateOrConnectWithoutGamesInput[]
    upsert?: DeveloperUpsertWithWhereUniqueWithoutGamesInput | DeveloperUpsertWithWhereUniqueWithoutGamesInput[]
    set?: DeveloperWhereUniqueInput | DeveloperWhereUniqueInput[]
    disconnect?: DeveloperWhereUniqueInput | DeveloperWhereUniqueInput[]
    delete?: DeveloperWhereUniqueInput | DeveloperWhereUniqueInput[]
    connect?: DeveloperWhereUniqueInput | DeveloperWhereUniqueInput[]
    update?: DeveloperUpdateWithWhereUniqueWithoutGamesInput | DeveloperUpdateWithWhereUniqueWithoutGamesInput[]
    updateMany?: DeveloperUpdateManyWithWhereWithoutGamesInput | DeveloperUpdateManyWithWhereWithoutGamesInput[]
    deleteMany?: DeveloperScalarWhereInput | DeveloperScalarWhereInput[]
  }

  export type PublisherUncheckedUpdateManyWithoutGamesNestedInput = {
    create?: XOR<PublisherCreateWithoutGamesInput, PublisherUncheckedCreateWithoutGamesInput> | PublisherCreateWithoutGamesInput[] | PublisherUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: PublisherCreateOrConnectWithoutGamesInput | PublisherCreateOrConnectWithoutGamesInput[]
    upsert?: PublisherUpsertWithWhereUniqueWithoutGamesInput | PublisherUpsertWithWhereUniqueWithoutGamesInput[]
    set?: PublisherWhereUniqueInput | PublisherWhereUniqueInput[]
    disconnect?: PublisherWhereUniqueInput | PublisherWhereUniqueInput[]
    delete?: PublisherWhereUniqueInput | PublisherWhereUniqueInput[]
    connect?: PublisherWhereUniqueInput | PublisherWhereUniqueInput[]
    update?: PublisherUpdateWithWhereUniqueWithoutGamesInput | PublisherUpdateWithWhereUniqueWithoutGamesInput[]
    updateMany?: PublisherUpdateManyWithWhereWithoutGamesInput | PublisherUpdateManyWithWhereWithoutGamesInput[]
    deleteMany?: PublisherScalarWhereInput | PublisherScalarWhereInput[]
  }

  export type GameImageUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameImageCreateWithoutGameInput, GameImageUncheckedCreateWithoutGameInput> | GameImageCreateWithoutGameInput[] | GameImageUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameImageCreateOrConnectWithoutGameInput | GameImageCreateOrConnectWithoutGameInput[]
    upsert?: GameImageUpsertWithWhereUniqueWithoutGameInput | GameImageUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameImageCreateManyGameInputEnvelope
    set?: GameImageWhereUniqueInput | GameImageWhereUniqueInput[]
    disconnect?: GameImageWhereUniqueInput | GameImageWhereUniqueInput[]
    delete?: GameImageWhereUniqueInput | GameImageWhereUniqueInput[]
    connect?: GameImageWhereUniqueInput | GameImageWhereUniqueInput[]
    update?: GameImageUpdateWithWhereUniqueWithoutGameInput | GameImageUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameImageUpdateManyWithWhereWithoutGameInput | GameImageUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameImageScalarWhereInput | GameImageScalarWhereInput[]
  }

  export type AchievementUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<AchievementCreateWithoutGameInput, AchievementUncheckedCreateWithoutGameInput> | AchievementCreateWithoutGameInput[] | AchievementUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutGameInput | AchievementCreateOrConnectWithoutGameInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutGameInput | AchievementUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: AchievementCreateManyGameInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutGameInput | AchievementUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutGameInput | AchievementUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUploadedImagesInput = {
    create?: XOR<UserCreateWithoutUploadedImagesInput, UserUncheckedCreateWithoutUploadedImagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedImagesInput
    connect?: UserWhereUniqueInput
  }

  export type GameCreateNestedManyWithoutCoverImageInput = {
    create?: XOR<GameCreateWithoutCoverImageInput, GameUncheckedCreateWithoutCoverImageInput> | GameCreateWithoutCoverImageInput[] | GameUncheckedCreateWithoutCoverImageInput[]
    connectOrCreate?: GameCreateOrConnectWithoutCoverImageInput | GameCreateOrConnectWithoutCoverImageInput[]
    createMany?: GameCreateManyCoverImageInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutProfilePictureInput = {
    create?: XOR<UserCreateWithoutProfilePictureInput, UserUncheckedCreateWithoutProfilePictureInput> | UserCreateWithoutProfilePictureInput[] | UserUncheckedCreateWithoutProfilePictureInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProfilePictureInput | UserCreateOrConnectWithoutProfilePictureInput[]
    createMany?: UserCreateManyProfilePictureInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutCoverImageInput = {
    create?: XOR<GameCreateWithoutCoverImageInput, GameUncheckedCreateWithoutCoverImageInput> | GameCreateWithoutCoverImageInput[] | GameUncheckedCreateWithoutCoverImageInput[]
    connectOrCreate?: GameCreateOrConnectWithoutCoverImageInput | GameCreateOrConnectWithoutCoverImageInput[]
    createMany?: GameCreateManyCoverImageInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutProfilePictureInput = {
    create?: XOR<UserCreateWithoutProfilePictureInput, UserUncheckedCreateWithoutProfilePictureInput> | UserCreateWithoutProfilePictureInput[] | UserUncheckedCreateWithoutProfilePictureInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProfilePictureInput | UserCreateOrConnectWithoutProfilePictureInput[]
    createMany?: UserCreateManyProfilePictureInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutUploadedImagesNestedInput = {
    create?: XOR<UserCreateWithoutUploadedImagesInput, UserUncheckedCreateWithoutUploadedImagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedImagesInput
    upsert?: UserUpsertWithoutUploadedImagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedImagesInput, UserUpdateWithoutUploadedImagesInput>, UserUncheckedUpdateWithoutUploadedImagesInput>
  }

  export type GameUpdateManyWithoutCoverImageNestedInput = {
    create?: XOR<GameCreateWithoutCoverImageInput, GameUncheckedCreateWithoutCoverImageInput> | GameCreateWithoutCoverImageInput[] | GameUncheckedCreateWithoutCoverImageInput[]
    connectOrCreate?: GameCreateOrConnectWithoutCoverImageInput | GameCreateOrConnectWithoutCoverImageInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutCoverImageInput | GameUpsertWithWhereUniqueWithoutCoverImageInput[]
    createMany?: GameCreateManyCoverImageInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutCoverImageInput | GameUpdateWithWhereUniqueWithoutCoverImageInput[]
    updateMany?: GameUpdateManyWithWhereWithoutCoverImageInput | GameUpdateManyWithWhereWithoutCoverImageInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type UserUpdateManyWithoutProfilePictureNestedInput = {
    create?: XOR<UserCreateWithoutProfilePictureInput, UserUncheckedCreateWithoutProfilePictureInput> | UserCreateWithoutProfilePictureInput[] | UserUncheckedCreateWithoutProfilePictureInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProfilePictureInput | UserCreateOrConnectWithoutProfilePictureInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProfilePictureInput | UserUpsertWithWhereUniqueWithoutProfilePictureInput[]
    createMany?: UserCreateManyProfilePictureInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProfilePictureInput | UserUpdateWithWhereUniqueWithoutProfilePictureInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProfilePictureInput | UserUpdateManyWithWhereWithoutProfilePictureInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutCoverImageNestedInput = {
    create?: XOR<GameCreateWithoutCoverImageInput, GameUncheckedCreateWithoutCoverImageInput> | GameCreateWithoutCoverImageInput[] | GameUncheckedCreateWithoutCoverImageInput[]
    connectOrCreate?: GameCreateOrConnectWithoutCoverImageInput | GameCreateOrConnectWithoutCoverImageInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutCoverImageInput | GameUpsertWithWhereUniqueWithoutCoverImageInput[]
    createMany?: GameCreateManyCoverImageInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutCoverImageInput | GameUpdateWithWhereUniqueWithoutCoverImageInput[]
    updateMany?: GameUpdateManyWithWhereWithoutCoverImageInput | GameUpdateManyWithWhereWithoutCoverImageInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutProfilePictureNestedInput = {
    create?: XOR<UserCreateWithoutProfilePictureInput, UserUncheckedCreateWithoutProfilePictureInput> | UserCreateWithoutProfilePictureInput[] | UserUncheckedCreateWithoutProfilePictureInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProfilePictureInput | UserCreateOrConnectWithoutProfilePictureInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProfilePictureInput | UserUpsertWithWhereUniqueWithoutProfilePictureInput[]
    createMany?: UserCreateManyProfilePictureInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProfilePictureInput | UserUpdateWithWhereUniqueWithoutProfilePictureInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProfilePictureInput | UserUpdateManyWithWhereWithoutProfilePictureInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutReviewsInput = {
    create?: XOR<GameCreateWithoutReviewsInput, GameUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: GameCreateOrConnectWithoutReviewsInput
    connect?: GameWhereUniqueInput
  }

  export type ReviewUserTagCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewUserTagCreateWithoutReviewInput, ReviewUserTagUncheckedCreateWithoutReviewInput> | ReviewUserTagCreateWithoutReviewInput[] | ReviewUserTagUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewUserTagCreateOrConnectWithoutReviewInput | ReviewUserTagCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewUserTagCreateManyReviewInputEnvelope
    connect?: ReviewUserTagWhereUniqueInput | ReviewUserTagWhereUniqueInput[]
  }

  export type ReviewCommentCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewCommentCreateWithoutReviewInput, ReviewCommentUncheckedCreateWithoutReviewInput> | ReviewCommentCreateWithoutReviewInput[] | ReviewCommentUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewCommentCreateOrConnectWithoutReviewInput | ReviewCommentCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewCommentCreateManyReviewInputEnvelope
    connect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
  }

  export type ReviewUserTagUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewUserTagCreateWithoutReviewInput, ReviewUserTagUncheckedCreateWithoutReviewInput> | ReviewUserTagCreateWithoutReviewInput[] | ReviewUserTagUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewUserTagCreateOrConnectWithoutReviewInput | ReviewUserTagCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewUserTagCreateManyReviewInputEnvelope
    connect?: ReviewUserTagWhereUniqueInput | ReviewUserTagWhereUniqueInput[]
  }

  export type ReviewCommentUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewCommentCreateWithoutReviewInput, ReviewCommentUncheckedCreateWithoutReviewInput> | ReviewCommentCreateWithoutReviewInput[] | ReviewCommentUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewCommentCreateOrConnectWithoutReviewInput | ReviewCommentCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewCommentCreateManyReviewInputEnvelope
    connect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type GameUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<GameCreateWithoutReviewsInput, GameUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: GameCreateOrConnectWithoutReviewsInput
    upsert?: GameUpsertWithoutReviewsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutReviewsInput, GameUpdateWithoutReviewsInput>, GameUncheckedUpdateWithoutReviewsInput>
  }

  export type ReviewUserTagUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewUserTagCreateWithoutReviewInput, ReviewUserTagUncheckedCreateWithoutReviewInput> | ReviewUserTagCreateWithoutReviewInput[] | ReviewUserTagUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewUserTagCreateOrConnectWithoutReviewInput | ReviewUserTagCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewUserTagUpsertWithWhereUniqueWithoutReviewInput | ReviewUserTagUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewUserTagCreateManyReviewInputEnvelope
    set?: ReviewUserTagWhereUniqueInput | ReviewUserTagWhereUniqueInput[]
    disconnect?: ReviewUserTagWhereUniqueInput | ReviewUserTagWhereUniqueInput[]
    delete?: ReviewUserTagWhereUniqueInput | ReviewUserTagWhereUniqueInput[]
    connect?: ReviewUserTagWhereUniqueInput | ReviewUserTagWhereUniqueInput[]
    update?: ReviewUserTagUpdateWithWhereUniqueWithoutReviewInput | ReviewUserTagUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewUserTagUpdateManyWithWhereWithoutReviewInput | ReviewUserTagUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewUserTagScalarWhereInput | ReviewUserTagScalarWhereInput[]
  }

  export type ReviewCommentUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewCommentCreateWithoutReviewInput, ReviewCommentUncheckedCreateWithoutReviewInput> | ReviewCommentCreateWithoutReviewInput[] | ReviewCommentUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewCommentCreateOrConnectWithoutReviewInput | ReviewCommentCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewCommentUpsertWithWhereUniqueWithoutReviewInput | ReviewCommentUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewCommentCreateManyReviewInputEnvelope
    set?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    disconnect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    delete?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    connect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    update?: ReviewCommentUpdateWithWhereUniqueWithoutReviewInput | ReviewCommentUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewCommentUpdateManyWithWhereWithoutReviewInput | ReviewCommentUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewCommentScalarWhereInput | ReviewCommentScalarWhereInput[]
  }

  export type ReviewUserTagUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewUserTagCreateWithoutReviewInput, ReviewUserTagUncheckedCreateWithoutReviewInput> | ReviewUserTagCreateWithoutReviewInput[] | ReviewUserTagUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewUserTagCreateOrConnectWithoutReviewInput | ReviewUserTagCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewUserTagUpsertWithWhereUniqueWithoutReviewInput | ReviewUserTagUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewUserTagCreateManyReviewInputEnvelope
    set?: ReviewUserTagWhereUniqueInput | ReviewUserTagWhereUniqueInput[]
    disconnect?: ReviewUserTagWhereUniqueInput | ReviewUserTagWhereUniqueInput[]
    delete?: ReviewUserTagWhereUniqueInput | ReviewUserTagWhereUniqueInput[]
    connect?: ReviewUserTagWhereUniqueInput | ReviewUserTagWhereUniqueInput[]
    update?: ReviewUserTagUpdateWithWhereUniqueWithoutReviewInput | ReviewUserTagUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewUserTagUpdateManyWithWhereWithoutReviewInput | ReviewUserTagUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewUserTagScalarWhereInput | ReviewUserTagScalarWhereInput[]
  }

  export type ReviewCommentUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewCommentCreateWithoutReviewInput, ReviewCommentUncheckedCreateWithoutReviewInput> | ReviewCommentCreateWithoutReviewInput[] | ReviewCommentUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewCommentCreateOrConnectWithoutReviewInput | ReviewCommentCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewCommentUpsertWithWhereUniqueWithoutReviewInput | ReviewCommentUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewCommentCreateManyReviewInputEnvelope
    set?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    disconnect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    delete?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    connect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    update?: ReviewCommentUpdateWithWhereUniqueWithoutReviewInput | ReviewCommentUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewCommentUpdateManyWithWhereWithoutReviewInput | ReviewCommentUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewCommentScalarWhereInput | ReviewCommentScalarWhereInput[]
  }

  export type ReviewCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ReviewCreateWithoutCommentsInput, ReviewUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutCommentsInput
    connect?: ReviewWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewCommentInput = {
    create?: XOR<UserCreateWithoutReviewCommentInput, UserUncheckedCreateWithoutReviewCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewCommentInput
    connect?: UserWhereUniqueInput
  }

  export type ReviewUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ReviewCreateWithoutCommentsInput, ReviewUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutCommentsInput
    upsert?: ReviewUpsertWithoutCommentsInput
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutCommentsInput, ReviewUpdateWithoutCommentsInput>, ReviewUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutReviewCommentNestedInput = {
    create?: XOR<UserCreateWithoutReviewCommentInput, UserUncheckedCreateWithoutReviewCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewCommentInput
    upsert?: UserUpsertWithoutReviewCommentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewCommentInput, UserUpdateWithoutReviewCommentInput>, UserUncheckedUpdateWithoutReviewCommentInput>
  }

  export type UserCreateNestedOneWithoutGameUserInput = {
    create?: XOR<UserCreateWithoutGameUserInput, UserUncheckedCreateWithoutGameUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutGameUserInput
    connect?: UserWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutUsersInput = {
    create?: XOR<GameCreateWithoutUsersInput, GameUncheckedCreateWithoutUsersInput>
    connectOrCreate?: GameCreateOrConnectWithoutUsersInput
    connect?: GameWhereUniqueInput
  }

  export type EnumProgressStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProgressStatus
  }

  export type UserUpdateOneRequiredWithoutGameUserNestedInput = {
    create?: XOR<UserCreateWithoutGameUserInput, UserUncheckedCreateWithoutGameUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutGameUserInput
    upsert?: UserUpsertWithoutGameUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGameUserInput, UserUpdateWithoutGameUserInput>, UserUncheckedUpdateWithoutGameUserInput>
  }

  export type GameUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<GameCreateWithoutUsersInput, GameUncheckedCreateWithoutUsersInput>
    connectOrCreate?: GameCreateOrConnectWithoutUsersInput
    upsert?: GameUpsertWithoutUsersInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutUsersInput, GameUpdateWithoutUsersInput>, GameUncheckedUpdateWithoutUsersInput>
  }

  export type GameCreateNestedManyWithoutStatusesInput = {
    create?: XOR<GameCreateWithoutStatusesInput, GameUncheckedCreateWithoutStatusesInput> | GameCreateWithoutStatusesInput[] | GameUncheckedCreateWithoutStatusesInput[]
    connectOrCreate?: GameCreateOrConnectWithoutStatusesInput | GameCreateOrConnectWithoutStatusesInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutGameStatusesInput = {
    create?: XOR<UserCreateWithoutGameStatusesInput, UserUncheckedCreateWithoutGameStatusesInput>
    connectOrCreate?: UserCreateOrConnectWithoutGameStatusesInput
    connect?: UserWhereUniqueInput
  }

  export type GameUncheckedCreateNestedManyWithoutStatusesInput = {
    create?: XOR<GameCreateWithoutStatusesInput, GameUncheckedCreateWithoutStatusesInput> | GameCreateWithoutStatusesInput[] | GameUncheckedCreateWithoutStatusesInput[]
    connectOrCreate?: GameCreateOrConnectWithoutStatusesInput | GameCreateOrConnectWithoutStatusesInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type EnumGameStatusTypeFieldUpdateOperationsInput = {
    set?: $Enums.GameStatusType
  }

  export type GameUpdateManyWithoutStatusesNestedInput = {
    create?: XOR<GameCreateWithoutStatusesInput, GameUncheckedCreateWithoutStatusesInput> | GameCreateWithoutStatusesInput[] | GameUncheckedCreateWithoutStatusesInput[]
    connectOrCreate?: GameCreateOrConnectWithoutStatusesInput | GameCreateOrConnectWithoutStatusesInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutStatusesInput | GameUpsertWithWhereUniqueWithoutStatusesInput[]
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutStatusesInput | GameUpdateWithWhereUniqueWithoutStatusesInput[]
    updateMany?: GameUpdateManyWithWhereWithoutStatusesInput | GameUpdateManyWithWhereWithoutStatusesInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutGameStatusesNestedInput = {
    create?: XOR<UserCreateWithoutGameStatusesInput, UserUncheckedCreateWithoutGameStatusesInput>
    connectOrCreate?: UserCreateOrConnectWithoutGameStatusesInput
    upsert?: UserUpsertWithoutGameStatusesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGameStatusesInput, UserUpdateWithoutGameStatusesInput>, UserUncheckedUpdateWithoutGameStatusesInput>
  }

  export type GameUncheckedUpdateManyWithoutStatusesNestedInput = {
    create?: XOR<GameCreateWithoutStatusesInput, GameUncheckedCreateWithoutStatusesInput> | GameCreateWithoutStatusesInput[] | GameUncheckedCreateWithoutStatusesInput[]
    connectOrCreate?: GameCreateOrConnectWithoutStatusesInput | GameCreateOrConnectWithoutStatusesInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutStatusesInput | GameUpsertWithWhereUniqueWithoutStatusesInput[]
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutStatusesInput | GameUpdateWithWhereUniqueWithoutStatusesInput[]
    updateMany?: GameUpdateManyWithWhereWithoutStatusesInput | GameUpdateManyWithWhereWithoutStatusesInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutUserTagsInput = {
    create?: XOR<UserCreateWithoutUserTagsInput, UserUncheckedCreateWithoutUserTagsInput> | UserCreateWithoutUserTagsInput[] | UserUncheckedCreateWithoutUserTagsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUserTagsInput | UserCreateOrConnectWithoutUserTagsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutUserTagsInput = {
    create?: XOR<UserCreateWithoutUserTagsInput, UserUncheckedCreateWithoutUserTagsInput> | UserCreateWithoutUserTagsInput[] | UserUncheckedCreateWithoutUserTagsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUserTagsInput | UserCreateOrConnectWithoutUserTagsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutUserTagsNestedInput = {
    create?: XOR<UserCreateWithoutUserTagsInput, UserUncheckedCreateWithoutUserTagsInput> | UserCreateWithoutUserTagsInput[] | UserUncheckedCreateWithoutUserTagsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUserTagsInput | UserCreateOrConnectWithoutUserTagsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutUserTagsInput | UserUpsertWithWhereUniqueWithoutUserTagsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutUserTagsInput | UserUpdateWithWhereUniqueWithoutUserTagsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutUserTagsInput | UserUpdateManyWithWhereWithoutUserTagsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutUserTagsNestedInput = {
    create?: XOR<UserCreateWithoutUserTagsInput, UserUncheckedCreateWithoutUserTagsInput> | UserCreateWithoutUserTagsInput[] | UserUncheckedCreateWithoutUserTagsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUserTagsInput | UserCreateOrConnectWithoutUserTagsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutUserTagsInput | UserUpsertWithWhereUniqueWithoutUserTagsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutUserTagsInput | UserUpdateWithWhereUniqueWithoutUserTagsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutUserTagsInput | UserUpdateManyWithWhereWithoutUserTagsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type GameCreateNestedManyWithoutTagsInput = {
    create?: XOR<GameCreateWithoutTagsInput, GameUncheckedCreateWithoutTagsInput> | GameCreateWithoutTagsInput[] | GameUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: GameCreateOrConnectWithoutTagsInput | GameCreateOrConnectWithoutTagsInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<GameCreateWithoutTagsInput, GameUncheckedCreateWithoutTagsInput> | GameCreateWithoutTagsInput[] | GameUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: GameCreateOrConnectWithoutTagsInput | GameCreateOrConnectWithoutTagsInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type GameUpdateManyWithoutTagsNestedInput = {
    create?: XOR<GameCreateWithoutTagsInput, GameUncheckedCreateWithoutTagsInput> | GameCreateWithoutTagsInput[] | GameUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: GameCreateOrConnectWithoutTagsInput | GameCreateOrConnectWithoutTagsInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutTagsInput | GameUpsertWithWhereUniqueWithoutTagsInput[]
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutTagsInput | GameUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: GameUpdateManyWithWhereWithoutTagsInput | GameUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<GameCreateWithoutTagsInput, GameUncheckedCreateWithoutTagsInput> | GameCreateWithoutTagsInput[] | GameUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: GameCreateOrConnectWithoutTagsInput | GameCreateOrConnectWithoutTagsInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutTagsInput | GameUpsertWithWhereUniqueWithoutTagsInput[]
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutTagsInput | GameUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: GameUpdateManyWithWhereWithoutTagsInput | GameUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type ReviewCreateNestedOneWithoutTagsInput = {
    create?: XOR<ReviewCreateWithoutTagsInput, ReviewUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutTagsInput
    connect?: ReviewWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewTagsInput = {
    create?: XOR<UserCreateWithoutReviewTagsInput, UserUncheckedCreateWithoutReviewTagsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewTagsInput
    connect?: UserWhereUniqueInput
  }

  export type ReviewUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<ReviewCreateWithoutTagsInput, ReviewUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutTagsInput
    upsert?: ReviewUpsertWithoutTagsInput
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutTagsInput, ReviewUpdateWithoutTagsInput>, ReviewUncheckedUpdateWithoutTagsInput>
  }

  export type UserUpdateOneRequiredWithoutReviewTagsNestedInput = {
    create?: XOR<UserCreateWithoutReviewTagsInput, UserUncheckedCreateWithoutReviewTagsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewTagsInput
    upsert?: UserUpsertWithoutReviewTagsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewTagsInput, UserUpdateWithoutReviewTagsInput>, UserUncheckedUpdateWithoutReviewTagsInput>
  }

  export type GameCreateNestedManyWithoutDevelopersInput = {
    create?: XOR<GameCreateWithoutDevelopersInput, GameUncheckedCreateWithoutDevelopersInput> | GameCreateWithoutDevelopersInput[] | GameUncheckedCreateWithoutDevelopersInput[]
    connectOrCreate?: GameCreateOrConnectWithoutDevelopersInput | GameCreateOrConnectWithoutDevelopersInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutDevelopersInput = {
    create?: XOR<GameCreateWithoutDevelopersInput, GameUncheckedCreateWithoutDevelopersInput> | GameCreateWithoutDevelopersInput[] | GameUncheckedCreateWithoutDevelopersInput[]
    connectOrCreate?: GameCreateOrConnectWithoutDevelopersInput | GameCreateOrConnectWithoutDevelopersInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type GameUpdateManyWithoutDevelopersNestedInput = {
    create?: XOR<GameCreateWithoutDevelopersInput, GameUncheckedCreateWithoutDevelopersInput> | GameCreateWithoutDevelopersInput[] | GameUncheckedCreateWithoutDevelopersInput[]
    connectOrCreate?: GameCreateOrConnectWithoutDevelopersInput | GameCreateOrConnectWithoutDevelopersInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutDevelopersInput | GameUpsertWithWhereUniqueWithoutDevelopersInput[]
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutDevelopersInput | GameUpdateWithWhereUniqueWithoutDevelopersInput[]
    updateMany?: GameUpdateManyWithWhereWithoutDevelopersInput | GameUpdateManyWithWhereWithoutDevelopersInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutDevelopersNestedInput = {
    create?: XOR<GameCreateWithoutDevelopersInput, GameUncheckedCreateWithoutDevelopersInput> | GameCreateWithoutDevelopersInput[] | GameUncheckedCreateWithoutDevelopersInput[]
    connectOrCreate?: GameCreateOrConnectWithoutDevelopersInput | GameCreateOrConnectWithoutDevelopersInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutDevelopersInput | GameUpsertWithWhereUniqueWithoutDevelopersInput[]
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutDevelopersInput | GameUpdateWithWhereUniqueWithoutDevelopersInput[]
    updateMany?: GameUpdateManyWithWhereWithoutDevelopersInput | GameUpdateManyWithWhereWithoutDevelopersInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type GameCreateNestedManyWithoutPublishersInput = {
    create?: XOR<GameCreateWithoutPublishersInput, GameUncheckedCreateWithoutPublishersInput> | GameCreateWithoutPublishersInput[] | GameUncheckedCreateWithoutPublishersInput[]
    connectOrCreate?: GameCreateOrConnectWithoutPublishersInput | GameCreateOrConnectWithoutPublishersInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutPublishersInput = {
    create?: XOR<GameCreateWithoutPublishersInput, GameUncheckedCreateWithoutPublishersInput> | GameCreateWithoutPublishersInput[] | GameUncheckedCreateWithoutPublishersInput[]
    connectOrCreate?: GameCreateOrConnectWithoutPublishersInput | GameCreateOrConnectWithoutPublishersInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type GameUpdateManyWithoutPublishersNestedInput = {
    create?: XOR<GameCreateWithoutPublishersInput, GameUncheckedCreateWithoutPublishersInput> | GameCreateWithoutPublishersInput[] | GameUncheckedCreateWithoutPublishersInput[]
    connectOrCreate?: GameCreateOrConnectWithoutPublishersInput | GameCreateOrConnectWithoutPublishersInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutPublishersInput | GameUpsertWithWhereUniqueWithoutPublishersInput[]
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutPublishersInput | GameUpdateWithWhereUniqueWithoutPublishersInput[]
    updateMany?: GameUpdateManyWithWhereWithoutPublishersInput | GameUpdateManyWithWhereWithoutPublishersInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutPublishersNestedInput = {
    create?: XOR<GameCreateWithoutPublishersInput, GameUncheckedCreateWithoutPublishersInput> | GameCreateWithoutPublishersInput[] | GameUncheckedCreateWithoutPublishersInput[]
    connectOrCreate?: GameCreateOrConnectWithoutPublishersInput | GameCreateOrConnectWithoutPublishersInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutPublishersInput | GameUpsertWithWhereUniqueWithoutPublishersInput[]
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutPublishersInput | GameUpdateWithWhereUniqueWithoutPublishersInput[]
    updateMany?: GameUpdateManyWithWhereWithoutPublishersInput | GameUpdateManyWithWhereWithoutPublishersInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type GameCreateNestedOneWithoutImagesInput = {
    create?: XOR<GameCreateWithoutImagesInput, GameUncheckedCreateWithoutImagesInput>
    connectOrCreate?: GameCreateOrConnectWithoutImagesInput
    connect?: GameWhereUniqueInput
  }

  export type GameUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<GameCreateWithoutImagesInput, GameUncheckedCreateWithoutImagesInput>
    connectOrCreate?: GameCreateOrConnectWithoutImagesInput
    upsert?: GameUpsertWithoutImagesInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutImagesInput, GameUpdateWithoutImagesInput>, GameUncheckedUpdateWithoutImagesInput>
  }

  export type GameCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<GameCreateWithoutAchievementsInput, GameUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: GameCreateOrConnectWithoutAchievementsInput
    connect?: GameWhereUniqueInput
  }

  export type AchievementUnlockCreateNestedManyWithoutAchievementInput = {
    create?: XOR<AchievementUnlockCreateWithoutAchievementInput, AchievementUnlockUncheckedCreateWithoutAchievementInput> | AchievementUnlockCreateWithoutAchievementInput[] | AchievementUnlockUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: AchievementUnlockCreateOrConnectWithoutAchievementInput | AchievementUnlockCreateOrConnectWithoutAchievementInput[]
    createMany?: AchievementUnlockCreateManyAchievementInputEnvelope
    connect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
  }

  export type AchievementUnlockUncheckedCreateNestedManyWithoutAchievementInput = {
    create?: XOR<AchievementUnlockCreateWithoutAchievementInput, AchievementUnlockUncheckedCreateWithoutAchievementInput> | AchievementUnlockCreateWithoutAchievementInput[] | AchievementUnlockUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: AchievementUnlockCreateOrConnectWithoutAchievementInput | AchievementUnlockCreateOrConnectWithoutAchievementInput[]
    createMany?: AchievementUnlockCreateManyAchievementInputEnvelope
    connect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
  }

  export type GameUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<GameCreateWithoutAchievementsInput, GameUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: GameCreateOrConnectWithoutAchievementsInput
    upsert?: GameUpsertWithoutAchievementsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutAchievementsInput, GameUpdateWithoutAchievementsInput>, GameUncheckedUpdateWithoutAchievementsInput>
  }

  export type AchievementUnlockUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<AchievementUnlockCreateWithoutAchievementInput, AchievementUnlockUncheckedCreateWithoutAchievementInput> | AchievementUnlockCreateWithoutAchievementInput[] | AchievementUnlockUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: AchievementUnlockCreateOrConnectWithoutAchievementInput | AchievementUnlockCreateOrConnectWithoutAchievementInput[]
    upsert?: AchievementUnlockUpsertWithWhereUniqueWithoutAchievementInput | AchievementUnlockUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: AchievementUnlockCreateManyAchievementInputEnvelope
    set?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    disconnect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    delete?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    connect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    update?: AchievementUnlockUpdateWithWhereUniqueWithoutAchievementInput | AchievementUnlockUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: AchievementUnlockUpdateManyWithWhereWithoutAchievementInput | AchievementUnlockUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: AchievementUnlockScalarWhereInput | AchievementUnlockScalarWhereInput[]
  }

  export type AchievementUnlockUncheckedUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<AchievementUnlockCreateWithoutAchievementInput, AchievementUnlockUncheckedCreateWithoutAchievementInput> | AchievementUnlockCreateWithoutAchievementInput[] | AchievementUnlockUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: AchievementUnlockCreateOrConnectWithoutAchievementInput | AchievementUnlockCreateOrConnectWithoutAchievementInput[]
    upsert?: AchievementUnlockUpsertWithWhereUniqueWithoutAchievementInput | AchievementUnlockUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: AchievementUnlockCreateManyAchievementInputEnvelope
    set?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    disconnect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    delete?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    connect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    update?: AchievementUnlockUpdateWithWhereUniqueWithoutAchievementInput | AchievementUnlockUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: AchievementUnlockUpdateManyWithWhereWithoutAchievementInput | AchievementUnlockUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: AchievementUnlockScalarWhereInput | AchievementUnlockScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    connect?: UserWhereUniqueInput
  }

  export type AchievementCreateNestedOneWithoutUnlocksInput = {
    create?: XOR<AchievementCreateWithoutUnlocksInput, AchievementUncheckedCreateWithoutUnlocksInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUnlocksInput
    connect?: AchievementWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    upsert?: UserUpsertWithoutAchievementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAchievementsInput, UserUpdateWithoutAchievementsInput>, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type AchievementUpdateOneRequiredWithoutUnlocksNestedInput = {
    create?: XOR<AchievementCreateWithoutUnlocksInput, AchievementUncheckedCreateWithoutUnlocksInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUnlocksInput
    upsert?: AchievementUpsertWithoutUnlocksInput
    connect?: AchievementWhereUniqueInput
    update?: XOR<XOR<AchievementUpdateToOneWithWhereWithoutUnlocksInput, AchievementUpdateWithoutUnlocksInput>, AchievementUncheckedUpdateWithoutUnlocksInput>
  }

  export type UserCreateNestedOneWithoutEmailChangesInput = {
    create?: XOR<UserCreateWithoutEmailChangesInput, UserUncheckedCreateWithoutEmailChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailChangesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEmailChangesNestedInput = {
    create?: XOR<UserCreateWithoutEmailChangesInput, UserUncheckedCreateWithoutEmailChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailChangesInput
    upsert?: UserUpsertWithoutEmailChangesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailChangesInput, UserUpdateWithoutEmailChangesInput>, UserUncheckedUpdateWithoutEmailChangesInput>
  }

  export type UserCreateNestedOneWithoutEmailVerificationsInput = {
    create?: XOR<UserCreateWithoutEmailVerificationsInput, UserUncheckedCreateWithoutEmailVerificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailVerificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEmailVerificationsNestedInput = {
    create?: XOR<UserCreateWithoutEmailVerificationsInput, UserUncheckedCreateWithoutEmailVerificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailVerificationsInput
    upsert?: UserUpsertWithoutEmailVerificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailVerificationsInput, UserUpdateWithoutEmailVerificationsInput>, UserUncheckedUpdateWithoutEmailVerificationsInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetsInput = {
    create?: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetsNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetsInput
    upsert?: UserUpsertWithoutPasswordResetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetsInput, UserUpdateWithoutPasswordResetsInput>, UserUncheckedUpdateWithoutPasswordResetsInput>
  }

  export type UserCreateNestedOneWithoutSentFriendRequestsInput = {
    create?: XOR<UserCreateWithoutSentFriendRequestsInput, UserUncheckedCreateWithoutSentFriendRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentFriendRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedFriendRequestsInput = {
    create?: XOR<UserCreateWithoutReceivedFriendRequestsInput, UserUncheckedCreateWithoutReceivedFriendRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedFriendRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFriendshipStatusFieldUpdateOperationsInput = {
    set?: $Enums.FriendshipStatus
  }

  export type UserUpdateOneRequiredWithoutSentFriendRequestsNestedInput = {
    create?: XOR<UserCreateWithoutSentFriendRequestsInput, UserUncheckedCreateWithoutSentFriendRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentFriendRequestsInput
    upsert?: UserUpsertWithoutSentFriendRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentFriendRequestsInput, UserUpdateWithoutSentFriendRequestsInput>, UserUncheckedUpdateWithoutSentFriendRequestsInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedFriendRequestsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedFriendRequestsInput, UserUncheckedCreateWithoutReceivedFriendRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedFriendRequestsInput
    upsert?: UserUpsertWithoutReceivedFriendRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedFriendRequestsInput, UserUpdateWithoutReceivedFriendRequestsInput>, UserUncheckedUpdateWithoutReceivedFriendRequestsInput>
  }

  export type UserCreateNestedManyWithoutGroupsInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput> | UserCreateWithoutGroupsInput[] | UserUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput | UserCreateOrConnectWithoutGroupsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutGroupsInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput> | UserCreateWithoutGroupsInput[] | UserUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput | UserCreateOrConnectWithoutGroupsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput> | UserCreateWithoutGroupsInput[] | UserUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput | UserCreateOrConnectWithoutGroupsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutGroupsInput | UserUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutGroupsInput | UserUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutGroupsInput | UserUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput> | UserCreateWithoutGroupsInput[] | UserUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput | UserCreateOrConnectWithoutGroupsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutGroupsInput | UserUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutGroupsInput | UserUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutGroupsInput | UserUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type GameCreateNestedManyWithoutGenresInput = {
    create?: XOR<GameCreateWithoutGenresInput, GameUncheckedCreateWithoutGenresInput> | GameCreateWithoutGenresInput[] | GameUncheckedCreateWithoutGenresInput[]
    connectOrCreate?: GameCreateOrConnectWithoutGenresInput | GameCreateOrConnectWithoutGenresInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutGenresInput = {
    create?: XOR<GameCreateWithoutGenresInput, GameUncheckedCreateWithoutGenresInput> | GameCreateWithoutGenresInput[] | GameUncheckedCreateWithoutGenresInput[]
    connectOrCreate?: GameCreateOrConnectWithoutGenresInput | GameCreateOrConnectWithoutGenresInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type GameUpdateManyWithoutGenresNestedInput = {
    create?: XOR<GameCreateWithoutGenresInput, GameUncheckedCreateWithoutGenresInput> | GameCreateWithoutGenresInput[] | GameUncheckedCreateWithoutGenresInput[]
    connectOrCreate?: GameCreateOrConnectWithoutGenresInput | GameCreateOrConnectWithoutGenresInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutGenresInput | GameUpsertWithWhereUniqueWithoutGenresInput[]
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutGenresInput | GameUpdateWithWhereUniqueWithoutGenresInput[]
    updateMany?: GameUpdateManyWithWhereWithoutGenresInput | GameUpdateManyWithWhereWithoutGenresInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutGenresNestedInput = {
    create?: XOR<GameCreateWithoutGenresInput, GameUncheckedCreateWithoutGenresInput> | GameCreateWithoutGenresInput[] | GameUncheckedCreateWithoutGenresInput[]
    connectOrCreate?: GameCreateOrConnectWithoutGenresInput | GameCreateOrConnectWithoutGenresInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutGenresInput | GameUpsertWithWhereUniqueWithoutGenresInput[]
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutGenresInput | GameUpdateWithWhereUniqueWithoutGenresInput[]
    updateMany?: GameUpdateManyWithWhereWithoutGenresInput | GameUpdateManyWithWhereWithoutGenresInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type GameCreateNestedManyWithoutPlatformsInput = {
    create?: XOR<GameCreateWithoutPlatformsInput, GameUncheckedCreateWithoutPlatformsInput> | GameCreateWithoutPlatformsInput[] | GameUncheckedCreateWithoutPlatformsInput[]
    connectOrCreate?: GameCreateOrConnectWithoutPlatformsInput | GameCreateOrConnectWithoutPlatformsInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutPlatformsInput = {
    create?: XOR<GameCreateWithoutPlatformsInput, GameUncheckedCreateWithoutPlatformsInput> | GameCreateWithoutPlatformsInput[] | GameUncheckedCreateWithoutPlatformsInput[]
    connectOrCreate?: GameCreateOrConnectWithoutPlatformsInput | GameCreateOrConnectWithoutPlatformsInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type GameUpdateManyWithoutPlatformsNestedInput = {
    create?: XOR<GameCreateWithoutPlatformsInput, GameUncheckedCreateWithoutPlatformsInput> | GameCreateWithoutPlatformsInput[] | GameUncheckedCreateWithoutPlatformsInput[]
    connectOrCreate?: GameCreateOrConnectWithoutPlatformsInput | GameCreateOrConnectWithoutPlatformsInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutPlatformsInput | GameUpsertWithWhereUniqueWithoutPlatformsInput[]
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutPlatformsInput | GameUpdateWithWhereUniqueWithoutPlatformsInput[]
    updateMany?: GameUpdateManyWithWhereWithoutPlatformsInput | GameUpdateManyWithWhereWithoutPlatformsInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutPlatformsNestedInput = {
    create?: XOR<GameCreateWithoutPlatformsInput, GameUncheckedCreateWithoutPlatformsInput> | GameCreateWithoutPlatformsInput[] | GameUncheckedCreateWithoutPlatformsInput[]
    connectOrCreate?: GameCreateOrConnectWithoutPlatformsInput | GameCreateOrConnectWithoutPlatformsInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutPlatformsInput | GameUpsertWithWhereUniqueWithoutPlatformsInput[]
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutPlatformsInput | GameUpdateWithWhereUniqueWithoutPlatformsInput[]
    updateMany?: GameUpdateManyWithWhereWithoutPlatformsInput | GameUpdateManyWithWhereWithoutPlatformsInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumProgressStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProgressStatus | EnumProgressStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProgressStatus[] | ListEnumProgressStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProgressStatus[] | ListEnumProgressStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProgressStatusFilter<$PrismaModel> | $Enums.ProgressStatus
  }

  export type NestedEnumProgressStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProgressStatus | EnumProgressStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProgressStatus[] | ListEnumProgressStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProgressStatus[] | ListEnumProgressStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProgressStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProgressStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProgressStatusFilter<$PrismaModel>
    _max?: NestedEnumProgressStatusFilter<$PrismaModel>
  }

  export type NestedEnumGameStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatusType | EnumGameStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatusType[] | ListEnumGameStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatusType[] | ListEnumGameStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusTypeFilter<$PrismaModel> | $Enums.GameStatusType
  }

  export type NestedEnumGameStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatusType | EnumGameStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatusType[] | ListEnumGameStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatusType[] | ListEnumGameStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.GameStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumGameStatusTypeFilter<$PrismaModel>
  }

  export type NestedEnumFriendshipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusFilter<$PrismaModel> | $Enums.FriendshipStatus
  }

  export type NestedEnumFriendshipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusWithAggregatesFilter<$PrismaModel> | $Enums.FriendshipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFriendshipStatusFilter<$PrismaModel>
    _max?: NestedEnumFriendshipStatusFilter<$PrismaModel>
  }

  export type ImageCreateWithoutUserInput = {
    url: string
    checksum: string
    width?: number | null
    height?: number | null
    uploadedAt?: Date | string
    uploadedBy?: UserCreateNestedOneWithoutUploadedImagesInput
    games?: GameCreateNestedManyWithoutCoverImageInput
  }

  export type ImageUncheckedCreateWithoutUserInput = {
    id?: number
    url: string
    checksum: string
    width?: number | null
    height?: number | null
    uploadedAt?: Date | string
    uploadedById?: number | null
    games?: GameUncheckedCreateNestedManyWithoutCoverImageInput
  }

  export type ImageCreateOrConnectWithoutUserInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutUserInput, ImageUncheckedCreateWithoutUserInput>
  }

  export type EmailChangeCreateWithoutUserInput = {
    newEmail: string
    token: string
    createdAt?: Date | string
  }

  export type EmailChangeUncheckedCreateWithoutUserInput = {
    id?: number
    newEmail: string
    token: string
    createdAt?: Date | string
  }

  export type EmailChangeCreateOrConnectWithoutUserInput = {
    where: EmailChangeWhereUniqueInput
    create: XOR<EmailChangeCreateWithoutUserInput, EmailChangeUncheckedCreateWithoutUserInput>
  }

  export type EmailChangeCreateManyUserInputEnvelope = {
    data: EmailChangeCreateManyUserInput | EmailChangeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmailVerificationCreateWithoutUserInput = {
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type EmailVerificationUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type EmailVerificationCreateOrConnectWithoutUserInput = {
    where: EmailVerificationWhereUniqueInput
    create: XOR<EmailVerificationCreateWithoutUserInput, EmailVerificationUncheckedCreateWithoutUserInput>
  }

  export type EmailVerificationCreateManyUserInputEnvelope = {
    data: EmailVerificationCreateManyUserInput | EmailVerificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetCreateWithoutUserInput = {
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type PasswordResetUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type PasswordResetCreateOrConnectWithoutUserInput = {
    where: PasswordResetWhereUniqueInput
    create: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetCreateManyUserInputEnvelope = {
    data: PasswordResetCreateManyUserInput | PasswordResetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GameCreateWithoutUserInput = {
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImage?: ImageCreateNestedOneWithoutGamesInput
    reviews?: ReviewCreateNestedManyWithoutGameInput
    users?: GameUserCreateNestedManyWithoutGameInput
    favouritedBy?: UserCreateNestedManyWithoutFavouritesInput
    genres?: GenreCreateNestedManyWithoutGamesInput
    platforms?: PlatformCreateNestedManyWithoutGamesInput
    tags?: GameTagCreateNestedManyWithoutGamesInput
    statuses?: GameStatusCreateNestedManyWithoutGamesInput
    developers?: DeveloperCreateNestedManyWithoutGamesInput
    publishers?: PublisherCreateNestedManyWithoutGamesInput
    images?: GameImageCreateNestedManyWithoutGameInput
    achievements?: AchievementCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImageId?: number | null
    reviews?: ReviewUncheckedCreateNestedManyWithoutGameInput
    users?: GameUserUncheckedCreateNestedManyWithoutGameInput
    favouritedBy?: UserUncheckedCreateNestedManyWithoutFavouritesInput
    genres?: GenreUncheckedCreateNestedManyWithoutGamesInput
    platforms?: PlatformUncheckedCreateNestedManyWithoutGamesInput
    tags?: GameTagUncheckedCreateNestedManyWithoutGamesInput
    statuses?: GameStatusUncheckedCreateNestedManyWithoutGamesInput
    developers?: DeveloperUncheckedCreateNestedManyWithoutGamesInput
    publishers?: PublisherUncheckedCreateNestedManyWithoutGamesInput
    images?: GameImageUncheckedCreateNestedManyWithoutGameInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutUserInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutUserInput, GameUncheckedCreateWithoutUserInput>
  }

  export type GameCreateManyUserInputEnvelope = {
    data: GameCreateManyUserInput | GameCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GameCreateWithoutFavouritedByInput = {
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImage?: ImageCreateNestedOneWithoutGamesInput
    reviews?: ReviewCreateNestedManyWithoutGameInput
    users?: GameUserCreateNestedManyWithoutGameInput
    genres?: GenreCreateNestedManyWithoutGamesInput
    platforms?: PlatformCreateNestedManyWithoutGamesInput
    tags?: GameTagCreateNestedManyWithoutGamesInput
    statuses?: GameStatusCreateNestedManyWithoutGamesInput
    developers?: DeveloperCreateNestedManyWithoutGamesInput
    publishers?: PublisherCreateNestedManyWithoutGamesInput
    images?: GameImageCreateNestedManyWithoutGameInput
    achievements?: AchievementCreateNestedManyWithoutGameInput
    User?: UserCreateNestedOneWithoutPlayedGamesInput
  }

  export type GameUncheckedCreateWithoutFavouritedByInput = {
    id?: number
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImageId?: number | null
    userId?: number | null
    reviews?: ReviewUncheckedCreateNestedManyWithoutGameInput
    users?: GameUserUncheckedCreateNestedManyWithoutGameInput
    genres?: GenreUncheckedCreateNestedManyWithoutGamesInput
    platforms?: PlatformUncheckedCreateNestedManyWithoutGamesInput
    tags?: GameTagUncheckedCreateNestedManyWithoutGamesInput
    statuses?: GameStatusUncheckedCreateNestedManyWithoutGamesInput
    developers?: DeveloperUncheckedCreateNestedManyWithoutGamesInput
    publishers?: PublisherUncheckedCreateNestedManyWithoutGamesInput
    images?: GameImageUncheckedCreateNestedManyWithoutGameInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutFavouritedByInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutFavouritedByInput, GameUncheckedCreateWithoutFavouritedByInput>
  }

  export type FriendshipCreateWithoutSenderInput = {
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedFriendRequestsInput
  }

  export type FriendshipUncheckedCreateWithoutSenderInput = {
    id?: number
    receiverId: number
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
  }

  export type FriendshipCreateOrConnectWithoutSenderInput = {
    where: FriendshipWhereUniqueInput
    create: XOR<FriendshipCreateWithoutSenderInput, FriendshipUncheckedCreateWithoutSenderInput>
  }

  export type FriendshipCreateManySenderInputEnvelope = {
    data: FriendshipCreateManySenderInput | FriendshipCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type FriendshipCreateWithoutReceiverInput = {
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentFriendRequestsInput
  }

  export type FriendshipUncheckedCreateWithoutReceiverInput = {
    id?: number
    senderId: number
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
  }

  export type FriendshipCreateOrConnectWithoutReceiverInput = {
    where: FriendshipWhereUniqueInput
    create: XOR<FriendshipCreateWithoutReceiverInput, FriendshipUncheckedCreateWithoutReceiverInput>
  }

  export type FriendshipCreateManyReceiverInputEnvelope = {
    data: FriendshipCreateManyReceiverInput | FriendshipCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type UserGroupCreateWithoutUsersInput = {
    name: string
    role?: string
  }

  export type UserGroupUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    role?: string
  }

  export type UserGroupCreateOrConnectWithoutUsersInput = {
    where: UserGroupWhereUniqueInput
    create: XOR<UserGroupCreateWithoutUsersInput, UserGroupUncheckedCreateWithoutUsersInput>
  }

  export type ReviewCreateWithoutUserInput = {
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    game: GameCreateNestedOneWithoutReviewsInput
    tags?: ReviewUserTagCreateNestedManyWithoutReviewInput
    comments?: ReviewCommentCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: number
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gameId: number
    tags?: ReviewUserTagUncheckedCreateNestedManyWithoutReviewInput
    comments?: ReviewCommentUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewUserTagCreateWithoutUserInput = {
    label: string
    review: ReviewCreateNestedOneWithoutTagsInput
  }

  export type ReviewUserTagUncheckedCreateWithoutUserInput = {
    id?: number
    label: string
    reviewId: number
  }

  export type ReviewUserTagCreateOrConnectWithoutUserInput = {
    where: ReviewUserTagWhereUniqueInput
    create: XOR<ReviewUserTagCreateWithoutUserInput, ReviewUserTagUncheckedCreateWithoutUserInput>
  }

  export type ReviewUserTagCreateManyUserInputEnvelope = {
    data: ReviewUserTagCreateManyUserInput | ReviewUserTagCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserTagCreateWithoutUsersInput = {
    label: string
  }

  export type UserTagUncheckedCreateWithoutUsersInput = {
    id?: number
    label: string
  }

  export type UserTagCreateOrConnectWithoutUsersInput = {
    where: UserTagWhereUniqueInput
    create: XOR<UserTagCreateWithoutUsersInput, UserTagUncheckedCreateWithoutUsersInput>
  }

  export type GameStatusCreateWithoutUserInput = {
    type: $Enums.GameStatusType
    games?: GameCreateNestedManyWithoutStatusesInput
  }

  export type GameStatusUncheckedCreateWithoutUserInput = {
    id?: number
    type: $Enums.GameStatusType
    games?: GameUncheckedCreateNestedManyWithoutStatusesInput
  }

  export type GameStatusCreateOrConnectWithoutUserInput = {
    where: GameStatusWhereUniqueInput
    create: XOR<GameStatusCreateWithoutUserInput, GameStatusUncheckedCreateWithoutUserInput>
  }

  export type GameStatusCreateManyUserInputEnvelope = {
    data: GameStatusCreateManyUserInput | GameStatusCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AchievementUnlockCreateWithoutUserInput = {
    unlockedAt?: Date | string
    achievement: AchievementCreateNestedOneWithoutUnlocksInput
  }

  export type AchievementUnlockUncheckedCreateWithoutUserInput = {
    id?: number
    unlockedAt?: Date | string
    achievementId: number
  }

  export type AchievementUnlockCreateOrConnectWithoutUserInput = {
    where: AchievementUnlockWhereUniqueInput
    create: XOR<AchievementUnlockCreateWithoutUserInput, AchievementUnlockUncheckedCreateWithoutUserInput>
  }

  export type AchievementUnlockCreateManyUserInputEnvelope = {
    data: AchievementUnlockCreateManyUserInput | AchievementUnlockCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ImageCreateWithoutUploadedByInput = {
    url: string
    checksum: string
    width?: number | null
    height?: number | null
    uploadedAt?: Date | string
    games?: GameCreateNestedManyWithoutCoverImageInput
    User?: UserCreateNestedManyWithoutProfilePictureInput
  }

  export type ImageUncheckedCreateWithoutUploadedByInput = {
    id?: number
    url: string
    checksum: string
    width?: number | null
    height?: number | null
    uploadedAt?: Date | string
    games?: GameUncheckedCreateNestedManyWithoutCoverImageInput
    User?: UserUncheckedCreateNestedManyWithoutProfilePictureInput
  }

  export type ImageCreateOrConnectWithoutUploadedByInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutUploadedByInput, ImageUncheckedCreateWithoutUploadedByInput>
  }

  export type ImageCreateManyUploadedByInputEnvelope = {
    data: ImageCreateManyUploadedByInput | ImageCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCommentCreateWithoutUserInput = {
    content: string
    createdAt?: Date | string
    review: ReviewCreateNestedOneWithoutCommentsInput
  }

  export type ReviewCommentUncheckedCreateWithoutUserInput = {
    id?: number
    content: string
    createdAt?: Date | string
    reviewId: number
  }

  export type ReviewCommentCreateOrConnectWithoutUserInput = {
    where: ReviewCommentWhereUniqueInput
    create: XOR<ReviewCommentCreateWithoutUserInput, ReviewCommentUncheckedCreateWithoutUserInput>
  }

  export type ReviewCommentCreateManyUserInputEnvelope = {
    data: ReviewCommentCreateManyUserInput | ReviewCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GameUserCreateWithoutUserInput = {
    progress?: $Enums.ProgressStatus
    game: GameCreateNestedOneWithoutUsersInput
  }

  export type GameUserUncheckedCreateWithoutUserInput = {
    id?: number
    gameId: number
    progress?: $Enums.ProgressStatus
  }

  export type GameUserCreateOrConnectWithoutUserInput = {
    where: GameUserWhereUniqueInput
    create: XOR<GameUserCreateWithoutUserInput, GameUserUncheckedCreateWithoutUserInput>
  }

  export type GameUserCreateManyUserInputEnvelope = {
    data: GameUserCreateManyUserInput | GameUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ImageUpsertWithoutUserInput = {
    update: XOR<ImageUpdateWithoutUserInput, ImageUncheckedUpdateWithoutUserInput>
    create: XOR<ImageCreateWithoutUserInput, ImageUncheckedCreateWithoutUserInput>
    where?: ImageWhereInput
  }

  export type ImageUpdateToOneWithWhereWithoutUserInput = {
    where?: ImageWhereInput
    data: XOR<ImageUpdateWithoutUserInput, ImageUncheckedUpdateWithoutUserInput>
  }

  export type ImageUpdateWithoutUserInput = {
    url?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneWithoutUploadedImagesNestedInput
    games?: GameUpdateManyWithoutCoverImageNestedInput
  }

  export type ImageUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: NullableIntFieldUpdateOperationsInput | number | null
    games?: GameUncheckedUpdateManyWithoutCoverImageNestedInput
  }

  export type EmailChangeUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailChangeWhereUniqueInput
    update: XOR<EmailChangeUpdateWithoutUserInput, EmailChangeUncheckedUpdateWithoutUserInput>
    create: XOR<EmailChangeCreateWithoutUserInput, EmailChangeUncheckedCreateWithoutUserInput>
  }

  export type EmailChangeUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailChangeWhereUniqueInput
    data: XOR<EmailChangeUpdateWithoutUserInput, EmailChangeUncheckedUpdateWithoutUserInput>
  }

  export type EmailChangeUpdateManyWithWhereWithoutUserInput = {
    where: EmailChangeScalarWhereInput
    data: XOR<EmailChangeUpdateManyMutationInput, EmailChangeUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailChangeScalarWhereInput = {
    AND?: EmailChangeScalarWhereInput | EmailChangeScalarWhereInput[]
    OR?: EmailChangeScalarWhereInput[]
    NOT?: EmailChangeScalarWhereInput | EmailChangeScalarWhereInput[]
    id?: IntFilter<"EmailChange"> | number
    userId?: IntFilter<"EmailChange"> | number
    newEmail?: StringFilter<"EmailChange"> | string
    token?: StringFilter<"EmailChange"> | string
    createdAt?: DateTimeFilter<"EmailChange"> | Date | string
  }

  export type EmailVerificationUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailVerificationWhereUniqueInput
    update: XOR<EmailVerificationUpdateWithoutUserInput, EmailVerificationUncheckedUpdateWithoutUserInput>
    create: XOR<EmailVerificationCreateWithoutUserInput, EmailVerificationUncheckedCreateWithoutUserInput>
  }

  export type EmailVerificationUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailVerificationWhereUniqueInput
    data: XOR<EmailVerificationUpdateWithoutUserInput, EmailVerificationUncheckedUpdateWithoutUserInput>
  }

  export type EmailVerificationUpdateManyWithWhereWithoutUserInput = {
    where: EmailVerificationScalarWhereInput
    data: XOR<EmailVerificationUpdateManyMutationInput, EmailVerificationUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailVerificationScalarWhereInput = {
    AND?: EmailVerificationScalarWhereInput | EmailVerificationScalarWhereInput[]
    OR?: EmailVerificationScalarWhereInput[]
    NOT?: EmailVerificationScalarWhereInput | EmailVerificationScalarWhereInput[]
    id?: IntFilter<"EmailVerification"> | number
    userId?: IntFilter<"EmailVerification"> | number
    token?: StringFilter<"EmailVerification"> | string
    createdAt?: DateTimeFilter<"EmailVerification"> | Date | string
    expiresAt?: DateTimeFilter<"EmailVerification"> | Date | string
  }

  export type PasswordResetUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetWhereUniqueInput
    update: XOR<PasswordResetUpdateWithoutUserInput, PasswordResetUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetWhereUniqueInput
    data: XOR<PasswordResetUpdateWithoutUserInput, PasswordResetUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetScalarWhereInput
    data: XOR<PasswordResetUpdateManyMutationInput, PasswordResetUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetScalarWhereInput = {
    AND?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
    OR?: PasswordResetScalarWhereInput[]
    NOT?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
    id?: IntFilter<"PasswordReset"> | number
    userId?: IntFilter<"PasswordReset"> | number
    token?: StringFilter<"PasswordReset"> | string
    createdAt?: DateTimeFilter<"PasswordReset"> | Date | string
    expiresAt?: DateTimeFilter<"PasswordReset"> | Date | string
  }

  export type GameUpsertWithWhereUniqueWithoutUserInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutUserInput, GameUncheckedUpdateWithoutUserInput>
    create: XOR<GameCreateWithoutUserInput, GameUncheckedCreateWithoutUserInput>
  }

  export type GameUpdateWithWhereUniqueWithoutUserInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutUserInput, GameUncheckedUpdateWithoutUserInput>
  }

  export type GameUpdateManyWithWhereWithoutUserInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutUserInput>
  }

  export type GameScalarWhereInput = {
    AND?: GameScalarWhereInput | GameScalarWhereInput[]
    OR?: GameScalarWhereInput[]
    NOT?: GameScalarWhereInput | GameScalarWhereInput[]
    id?: IntFilter<"Game"> | number
    title?: StringFilter<"Game"> | string
    description?: StringNullableFilter<"Game"> | string | null
    releaseDate?: DateTimeNullableFilter<"Game"> | Date | string | null
    coverImageId?: IntNullableFilter<"Game"> | number | null
    userId?: IntNullableFilter<"Game"> | number | null
  }

  export type GameUpsertWithWhereUniqueWithoutFavouritedByInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutFavouritedByInput, GameUncheckedUpdateWithoutFavouritedByInput>
    create: XOR<GameCreateWithoutFavouritedByInput, GameUncheckedCreateWithoutFavouritedByInput>
  }

  export type GameUpdateWithWhereUniqueWithoutFavouritedByInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutFavouritedByInput, GameUncheckedUpdateWithoutFavouritedByInput>
  }

  export type GameUpdateManyWithWhereWithoutFavouritedByInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutFavouritedByInput>
  }

  export type FriendshipUpsertWithWhereUniqueWithoutSenderInput = {
    where: FriendshipWhereUniqueInput
    update: XOR<FriendshipUpdateWithoutSenderInput, FriendshipUncheckedUpdateWithoutSenderInput>
    create: XOR<FriendshipCreateWithoutSenderInput, FriendshipUncheckedCreateWithoutSenderInput>
  }

  export type FriendshipUpdateWithWhereUniqueWithoutSenderInput = {
    where: FriendshipWhereUniqueInput
    data: XOR<FriendshipUpdateWithoutSenderInput, FriendshipUncheckedUpdateWithoutSenderInput>
  }

  export type FriendshipUpdateManyWithWhereWithoutSenderInput = {
    where: FriendshipScalarWhereInput
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyWithoutSenderInput>
  }

  export type FriendshipScalarWhereInput = {
    AND?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
    OR?: FriendshipScalarWhereInput[]
    NOT?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
    id?: IntFilter<"Friendship"> | number
    senderId?: IntFilter<"Friendship"> | number
    receiverId?: IntFilter<"Friendship"> | number
    status?: EnumFriendshipStatusFilter<"Friendship"> | $Enums.FriendshipStatus
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
  }

  export type FriendshipUpsertWithWhereUniqueWithoutReceiverInput = {
    where: FriendshipWhereUniqueInput
    update: XOR<FriendshipUpdateWithoutReceiverInput, FriendshipUncheckedUpdateWithoutReceiverInput>
    create: XOR<FriendshipCreateWithoutReceiverInput, FriendshipUncheckedCreateWithoutReceiverInput>
  }

  export type FriendshipUpdateWithWhereUniqueWithoutReceiverInput = {
    where: FriendshipWhereUniqueInput
    data: XOR<FriendshipUpdateWithoutReceiverInput, FriendshipUncheckedUpdateWithoutReceiverInput>
  }

  export type FriendshipUpdateManyWithWhereWithoutReceiverInput = {
    where: FriendshipScalarWhereInput
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyWithoutReceiverInput>
  }

  export type UserGroupUpsertWithWhereUniqueWithoutUsersInput = {
    where: UserGroupWhereUniqueInput
    update: XOR<UserGroupUpdateWithoutUsersInput, UserGroupUncheckedUpdateWithoutUsersInput>
    create: XOR<UserGroupCreateWithoutUsersInput, UserGroupUncheckedCreateWithoutUsersInput>
  }

  export type UserGroupUpdateWithWhereUniqueWithoutUsersInput = {
    where: UserGroupWhereUniqueInput
    data: XOR<UserGroupUpdateWithoutUsersInput, UserGroupUncheckedUpdateWithoutUsersInput>
  }

  export type UserGroupUpdateManyWithWhereWithoutUsersInput = {
    where: UserGroupScalarWhereInput
    data: XOR<UserGroupUpdateManyMutationInput, UserGroupUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserGroupScalarWhereInput = {
    AND?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
    OR?: UserGroupScalarWhereInput[]
    NOT?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
    id?: IntFilter<"UserGroup"> | number
    name?: StringFilter<"UserGroup"> | string
    role?: StringFilter<"UserGroup"> | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: IntFilter<"Review"> | number
    rating?: IntFilter<"Review"> | number
    content?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    userId?: IntFilter<"Review"> | number
    gameId?: IntFilter<"Review"> | number
  }

  export type ReviewUserTagUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewUserTagWhereUniqueInput
    update: XOR<ReviewUserTagUpdateWithoutUserInput, ReviewUserTagUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewUserTagCreateWithoutUserInput, ReviewUserTagUncheckedCreateWithoutUserInput>
  }

  export type ReviewUserTagUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewUserTagWhereUniqueInput
    data: XOR<ReviewUserTagUpdateWithoutUserInput, ReviewUserTagUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUserTagUpdateManyWithWhereWithoutUserInput = {
    where: ReviewUserTagScalarWhereInput
    data: XOR<ReviewUserTagUpdateManyMutationInput, ReviewUserTagUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewUserTagScalarWhereInput = {
    AND?: ReviewUserTagScalarWhereInput | ReviewUserTagScalarWhereInput[]
    OR?: ReviewUserTagScalarWhereInput[]
    NOT?: ReviewUserTagScalarWhereInput | ReviewUserTagScalarWhereInput[]
    id?: IntFilter<"ReviewUserTag"> | number
    label?: StringFilter<"ReviewUserTag"> | string
    reviewId?: IntFilter<"ReviewUserTag"> | number
    userId?: IntFilter<"ReviewUserTag"> | number
  }

  export type UserTagUpsertWithWhereUniqueWithoutUsersInput = {
    where: UserTagWhereUniqueInput
    update: XOR<UserTagUpdateWithoutUsersInput, UserTagUncheckedUpdateWithoutUsersInput>
    create: XOR<UserTagCreateWithoutUsersInput, UserTagUncheckedCreateWithoutUsersInput>
  }

  export type UserTagUpdateWithWhereUniqueWithoutUsersInput = {
    where: UserTagWhereUniqueInput
    data: XOR<UserTagUpdateWithoutUsersInput, UserTagUncheckedUpdateWithoutUsersInput>
  }

  export type UserTagUpdateManyWithWhereWithoutUsersInput = {
    where: UserTagScalarWhereInput
    data: XOR<UserTagUpdateManyMutationInput, UserTagUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserTagScalarWhereInput = {
    AND?: UserTagScalarWhereInput | UserTagScalarWhereInput[]
    OR?: UserTagScalarWhereInput[]
    NOT?: UserTagScalarWhereInput | UserTagScalarWhereInput[]
    id?: IntFilter<"UserTag"> | number
    label?: StringFilter<"UserTag"> | string
  }

  export type GameStatusUpsertWithWhereUniqueWithoutUserInput = {
    where: GameStatusWhereUniqueInput
    update: XOR<GameStatusUpdateWithoutUserInput, GameStatusUncheckedUpdateWithoutUserInput>
    create: XOR<GameStatusCreateWithoutUserInput, GameStatusUncheckedCreateWithoutUserInput>
  }

  export type GameStatusUpdateWithWhereUniqueWithoutUserInput = {
    where: GameStatusWhereUniqueInput
    data: XOR<GameStatusUpdateWithoutUserInput, GameStatusUncheckedUpdateWithoutUserInput>
  }

  export type GameStatusUpdateManyWithWhereWithoutUserInput = {
    where: GameStatusScalarWhereInput
    data: XOR<GameStatusUpdateManyMutationInput, GameStatusUncheckedUpdateManyWithoutUserInput>
  }

  export type GameStatusScalarWhereInput = {
    AND?: GameStatusScalarWhereInput | GameStatusScalarWhereInput[]
    OR?: GameStatusScalarWhereInput[]
    NOT?: GameStatusScalarWhereInput | GameStatusScalarWhereInput[]
    id?: IntFilter<"GameStatus"> | number
    type?: EnumGameStatusTypeFilter<"GameStatus"> | $Enums.GameStatusType
    userId?: IntFilter<"GameStatus"> | number
  }

  export type AchievementUnlockUpsertWithWhereUniqueWithoutUserInput = {
    where: AchievementUnlockWhereUniqueInput
    update: XOR<AchievementUnlockUpdateWithoutUserInput, AchievementUnlockUncheckedUpdateWithoutUserInput>
    create: XOR<AchievementUnlockCreateWithoutUserInput, AchievementUnlockUncheckedCreateWithoutUserInput>
  }

  export type AchievementUnlockUpdateWithWhereUniqueWithoutUserInput = {
    where: AchievementUnlockWhereUniqueInput
    data: XOR<AchievementUnlockUpdateWithoutUserInput, AchievementUnlockUncheckedUpdateWithoutUserInput>
  }

  export type AchievementUnlockUpdateManyWithWhereWithoutUserInput = {
    where: AchievementUnlockScalarWhereInput
    data: XOR<AchievementUnlockUpdateManyMutationInput, AchievementUnlockUncheckedUpdateManyWithoutUserInput>
  }

  export type AchievementUnlockScalarWhereInput = {
    AND?: AchievementUnlockScalarWhereInput | AchievementUnlockScalarWhereInput[]
    OR?: AchievementUnlockScalarWhereInput[]
    NOT?: AchievementUnlockScalarWhereInput | AchievementUnlockScalarWhereInput[]
    id?: IntFilter<"AchievementUnlock"> | number
    unlockedAt?: DateTimeFilter<"AchievementUnlock"> | Date | string
    userId?: IntFilter<"AchievementUnlock"> | number
    achievementId?: IntFilter<"AchievementUnlock"> | number
  }

  export type ImageUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutUploadedByInput, ImageUncheckedUpdateWithoutUploadedByInput>
    create: XOR<ImageCreateWithoutUploadedByInput, ImageUncheckedCreateWithoutUploadedByInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutUploadedByInput, ImageUncheckedUpdateWithoutUploadedByInput>
  }

  export type ImageUpdateManyWithWhereWithoutUploadedByInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type ImageScalarWhereInput = {
    AND?: ImageScalarWhereInput | ImageScalarWhereInput[]
    OR?: ImageScalarWhereInput[]
    NOT?: ImageScalarWhereInput | ImageScalarWhereInput[]
    id?: IntFilter<"Image"> | number
    url?: StringFilter<"Image"> | string
    checksum?: StringFilter<"Image"> | string
    width?: IntNullableFilter<"Image"> | number | null
    height?: IntNullableFilter<"Image"> | number | null
    uploadedAt?: DateTimeFilter<"Image"> | Date | string
    uploadedById?: IntNullableFilter<"Image"> | number | null
  }

  export type ReviewCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewCommentWhereUniqueInput
    update: XOR<ReviewCommentUpdateWithoutUserInput, ReviewCommentUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCommentCreateWithoutUserInput, ReviewCommentUncheckedCreateWithoutUserInput>
  }

  export type ReviewCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewCommentWhereUniqueInput
    data: XOR<ReviewCommentUpdateWithoutUserInput, ReviewCommentUncheckedUpdateWithoutUserInput>
  }

  export type ReviewCommentUpdateManyWithWhereWithoutUserInput = {
    where: ReviewCommentScalarWhereInput
    data: XOR<ReviewCommentUpdateManyMutationInput, ReviewCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewCommentScalarWhereInput = {
    AND?: ReviewCommentScalarWhereInput | ReviewCommentScalarWhereInput[]
    OR?: ReviewCommentScalarWhereInput[]
    NOT?: ReviewCommentScalarWhereInput | ReviewCommentScalarWhereInput[]
    id?: IntFilter<"ReviewComment"> | number
    content?: StringFilter<"ReviewComment"> | string
    createdAt?: DateTimeFilter<"ReviewComment"> | Date | string
    reviewId?: IntFilter<"ReviewComment"> | number
    userId?: IntFilter<"ReviewComment"> | number
  }

  export type GameUserUpsertWithWhereUniqueWithoutUserInput = {
    where: GameUserWhereUniqueInput
    update: XOR<GameUserUpdateWithoutUserInput, GameUserUncheckedUpdateWithoutUserInput>
    create: XOR<GameUserCreateWithoutUserInput, GameUserUncheckedCreateWithoutUserInput>
  }

  export type GameUserUpdateWithWhereUniqueWithoutUserInput = {
    where: GameUserWhereUniqueInput
    data: XOR<GameUserUpdateWithoutUserInput, GameUserUncheckedUpdateWithoutUserInput>
  }

  export type GameUserUpdateManyWithWhereWithoutUserInput = {
    where: GameUserScalarWhereInput
    data: XOR<GameUserUpdateManyMutationInput, GameUserUncheckedUpdateManyWithoutUserInput>
  }

  export type GameUserScalarWhereInput = {
    AND?: GameUserScalarWhereInput | GameUserScalarWhereInput[]
    OR?: GameUserScalarWhereInput[]
    NOT?: GameUserScalarWhereInput | GameUserScalarWhereInput[]
    id?: IntFilter<"GameUser"> | number
    userId?: IntFilter<"GameUser"> | number
    gameId?: IntFilter<"GameUser"> | number
    progress?: EnumProgressStatusFilter<"GameUser"> | $Enums.ProgressStatus
  }

  export type ImageCreateWithoutGamesInput = {
    url: string
    checksum: string
    width?: number | null
    height?: number | null
    uploadedAt?: Date | string
    uploadedBy?: UserCreateNestedOneWithoutUploadedImagesInput
    User?: UserCreateNestedManyWithoutProfilePictureInput
  }

  export type ImageUncheckedCreateWithoutGamesInput = {
    id?: number
    url: string
    checksum: string
    width?: number | null
    height?: number | null
    uploadedAt?: Date | string
    uploadedById?: number | null
    User?: UserUncheckedCreateNestedManyWithoutProfilePictureInput
  }

  export type ImageCreateOrConnectWithoutGamesInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutGamesInput, ImageUncheckedCreateWithoutGamesInput>
  }

  export type ReviewCreateWithoutGameInput = {
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    tags?: ReviewUserTagCreateNestedManyWithoutReviewInput
    comments?: ReviewCommentCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutGameInput = {
    id?: number
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    tags?: ReviewUserTagUncheckedCreateNestedManyWithoutReviewInput
    comments?: ReviewCommentUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutGameInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutGameInput, ReviewUncheckedCreateWithoutGameInput>
  }

  export type ReviewCreateManyGameInputEnvelope = {
    data: ReviewCreateManyGameInput | ReviewCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type GameUserCreateWithoutGameInput = {
    progress?: $Enums.ProgressStatus
    user: UserCreateNestedOneWithoutGameUserInput
  }

  export type GameUserUncheckedCreateWithoutGameInput = {
    id?: number
    userId: number
    progress?: $Enums.ProgressStatus
  }

  export type GameUserCreateOrConnectWithoutGameInput = {
    where: GameUserWhereUniqueInput
    create: XOR<GameUserCreateWithoutGameInput, GameUserUncheckedCreateWithoutGameInput>
  }

  export type GameUserCreateManyGameInputEnvelope = {
    data: GameUserCreateManyGameInput | GameUserCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutFavouritesInput = {
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    profilePicture?: ImageCreateNestedOneWithoutUserInput
    emailChanges?: EmailChangeCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    playedGames?: GameCreateNestedManyWithoutUserInput
    sentFriendRequests?: FriendshipCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipCreateNestedManyWithoutReceiverInput
    groups?: UserGroupCreateNestedManyWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagCreateNestedManyWithoutUserInput
    userTags?: UserTagCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockCreateNestedManyWithoutUserInput
    uploadedImages?: ImageCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentCreateNestedManyWithoutUserInput
    GameUser?: GameUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFavouritesInput = {
    id?: number
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    profilePictureId?: number | null
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    emailChanges?: EmailChangeUncheckedCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    playedGames?: GameUncheckedCreateNestedManyWithoutUserInput
    sentFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutReceiverInput
    groups?: UserGroupUncheckedCreateNestedManyWithoutUsersInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagUncheckedCreateNestedManyWithoutUserInput
    userTags?: UserTagUncheckedCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutUserInput
    uploadedImages?: ImageUncheckedCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    GameUser?: GameUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFavouritesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavouritesInput, UserUncheckedCreateWithoutFavouritesInput>
  }

  export type GenreCreateWithoutGamesInput = {
    name: string
  }

  export type GenreUncheckedCreateWithoutGamesInput = {
    id?: number
    name: string
  }

  export type GenreCreateOrConnectWithoutGamesInput = {
    where: GenreWhereUniqueInput
    create: XOR<GenreCreateWithoutGamesInput, GenreUncheckedCreateWithoutGamesInput>
  }

  export type PlatformCreateWithoutGamesInput = {
    name: string
  }

  export type PlatformUncheckedCreateWithoutGamesInput = {
    id?: number
    name: string
  }

  export type PlatformCreateOrConnectWithoutGamesInput = {
    where: PlatformWhereUniqueInput
    create: XOR<PlatformCreateWithoutGamesInput, PlatformUncheckedCreateWithoutGamesInput>
  }

  export type GameTagCreateWithoutGamesInput = {
    label: string
  }

  export type GameTagUncheckedCreateWithoutGamesInput = {
    id?: number
    label: string
  }

  export type GameTagCreateOrConnectWithoutGamesInput = {
    where: GameTagWhereUniqueInput
    create: XOR<GameTagCreateWithoutGamesInput, GameTagUncheckedCreateWithoutGamesInput>
  }

  export type GameStatusCreateWithoutGamesInput = {
    type: $Enums.GameStatusType
    user: UserCreateNestedOneWithoutGameStatusesInput
  }

  export type GameStatusUncheckedCreateWithoutGamesInput = {
    id?: number
    type: $Enums.GameStatusType
    userId: number
  }

  export type GameStatusCreateOrConnectWithoutGamesInput = {
    where: GameStatusWhereUniqueInput
    create: XOR<GameStatusCreateWithoutGamesInput, GameStatusUncheckedCreateWithoutGamesInput>
  }

  export type DeveloperCreateWithoutGamesInput = {
    name: string
  }

  export type DeveloperUncheckedCreateWithoutGamesInput = {
    id?: number
    name: string
  }

  export type DeveloperCreateOrConnectWithoutGamesInput = {
    where: DeveloperWhereUniqueInput
    create: XOR<DeveloperCreateWithoutGamesInput, DeveloperUncheckedCreateWithoutGamesInput>
  }

  export type PublisherCreateWithoutGamesInput = {
    name: string
  }

  export type PublisherUncheckedCreateWithoutGamesInput = {
    id?: number
    name: string
  }

  export type PublisherCreateOrConnectWithoutGamesInput = {
    where: PublisherWhereUniqueInput
    create: XOR<PublisherCreateWithoutGamesInput, PublisherUncheckedCreateWithoutGamesInput>
  }

  export type GameImageCreateWithoutGameInput = {
    url: string
  }

  export type GameImageUncheckedCreateWithoutGameInput = {
    id?: number
    url: string
  }

  export type GameImageCreateOrConnectWithoutGameInput = {
    where: GameImageWhereUniqueInput
    create: XOR<GameImageCreateWithoutGameInput, GameImageUncheckedCreateWithoutGameInput>
  }

  export type GameImageCreateManyGameInputEnvelope = {
    data: GameImageCreateManyGameInput | GameImageCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type AchievementCreateWithoutGameInput = {
    title: string
    description?: string | null
    unlocks?: AchievementUnlockCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUncheckedCreateWithoutGameInput = {
    id?: number
    title: string
    description?: string | null
    unlocks?: AchievementUnlockUncheckedCreateNestedManyWithoutAchievementInput
  }

  export type AchievementCreateOrConnectWithoutGameInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutGameInput, AchievementUncheckedCreateWithoutGameInput>
  }

  export type AchievementCreateManyGameInputEnvelope = {
    data: AchievementCreateManyGameInput | AchievementCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPlayedGamesInput = {
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    profilePicture?: ImageCreateNestedOneWithoutUserInput
    emailChanges?: EmailChangeCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    favourites?: GameCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipCreateNestedManyWithoutReceiverInput
    groups?: UserGroupCreateNestedManyWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagCreateNestedManyWithoutUserInput
    userTags?: UserTagCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockCreateNestedManyWithoutUserInput
    uploadedImages?: ImageCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentCreateNestedManyWithoutUserInput
    GameUser?: GameUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlayedGamesInput = {
    id?: number
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    profilePictureId?: number | null
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    emailChanges?: EmailChangeUncheckedCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    favourites?: GameUncheckedCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutReceiverInput
    groups?: UserGroupUncheckedCreateNestedManyWithoutUsersInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagUncheckedCreateNestedManyWithoutUserInput
    userTags?: UserTagUncheckedCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutUserInput
    uploadedImages?: ImageUncheckedCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    GameUser?: GameUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlayedGamesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlayedGamesInput, UserUncheckedCreateWithoutPlayedGamesInput>
  }

  export type ImageUpsertWithoutGamesInput = {
    update: XOR<ImageUpdateWithoutGamesInput, ImageUncheckedUpdateWithoutGamesInput>
    create: XOR<ImageCreateWithoutGamesInput, ImageUncheckedCreateWithoutGamesInput>
    where?: ImageWhereInput
  }

  export type ImageUpdateToOneWithWhereWithoutGamesInput = {
    where?: ImageWhereInput
    data: XOR<ImageUpdateWithoutGamesInput, ImageUncheckedUpdateWithoutGamesInput>
  }

  export type ImageUpdateWithoutGamesInput = {
    url?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneWithoutUploadedImagesNestedInput
    User?: UserUpdateManyWithoutProfilePictureNestedInput
  }

  export type ImageUncheckedUpdateWithoutGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: NullableIntFieldUpdateOperationsInput | number | null
    User?: UserUncheckedUpdateManyWithoutProfilePictureNestedInput
  }

  export type ReviewUpsertWithWhereUniqueWithoutGameInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutGameInput, ReviewUncheckedUpdateWithoutGameInput>
    create: XOR<ReviewCreateWithoutGameInput, ReviewUncheckedCreateWithoutGameInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutGameInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutGameInput, ReviewUncheckedUpdateWithoutGameInput>
  }

  export type ReviewUpdateManyWithWhereWithoutGameInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutGameInput>
  }

  export type GameUserUpsertWithWhereUniqueWithoutGameInput = {
    where: GameUserWhereUniqueInput
    update: XOR<GameUserUpdateWithoutGameInput, GameUserUncheckedUpdateWithoutGameInput>
    create: XOR<GameUserCreateWithoutGameInput, GameUserUncheckedCreateWithoutGameInput>
  }

  export type GameUserUpdateWithWhereUniqueWithoutGameInput = {
    where: GameUserWhereUniqueInput
    data: XOR<GameUserUpdateWithoutGameInput, GameUserUncheckedUpdateWithoutGameInput>
  }

  export type GameUserUpdateManyWithWhereWithoutGameInput = {
    where: GameUserScalarWhereInput
    data: XOR<GameUserUpdateManyMutationInput, GameUserUncheckedUpdateManyWithoutGameInput>
  }

  export type UserUpsertWithWhereUniqueWithoutFavouritesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutFavouritesInput, UserUncheckedUpdateWithoutFavouritesInput>
    create: XOR<UserCreateWithoutFavouritesInput, UserUncheckedCreateWithoutFavouritesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutFavouritesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutFavouritesInput, UserUncheckedUpdateWithoutFavouritesInput>
  }

  export type UserUpdateManyWithWhereWithoutFavouritesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutFavouritesInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    googleId?: StringNullableFilter<"User"> | string | null
    displayName?: StringFilter<"User"> | string
    profilePictureId?: IntNullableFilter<"User"> | number | null
    emailVerified?: BoolFilter<"User"> | boolean
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    registrationDate?: DateTimeFilter<"User"> | Date | string
  }

  export type GenreUpsertWithWhereUniqueWithoutGamesInput = {
    where: GenreWhereUniqueInput
    update: XOR<GenreUpdateWithoutGamesInput, GenreUncheckedUpdateWithoutGamesInput>
    create: XOR<GenreCreateWithoutGamesInput, GenreUncheckedCreateWithoutGamesInput>
  }

  export type GenreUpdateWithWhereUniqueWithoutGamesInput = {
    where: GenreWhereUniqueInput
    data: XOR<GenreUpdateWithoutGamesInput, GenreUncheckedUpdateWithoutGamesInput>
  }

  export type GenreUpdateManyWithWhereWithoutGamesInput = {
    where: GenreScalarWhereInput
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyWithoutGamesInput>
  }

  export type GenreScalarWhereInput = {
    AND?: GenreScalarWhereInput | GenreScalarWhereInput[]
    OR?: GenreScalarWhereInput[]
    NOT?: GenreScalarWhereInput | GenreScalarWhereInput[]
    id?: IntFilter<"Genre"> | number
    name?: StringFilter<"Genre"> | string
  }

  export type PlatformUpsertWithWhereUniqueWithoutGamesInput = {
    where: PlatformWhereUniqueInput
    update: XOR<PlatformUpdateWithoutGamesInput, PlatformUncheckedUpdateWithoutGamesInput>
    create: XOR<PlatformCreateWithoutGamesInput, PlatformUncheckedCreateWithoutGamesInput>
  }

  export type PlatformUpdateWithWhereUniqueWithoutGamesInput = {
    where: PlatformWhereUniqueInput
    data: XOR<PlatformUpdateWithoutGamesInput, PlatformUncheckedUpdateWithoutGamesInput>
  }

  export type PlatformUpdateManyWithWhereWithoutGamesInput = {
    where: PlatformScalarWhereInput
    data: XOR<PlatformUpdateManyMutationInput, PlatformUncheckedUpdateManyWithoutGamesInput>
  }

  export type PlatformScalarWhereInput = {
    AND?: PlatformScalarWhereInput | PlatformScalarWhereInput[]
    OR?: PlatformScalarWhereInput[]
    NOT?: PlatformScalarWhereInput | PlatformScalarWhereInput[]
    id?: IntFilter<"Platform"> | number
    name?: StringFilter<"Platform"> | string
  }

  export type GameTagUpsertWithWhereUniqueWithoutGamesInput = {
    where: GameTagWhereUniqueInput
    update: XOR<GameTagUpdateWithoutGamesInput, GameTagUncheckedUpdateWithoutGamesInput>
    create: XOR<GameTagCreateWithoutGamesInput, GameTagUncheckedCreateWithoutGamesInput>
  }

  export type GameTagUpdateWithWhereUniqueWithoutGamesInput = {
    where: GameTagWhereUniqueInput
    data: XOR<GameTagUpdateWithoutGamesInput, GameTagUncheckedUpdateWithoutGamesInput>
  }

  export type GameTagUpdateManyWithWhereWithoutGamesInput = {
    where: GameTagScalarWhereInput
    data: XOR<GameTagUpdateManyMutationInput, GameTagUncheckedUpdateManyWithoutGamesInput>
  }

  export type GameTagScalarWhereInput = {
    AND?: GameTagScalarWhereInput | GameTagScalarWhereInput[]
    OR?: GameTagScalarWhereInput[]
    NOT?: GameTagScalarWhereInput | GameTagScalarWhereInput[]
    id?: IntFilter<"GameTag"> | number
    label?: StringFilter<"GameTag"> | string
  }

  export type GameStatusUpsertWithWhereUniqueWithoutGamesInput = {
    where: GameStatusWhereUniqueInput
    update: XOR<GameStatusUpdateWithoutGamesInput, GameStatusUncheckedUpdateWithoutGamesInput>
    create: XOR<GameStatusCreateWithoutGamesInput, GameStatusUncheckedCreateWithoutGamesInput>
  }

  export type GameStatusUpdateWithWhereUniqueWithoutGamesInput = {
    where: GameStatusWhereUniqueInput
    data: XOR<GameStatusUpdateWithoutGamesInput, GameStatusUncheckedUpdateWithoutGamesInput>
  }

  export type GameStatusUpdateManyWithWhereWithoutGamesInput = {
    where: GameStatusScalarWhereInput
    data: XOR<GameStatusUpdateManyMutationInput, GameStatusUncheckedUpdateManyWithoutGamesInput>
  }

  export type DeveloperUpsertWithWhereUniqueWithoutGamesInput = {
    where: DeveloperWhereUniqueInput
    update: XOR<DeveloperUpdateWithoutGamesInput, DeveloperUncheckedUpdateWithoutGamesInput>
    create: XOR<DeveloperCreateWithoutGamesInput, DeveloperUncheckedCreateWithoutGamesInput>
  }

  export type DeveloperUpdateWithWhereUniqueWithoutGamesInput = {
    where: DeveloperWhereUniqueInput
    data: XOR<DeveloperUpdateWithoutGamesInput, DeveloperUncheckedUpdateWithoutGamesInput>
  }

  export type DeveloperUpdateManyWithWhereWithoutGamesInput = {
    where: DeveloperScalarWhereInput
    data: XOR<DeveloperUpdateManyMutationInput, DeveloperUncheckedUpdateManyWithoutGamesInput>
  }

  export type DeveloperScalarWhereInput = {
    AND?: DeveloperScalarWhereInput | DeveloperScalarWhereInput[]
    OR?: DeveloperScalarWhereInput[]
    NOT?: DeveloperScalarWhereInput | DeveloperScalarWhereInput[]
    id?: IntFilter<"Developer"> | number
    name?: StringFilter<"Developer"> | string
  }

  export type PublisherUpsertWithWhereUniqueWithoutGamesInput = {
    where: PublisherWhereUniqueInput
    update: XOR<PublisherUpdateWithoutGamesInput, PublisherUncheckedUpdateWithoutGamesInput>
    create: XOR<PublisherCreateWithoutGamesInput, PublisherUncheckedCreateWithoutGamesInput>
  }

  export type PublisherUpdateWithWhereUniqueWithoutGamesInput = {
    where: PublisherWhereUniqueInput
    data: XOR<PublisherUpdateWithoutGamesInput, PublisherUncheckedUpdateWithoutGamesInput>
  }

  export type PublisherUpdateManyWithWhereWithoutGamesInput = {
    where: PublisherScalarWhereInput
    data: XOR<PublisherUpdateManyMutationInput, PublisherUncheckedUpdateManyWithoutGamesInput>
  }

  export type PublisherScalarWhereInput = {
    AND?: PublisherScalarWhereInput | PublisherScalarWhereInput[]
    OR?: PublisherScalarWhereInput[]
    NOT?: PublisherScalarWhereInput | PublisherScalarWhereInput[]
    id?: IntFilter<"Publisher"> | number
    name?: StringFilter<"Publisher"> | string
  }

  export type GameImageUpsertWithWhereUniqueWithoutGameInput = {
    where: GameImageWhereUniqueInput
    update: XOR<GameImageUpdateWithoutGameInput, GameImageUncheckedUpdateWithoutGameInput>
    create: XOR<GameImageCreateWithoutGameInput, GameImageUncheckedCreateWithoutGameInput>
  }

  export type GameImageUpdateWithWhereUniqueWithoutGameInput = {
    where: GameImageWhereUniqueInput
    data: XOR<GameImageUpdateWithoutGameInput, GameImageUncheckedUpdateWithoutGameInput>
  }

  export type GameImageUpdateManyWithWhereWithoutGameInput = {
    where: GameImageScalarWhereInput
    data: XOR<GameImageUpdateManyMutationInput, GameImageUncheckedUpdateManyWithoutGameInput>
  }

  export type GameImageScalarWhereInput = {
    AND?: GameImageScalarWhereInput | GameImageScalarWhereInput[]
    OR?: GameImageScalarWhereInput[]
    NOT?: GameImageScalarWhereInput | GameImageScalarWhereInput[]
    id?: IntFilter<"GameImage"> | number
    url?: StringFilter<"GameImage"> | string
    gameId?: IntFilter<"GameImage"> | number
  }

  export type AchievementUpsertWithWhereUniqueWithoutGameInput = {
    where: AchievementWhereUniqueInput
    update: XOR<AchievementUpdateWithoutGameInput, AchievementUncheckedUpdateWithoutGameInput>
    create: XOR<AchievementCreateWithoutGameInput, AchievementUncheckedCreateWithoutGameInput>
  }

  export type AchievementUpdateWithWhereUniqueWithoutGameInput = {
    where: AchievementWhereUniqueInput
    data: XOR<AchievementUpdateWithoutGameInput, AchievementUncheckedUpdateWithoutGameInput>
  }

  export type AchievementUpdateManyWithWhereWithoutGameInput = {
    where: AchievementScalarWhereInput
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyWithoutGameInput>
  }

  export type AchievementScalarWhereInput = {
    AND?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
    OR?: AchievementScalarWhereInput[]
    NOT?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
    id?: IntFilter<"Achievement"> | number
    title?: StringFilter<"Achievement"> | string
    description?: StringNullableFilter<"Achievement"> | string | null
    gameId?: IntFilter<"Achievement"> | number
  }

  export type UserUpsertWithoutPlayedGamesInput = {
    update: XOR<UserUpdateWithoutPlayedGamesInput, UserUncheckedUpdateWithoutPlayedGamesInput>
    create: XOR<UserCreateWithoutPlayedGamesInput, UserUncheckedCreateWithoutPlayedGamesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlayedGamesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlayedGamesInput, UserUncheckedUpdateWithoutPlayedGamesInput>
  }

  export type UserUpdateWithoutPlayedGamesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: ImageUpdateOneWithoutUserNestedInput
    emailChanges?: EmailChangeUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    favourites?: GameUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUpdateManyWithoutUserNestedInput
    userTags?: UserTagUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlayedGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    profilePictureId?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    emailChanges?: EmailChangeUncheckedUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    favourites?: GameUncheckedUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUncheckedUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUncheckedUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUncheckedUpdateManyWithoutUserNestedInput
    userTags?: UserTagUncheckedUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUncheckedUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUploadedImagesInput = {
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    profilePicture?: ImageCreateNestedOneWithoutUserInput
    emailChanges?: EmailChangeCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    playedGames?: GameCreateNestedManyWithoutUserInput
    favourites?: GameCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipCreateNestedManyWithoutReceiverInput
    groups?: UserGroupCreateNestedManyWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagCreateNestedManyWithoutUserInput
    userTags?: UserTagCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockCreateNestedManyWithoutUserInput
    ReviewComment?: ReviewCommentCreateNestedManyWithoutUserInput
    GameUser?: GameUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUploadedImagesInput = {
    id?: number
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    profilePictureId?: number | null
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    emailChanges?: EmailChangeUncheckedCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    playedGames?: GameUncheckedCreateNestedManyWithoutUserInput
    favourites?: GameUncheckedCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutReceiverInput
    groups?: UserGroupUncheckedCreateNestedManyWithoutUsersInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagUncheckedCreateNestedManyWithoutUserInput
    userTags?: UserTagUncheckedCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutUserInput
    ReviewComment?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    GameUser?: GameUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUploadedImagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedImagesInput, UserUncheckedCreateWithoutUploadedImagesInput>
  }

  export type GameCreateWithoutCoverImageInput = {
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    reviews?: ReviewCreateNestedManyWithoutGameInput
    users?: GameUserCreateNestedManyWithoutGameInput
    favouritedBy?: UserCreateNestedManyWithoutFavouritesInput
    genres?: GenreCreateNestedManyWithoutGamesInput
    platforms?: PlatformCreateNestedManyWithoutGamesInput
    tags?: GameTagCreateNestedManyWithoutGamesInput
    statuses?: GameStatusCreateNestedManyWithoutGamesInput
    developers?: DeveloperCreateNestedManyWithoutGamesInput
    publishers?: PublisherCreateNestedManyWithoutGamesInput
    images?: GameImageCreateNestedManyWithoutGameInput
    achievements?: AchievementCreateNestedManyWithoutGameInput
    User?: UserCreateNestedOneWithoutPlayedGamesInput
  }

  export type GameUncheckedCreateWithoutCoverImageInput = {
    id?: number
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    userId?: number | null
    reviews?: ReviewUncheckedCreateNestedManyWithoutGameInput
    users?: GameUserUncheckedCreateNestedManyWithoutGameInput
    favouritedBy?: UserUncheckedCreateNestedManyWithoutFavouritesInput
    genres?: GenreUncheckedCreateNestedManyWithoutGamesInput
    platforms?: PlatformUncheckedCreateNestedManyWithoutGamesInput
    tags?: GameTagUncheckedCreateNestedManyWithoutGamesInput
    statuses?: GameStatusUncheckedCreateNestedManyWithoutGamesInput
    developers?: DeveloperUncheckedCreateNestedManyWithoutGamesInput
    publishers?: PublisherUncheckedCreateNestedManyWithoutGamesInput
    images?: GameImageUncheckedCreateNestedManyWithoutGameInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutCoverImageInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutCoverImageInput, GameUncheckedCreateWithoutCoverImageInput>
  }

  export type GameCreateManyCoverImageInputEnvelope = {
    data: GameCreateManyCoverImageInput | GameCreateManyCoverImageInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutProfilePictureInput = {
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    emailChanges?: EmailChangeCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    playedGames?: GameCreateNestedManyWithoutUserInput
    favourites?: GameCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipCreateNestedManyWithoutReceiverInput
    groups?: UserGroupCreateNestedManyWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagCreateNestedManyWithoutUserInput
    userTags?: UserTagCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockCreateNestedManyWithoutUserInput
    uploadedImages?: ImageCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentCreateNestedManyWithoutUserInput
    GameUser?: GameUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfilePictureInput = {
    id?: number
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    emailChanges?: EmailChangeUncheckedCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    playedGames?: GameUncheckedCreateNestedManyWithoutUserInput
    favourites?: GameUncheckedCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutReceiverInput
    groups?: UserGroupUncheckedCreateNestedManyWithoutUsersInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagUncheckedCreateNestedManyWithoutUserInput
    userTags?: UserTagUncheckedCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutUserInput
    uploadedImages?: ImageUncheckedCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    GameUser?: GameUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfilePictureInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfilePictureInput, UserUncheckedCreateWithoutProfilePictureInput>
  }

  export type UserCreateManyProfilePictureInputEnvelope = {
    data: UserCreateManyProfilePictureInput | UserCreateManyProfilePictureInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutUploadedImagesInput = {
    update: XOR<UserUpdateWithoutUploadedImagesInput, UserUncheckedUpdateWithoutUploadedImagesInput>
    create: XOR<UserCreateWithoutUploadedImagesInput, UserUncheckedCreateWithoutUploadedImagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedImagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedImagesInput, UserUncheckedUpdateWithoutUploadedImagesInput>
  }

  export type UserUpdateWithoutUploadedImagesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: ImageUpdateOneWithoutUserNestedInput
    emailChanges?: EmailChangeUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    playedGames?: GameUpdateManyWithoutUserNestedInput
    favourites?: GameUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUpdateManyWithoutUserNestedInput
    userTags?: UserTagUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutUserNestedInput
    ReviewComment?: ReviewCommentUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    profilePictureId?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    emailChanges?: EmailChangeUncheckedUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    playedGames?: GameUncheckedUpdateManyWithoutUserNestedInput
    favourites?: GameUncheckedUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUncheckedUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUncheckedUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUncheckedUpdateManyWithoutUserNestedInput
    userTags?: UserTagUncheckedUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutUserNestedInput
    ReviewComment?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GameUpsertWithWhereUniqueWithoutCoverImageInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutCoverImageInput, GameUncheckedUpdateWithoutCoverImageInput>
    create: XOR<GameCreateWithoutCoverImageInput, GameUncheckedCreateWithoutCoverImageInput>
  }

  export type GameUpdateWithWhereUniqueWithoutCoverImageInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutCoverImageInput, GameUncheckedUpdateWithoutCoverImageInput>
  }

  export type GameUpdateManyWithWhereWithoutCoverImageInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutCoverImageInput>
  }

  export type UserUpsertWithWhereUniqueWithoutProfilePictureInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutProfilePictureInput, UserUncheckedUpdateWithoutProfilePictureInput>
    create: XOR<UserCreateWithoutProfilePictureInput, UserUncheckedCreateWithoutProfilePictureInput>
  }

  export type UserUpdateWithWhereUniqueWithoutProfilePictureInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutProfilePictureInput, UserUncheckedUpdateWithoutProfilePictureInput>
  }

  export type UserUpdateManyWithWhereWithoutProfilePictureInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutProfilePictureInput>
  }

  export type UserCreateWithoutReviewsInput = {
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    profilePicture?: ImageCreateNestedOneWithoutUserInput
    emailChanges?: EmailChangeCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    playedGames?: GameCreateNestedManyWithoutUserInput
    favourites?: GameCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipCreateNestedManyWithoutReceiverInput
    groups?: UserGroupCreateNestedManyWithoutUsersInput
    reviewTags?: ReviewUserTagCreateNestedManyWithoutUserInput
    userTags?: UserTagCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockCreateNestedManyWithoutUserInput
    uploadedImages?: ImageCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentCreateNestedManyWithoutUserInput
    GameUser?: GameUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: number
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    profilePictureId?: number | null
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    emailChanges?: EmailChangeUncheckedCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    playedGames?: GameUncheckedCreateNestedManyWithoutUserInput
    favourites?: GameUncheckedCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutReceiverInput
    groups?: UserGroupUncheckedCreateNestedManyWithoutUsersInput
    reviewTags?: ReviewUserTagUncheckedCreateNestedManyWithoutUserInput
    userTags?: UserTagUncheckedCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutUserInput
    uploadedImages?: ImageUncheckedCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    GameUser?: GameUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type GameCreateWithoutReviewsInput = {
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImage?: ImageCreateNestedOneWithoutGamesInput
    users?: GameUserCreateNestedManyWithoutGameInput
    favouritedBy?: UserCreateNestedManyWithoutFavouritesInput
    genres?: GenreCreateNestedManyWithoutGamesInput
    platforms?: PlatformCreateNestedManyWithoutGamesInput
    tags?: GameTagCreateNestedManyWithoutGamesInput
    statuses?: GameStatusCreateNestedManyWithoutGamesInput
    developers?: DeveloperCreateNestedManyWithoutGamesInput
    publishers?: PublisherCreateNestedManyWithoutGamesInput
    images?: GameImageCreateNestedManyWithoutGameInput
    achievements?: AchievementCreateNestedManyWithoutGameInput
    User?: UserCreateNestedOneWithoutPlayedGamesInput
  }

  export type GameUncheckedCreateWithoutReviewsInput = {
    id?: number
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImageId?: number | null
    userId?: number | null
    users?: GameUserUncheckedCreateNestedManyWithoutGameInput
    favouritedBy?: UserUncheckedCreateNestedManyWithoutFavouritesInput
    genres?: GenreUncheckedCreateNestedManyWithoutGamesInput
    platforms?: PlatformUncheckedCreateNestedManyWithoutGamesInput
    tags?: GameTagUncheckedCreateNestedManyWithoutGamesInput
    statuses?: GameStatusUncheckedCreateNestedManyWithoutGamesInput
    developers?: DeveloperUncheckedCreateNestedManyWithoutGamesInput
    publishers?: PublisherUncheckedCreateNestedManyWithoutGamesInput
    images?: GameImageUncheckedCreateNestedManyWithoutGameInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutReviewsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutReviewsInput, GameUncheckedCreateWithoutReviewsInput>
  }

  export type ReviewUserTagCreateWithoutReviewInput = {
    label: string
    user: UserCreateNestedOneWithoutReviewTagsInput
  }

  export type ReviewUserTagUncheckedCreateWithoutReviewInput = {
    id?: number
    label: string
    userId: number
  }

  export type ReviewUserTagCreateOrConnectWithoutReviewInput = {
    where: ReviewUserTagWhereUniqueInput
    create: XOR<ReviewUserTagCreateWithoutReviewInput, ReviewUserTagUncheckedCreateWithoutReviewInput>
  }

  export type ReviewUserTagCreateManyReviewInputEnvelope = {
    data: ReviewUserTagCreateManyReviewInput | ReviewUserTagCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCommentCreateWithoutReviewInput = {
    content: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReviewCommentInput
  }

  export type ReviewCommentUncheckedCreateWithoutReviewInput = {
    id?: number
    content: string
    createdAt?: Date | string
    userId: number
  }

  export type ReviewCommentCreateOrConnectWithoutReviewInput = {
    where: ReviewCommentWhereUniqueInput
    create: XOR<ReviewCommentCreateWithoutReviewInput, ReviewCommentUncheckedCreateWithoutReviewInput>
  }

  export type ReviewCommentCreateManyReviewInputEnvelope = {
    data: ReviewCommentCreateManyReviewInput | ReviewCommentCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: ImageUpdateOneWithoutUserNestedInput
    emailChanges?: EmailChangeUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    playedGames?: GameUpdateManyWithoutUserNestedInput
    favourites?: GameUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUpdateManyWithoutUsersNestedInput
    reviewTags?: ReviewUserTagUpdateManyWithoutUserNestedInput
    userTags?: UserTagUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    profilePictureId?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    emailChanges?: EmailChangeUncheckedUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    playedGames?: GameUncheckedUpdateManyWithoutUserNestedInput
    favourites?: GameUncheckedUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUncheckedUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUncheckedUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUncheckedUpdateManyWithoutUsersNestedInput
    reviewTags?: ReviewUserTagUncheckedUpdateManyWithoutUserNestedInput
    userTags?: UserTagUncheckedUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUncheckedUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GameUpsertWithoutReviewsInput = {
    update: XOR<GameUpdateWithoutReviewsInput, GameUncheckedUpdateWithoutReviewsInput>
    create: XOR<GameCreateWithoutReviewsInput, GameUncheckedCreateWithoutReviewsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutReviewsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutReviewsInput, GameUncheckedUpdateWithoutReviewsInput>
  }

  export type GameUpdateWithoutReviewsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: ImageUpdateOneWithoutGamesNestedInput
    users?: GameUserUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUpdateManyWithoutGamesNestedInput
    tags?: GameTagUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUpdateManyWithoutGamesNestedInput
    images?: GameImageUpdateManyWithoutGameNestedInput
    achievements?: AchievementUpdateManyWithoutGameNestedInput
    User?: UserUpdateOneWithoutPlayedGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    users?: GameUserUncheckedUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUncheckedUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUncheckedUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUncheckedUpdateManyWithoutGamesNestedInput
    tags?: GameTagUncheckedUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUncheckedUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUncheckedUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUncheckedUpdateManyWithoutGamesNestedInput
    images?: GameImageUncheckedUpdateManyWithoutGameNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutGameNestedInput
  }

  export type ReviewUserTagUpsertWithWhereUniqueWithoutReviewInput = {
    where: ReviewUserTagWhereUniqueInput
    update: XOR<ReviewUserTagUpdateWithoutReviewInput, ReviewUserTagUncheckedUpdateWithoutReviewInput>
    create: XOR<ReviewUserTagCreateWithoutReviewInput, ReviewUserTagUncheckedCreateWithoutReviewInput>
  }

  export type ReviewUserTagUpdateWithWhereUniqueWithoutReviewInput = {
    where: ReviewUserTagWhereUniqueInput
    data: XOR<ReviewUserTagUpdateWithoutReviewInput, ReviewUserTagUncheckedUpdateWithoutReviewInput>
  }

  export type ReviewUserTagUpdateManyWithWhereWithoutReviewInput = {
    where: ReviewUserTagScalarWhereInput
    data: XOR<ReviewUserTagUpdateManyMutationInput, ReviewUserTagUncheckedUpdateManyWithoutReviewInput>
  }

  export type ReviewCommentUpsertWithWhereUniqueWithoutReviewInput = {
    where: ReviewCommentWhereUniqueInput
    update: XOR<ReviewCommentUpdateWithoutReviewInput, ReviewCommentUncheckedUpdateWithoutReviewInput>
    create: XOR<ReviewCommentCreateWithoutReviewInput, ReviewCommentUncheckedCreateWithoutReviewInput>
  }

  export type ReviewCommentUpdateWithWhereUniqueWithoutReviewInput = {
    where: ReviewCommentWhereUniqueInput
    data: XOR<ReviewCommentUpdateWithoutReviewInput, ReviewCommentUncheckedUpdateWithoutReviewInput>
  }

  export type ReviewCommentUpdateManyWithWhereWithoutReviewInput = {
    where: ReviewCommentScalarWhereInput
    data: XOR<ReviewCommentUpdateManyMutationInput, ReviewCommentUncheckedUpdateManyWithoutReviewInput>
  }

  export type ReviewCreateWithoutCommentsInput = {
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    game: GameCreateNestedOneWithoutReviewsInput
    tags?: ReviewUserTagCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutCommentsInput = {
    id?: number
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    gameId: number
    tags?: ReviewUserTagUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutCommentsInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutCommentsInput, ReviewUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutReviewCommentInput = {
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    profilePicture?: ImageCreateNestedOneWithoutUserInput
    emailChanges?: EmailChangeCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    playedGames?: GameCreateNestedManyWithoutUserInput
    favourites?: GameCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipCreateNestedManyWithoutReceiverInput
    groups?: UserGroupCreateNestedManyWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagCreateNestedManyWithoutUserInput
    userTags?: UserTagCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockCreateNestedManyWithoutUserInput
    uploadedImages?: ImageCreateNestedManyWithoutUploadedByInput
    GameUser?: GameUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewCommentInput = {
    id?: number
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    profilePictureId?: number | null
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    emailChanges?: EmailChangeUncheckedCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    playedGames?: GameUncheckedCreateNestedManyWithoutUserInput
    favourites?: GameUncheckedCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutReceiverInput
    groups?: UserGroupUncheckedCreateNestedManyWithoutUsersInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagUncheckedCreateNestedManyWithoutUserInput
    userTags?: UserTagUncheckedCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutUserInput
    uploadedImages?: ImageUncheckedCreateNestedManyWithoutUploadedByInput
    GameUser?: GameUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewCommentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewCommentInput, UserUncheckedCreateWithoutReviewCommentInput>
  }

  export type ReviewUpsertWithoutCommentsInput = {
    update: XOR<ReviewUpdateWithoutCommentsInput, ReviewUncheckedUpdateWithoutCommentsInput>
    create: XOR<ReviewCreateWithoutCommentsInput, ReviewUncheckedCreateWithoutCommentsInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutCommentsInput, ReviewUncheckedUpdateWithoutCommentsInput>
  }

  export type ReviewUpdateWithoutCommentsInput = {
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    game?: GameUpdateOneRequiredWithoutReviewsNestedInput
    tags?: ReviewUserTagUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    tags?: ReviewUserTagUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type UserUpsertWithoutReviewCommentInput = {
    update: XOR<UserUpdateWithoutReviewCommentInput, UserUncheckedUpdateWithoutReviewCommentInput>
    create: XOR<UserCreateWithoutReviewCommentInput, UserUncheckedCreateWithoutReviewCommentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewCommentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewCommentInput, UserUncheckedUpdateWithoutReviewCommentInput>
  }

  export type UserUpdateWithoutReviewCommentInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: ImageUpdateOneWithoutUserNestedInput
    emailChanges?: EmailChangeUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    playedGames?: GameUpdateManyWithoutUserNestedInput
    favourites?: GameUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUpdateManyWithoutUserNestedInput
    userTags?: UserTagUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUpdateManyWithoutUploadedByNestedInput
    GameUser?: GameUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    profilePictureId?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    emailChanges?: EmailChangeUncheckedUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    playedGames?: GameUncheckedUpdateManyWithoutUserNestedInput
    favourites?: GameUncheckedUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUncheckedUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUncheckedUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUncheckedUpdateManyWithoutUserNestedInput
    userTags?: UserTagUncheckedUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUncheckedUpdateManyWithoutUploadedByNestedInput
    GameUser?: GameUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutGameUserInput = {
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    profilePicture?: ImageCreateNestedOneWithoutUserInput
    emailChanges?: EmailChangeCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    playedGames?: GameCreateNestedManyWithoutUserInput
    favourites?: GameCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipCreateNestedManyWithoutReceiverInput
    groups?: UserGroupCreateNestedManyWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagCreateNestedManyWithoutUserInput
    userTags?: UserTagCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockCreateNestedManyWithoutUserInput
    uploadedImages?: ImageCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGameUserInput = {
    id?: number
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    profilePictureId?: number | null
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    emailChanges?: EmailChangeUncheckedCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    playedGames?: GameUncheckedCreateNestedManyWithoutUserInput
    favourites?: GameUncheckedCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutReceiverInput
    groups?: UserGroupUncheckedCreateNestedManyWithoutUsersInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagUncheckedCreateNestedManyWithoutUserInput
    userTags?: UserTagUncheckedCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutUserInput
    uploadedImages?: ImageUncheckedCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGameUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGameUserInput, UserUncheckedCreateWithoutGameUserInput>
  }

  export type GameCreateWithoutUsersInput = {
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImage?: ImageCreateNestedOneWithoutGamesInput
    reviews?: ReviewCreateNestedManyWithoutGameInput
    favouritedBy?: UserCreateNestedManyWithoutFavouritesInput
    genres?: GenreCreateNestedManyWithoutGamesInput
    platforms?: PlatformCreateNestedManyWithoutGamesInput
    tags?: GameTagCreateNestedManyWithoutGamesInput
    statuses?: GameStatusCreateNestedManyWithoutGamesInput
    developers?: DeveloperCreateNestedManyWithoutGamesInput
    publishers?: PublisherCreateNestedManyWithoutGamesInput
    images?: GameImageCreateNestedManyWithoutGameInput
    achievements?: AchievementCreateNestedManyWithoutGameInput
    User?: UserCreateNestedOneWithoutPlayedGamesInput
  }

  export type GameUncheckedCreateWithoutUsersInput = {
    id?: number
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImageId?: number | null
    userId?: number | null
    reviews?: ReviewUncheckedCreateNestedManyWithoutGameInput
    favouritedBy?: UserUncheckedCreateNestedManyWithoutFavouritesInput
    genres?: GenreUncheckedCreateNestedManyWithoutGamesInput
    platforms?: PlatformUncheckedCreateNestedManyWithoutGamesInput
    tags?: GameTagUncheckedCreateNestedManyWithoutGamesInput
    statuses?: GameStatusUncheckedCreateNestedManyWithoutGamesInput
    developers?: DeveloperUncheckedCreateNestedManyWithoutGamesInput
    publishers?: PublisherUncheckedCreateNestedManyWithoutGamesInput
    images?: GameImageUncheckedCreateNestedManyWithoutGameInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutUsersInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutUsersInput, GameUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutGameUserInput = {
    update: XOR<UserUpdateWithoutGameUserInput, UserUncheckedUpdateWithoutGameUserInput>
    create: XOR<UserCreateWithoutGameUserInput, UserUncheckedCreateWithoutGameUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGameUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGameUserInput, UserUncheckedUpdateWithoutGameUserInput>
  }

  export type UserUpdateWithoutGameUserInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: ImageUpdateOneWithoutUserNestedInput
    emailChanges?: EmailChangeUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    playedGames?: GameUpdateManyWithoutUserNestedInput
    favourites?: GameUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUpdateManyWithoutUserNestedInput
    userTags?: UserTagUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGameUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    profilePictureId?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    emailChanges?: EmailChangeUncheckedUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    playedGames?: GameUncheckedUpdateManyWithoutUserNestedInput
    favourites?: GameUncheckedUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUncheckedUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUncheckedUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUncheckedUpdateManyWithoutUserNestedInput
    userTags?: UserTagUncheckedUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUncheckedUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GameUpsertWithoutUsersInput = {
    update: XOR<GameUpdateWithoutUsersInput, GameUncheckedUpdateWithoutUsersInput>
    create: XOR<GameCreateWithoutUsersInput, GameUncheckedCreateWithoutUsersInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutUsersInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutUsersInput, GameUncheckedUpdateWithoutUsersInput>
  }

  export type GameUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: ImageUpdateOneWithoutGamesNestedInput
    reviews?: ReviewUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUpdateManyWithoutGamesNestedInput
    tags?: GameTagUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUpdateManyWithoutGamesNestedInput
    images?: GameImageUpdateManyWithoutGameNestedInput
    achievements?: AchievementUpdateManyWithoutGameNestedInput
    User?: UserUpdateOneWithoutPlayedGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: ReviewUncheckedUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUncheckedUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUncheckedUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUncheckedUpdateManyWithoutGamesNestedInput
    tags?: GameTagUncheckedUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUncheckedUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUncheckedUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUncheckedUpdateManyWithoutGamesNestedInput
    images?: GameImageUncheckedUpdateManyWithoutGameNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameCreateWithoutStatusesInput = {
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImage?: ImageCreateNestedOneWithoutGamesInput
    reviews?: ReviewCreateNestedManyWithoutGameInput
    users?: GameUserCreateNestedManyWithoutGameInput
    favouritedBy?: UserCreateNestedManyWithoutFavouritesInput
    genres?: GenreCreateNestedManyWithoutGamesInput
    platforms?: PlatformCreateNestedManyWithoutGamesInput
    tags?: GameTagCreateNestedManyWithoutGamesInput
    developers?: DeveloperCreateNestedManyWithoutGamesInput
    publishers?: PublisherCreateNestedManyWithoutGamesInput
    images?: GameImageCreateNestedManyWithoutGameInput
    achievements?: AchievementCreateNestedManyWithoutGameInput
    User?: UserCreateNestedOneWithoutPlayedGamesInput
  }

  export type GameUncheckedCreateWithoutStatusesInput = {
    id?: number
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImageId?: number | null
    userId?: number | null
    reviews?: ReviewUncheckedCreateNestedManyWithoutGameInput
    users?: GameUserUncheckedCreateNestedManyWithoutGameInput
    favouritedBy?: UserUncheckedCreateNestedManyWithoutFavouritesInput
    genres?: GenreUncheckedCreateNestedManyWithoutGamesInput
    platforms?: PlatformUncheckedCreateNestedManyWithoutGamesInput
    tags?: GameTagUncheckedCreateNestedManyWithoutGamesInput
    developers?: DeveloperUncheckedCreateNestedManyWithoutGamesInput
    publishers?: PublisherUncheckedCreateNestedManyWithoutGamesInput
    images?: GameImageUncheckedCreateNestedManyWithoutGameInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutStatusesInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutStatusesInput, GameUncheckedCreateWithoutStatusesInput>
  }

  export type UserCreateWithoutGameStatusesInput = {
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    profilePicture?: ImageCreateNestedOneWithoutUserInput
    emailChanges?: EmailChangeCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    playedGames?: GameCreateNestedManyWithoutUserInput
    favourites?: GameCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipCreateNestedManyWithoutReceiverInput
    groups?: UserGroupCreateNestedManyWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagCreateNestedManyWithoutUserInput
    userTags?: UserTagCreateNestedManyWithoutUsersInput
    achievements?: AchievementUnlockCreateNestedManyWithoutUserInput
    uploadedImages?: ImageCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentCreateNestedManyWithoutUserInput
    GameUser?: GameUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGameStatusesInput = {
    id?: number
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    profilePictureId?: number | null
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    emailChanges?: EmailChangeUncheckedCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    playedGames?: GameUncheckedCreateNestedManyWithoutUserInput
    favourites?: GameUncheckedCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutReceiverInput
    groups?: UserGroupUncheckedCreateNestedManyWithoutUsersInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagUncheckedCreateNestedManyWithoutUserInput
    userTags?: UserTagUncheckedCreateNestedManyWithoutUsersInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutUserInput
    uploadedImages?: ImageUncheckedCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    GameUser?: GameUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGameStatusesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGameStatusesInput, UserUncheckedCreateWithoutGameStatusesInput>
  }

  export type GameUpsertWithWhereUniqueWithoutStatusesInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutStatusesInput, GameUncheckedUpdateWithoutStatusesInput>
    create: XOR<GameCreateWithoutStatusesInput, GameUncheckedCreateWithoutStatusesInput>
  }

  export type GameUpdateWithWhereUniqueWithoutStatusesInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutStatusesInput, GameUncheckedUpdateWithoutStatusesInput>
  }

  export type GameUpdateManyWithWhereWithoutStatusesInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutStatusesInput>
  }

  export type UserUpsertWithoutGameStatusesInput = {
    update: XOR<UserUpdateWithoutGameStatusesInput, UserUncheckedUpdateWithoutGameStatusesInput>
    create: XOR<UserCreateWithoutGameStatusesInput, UserUncheckedCreateWithoutGameStatusesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGameStatusesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGameStatusesInput, UserUncheckedUpdateWithoutGameStatusesInput>
  }

  export type UserUpdateWithoutGameStatusesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: ImageUpdateOneWithoutUserNestedInput
    emailChanges?: EmailChangeUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    playedGames?: GameUpdateManyWithoutUserNestedInput
    favourites?: GameUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUpdateManyWithoutUserNestedInput
    userTags?: UserTagUpdateManyWithoutUsersNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGameStatusesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    profilePictureId?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    emailChanges?: EmailChangeUncheckedUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    playedGames?: GameUncheckedUpdateManyWithoutUserNestedInput
    favourites?: GameUncheckedUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUncheckedUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUncheckedUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUncheckedUpdateManyWithoutUserNestedInput
    userTags?: UserTagUncheckedUpdateManyWithoutUsersNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUncheckedUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUserTagsInput = {
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    profilePicture?: ImageCreateNestedOneWithoutUserInput
    emailChanges?: EmailChangeCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    playedGames?: GameCreateNestedManyWithoutUserInput
    favourites?: GameCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipCreateNestedManyWithoutReceiverInput
    groups?: UserGroupCreateNestedManyWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagCreateNestedManyWithoutUserInput
    gameStatuses?: GameStatusCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockCreateNestedManyWithoutUserInput
    uploadedImages?: ImageCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentCreateNestedManyWithoutUserInput
    GameUser?: GameUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserTagsInput = {
    id?: number
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    profilePictureId?: number | null
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    emailChanges?: EmailChangeUncheckedCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    playedGames?: GameUncheckedCreateNestedManyWithoutUserInput
    favourites?: GameUncheckedCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutReceiverInput
    groups?: UserGroupUncheckedCreateNestedManyWithoutUsersInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagUncheckedCreateNestedManyWithoutUserInput
    gameStatuses?: GameStatusUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutUserInput
    uploadedImages?: ImageUncheckedCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    GameUser?: GameUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserTagsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserTagsInput, UserUncheckedCreateWithoutUserTagsInput>
  }

  export type UserUpsertWithWhereUniqueWithoutUserTagsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutUserTagsInput, UserUncheckedUpdateWithoutUserTagsInput>
    create: XOR<UserCreateWithoutUserTagsInput, UserUncheckedCreateWithoutUserTagsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutUserTagsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutUserTagsInput, UserUncheckedUpdateWithoutUserTagsInput>
  }

  export type UserUpdateManyWithWhereWithoutUserTagsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUserTagsInput>
  }

  export type GameCreateWithoutTagsInput = {
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImage?: ImageCreateNestedOneWithoutGamesInput
    reviews?: ReviewCreateNestedManyWithoutGameInput
    users?: GameUserCreateNestedManyWithoutGameInput
    favouritedBy?: UserCreateNestedManyWithoutFavouritesInput
    genres?: GenreCreateNestedManyWithoutGamesInput
    platforms?: PlatformCreateNestedManyWithoutGamesInput
    statuses?: GameStatusCreateNestedManyWithoutGamesInput
    developers?: DeveloperCreateNestedManyWithoutGamesInput
    publishers?: PublisherCreateNestedManyWithoutGamesInput
    images?: GameImageCreateNestedManyWithoutGameInput
    achievements?: AchievementCreateNestedManyWithoutGameInput
    User?: UserCreateNestedOneWithoutPlayedGamesInput
  }

  export type GameUncheckedCreateWithoutTagsInput = {
    id?: number
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImageId?: number | null
    userId?: number | null
    reviews?: ReviewUncheckedCreateNestedManyWithoutGameInput
    users?: GameUserUncheckedCreateNestedManyWithoutGameInput
    favouritedBy?: UserUncheckedCreateNestedManyWithoutFavouritesInput
    genres?: GenreUncheckedCreateNestedManyWithoutGamesInput
    platforms?: PlatformUncheckedCreateNestedManyWithoutGamesInput
    statuses?: GameStatusUncheckedCreateNestedManyWithoutGamesInput
    developers?: DeveloperUncheckedCreateNestedManyWithoutGamesInput
    publishers?: PublisherUncheckedCreateNestedManyWithoutGamesInput
    images?: GameImageUncheckedCreateNestedManyWithoutGameInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutTagsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutTagsInput, GameUncheckedCreateWithoutTagsInput>
  }

  export type GameUpsertWithWhereUniqueWithoutTagsInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutTagsInput, GameUncheckedUpdateWithoutTagsInput>
    create: XOR<GameCreateWithoutTagsInput, GameUncheckedCreateWithoutTagsInput>
  }

  export type GameUpdateWithWhereUniqueWithoutTagsInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutTagsInput, GameUncheckedUpdateWithoutTagsInput>
  }

  export type GameUpdateManyWithWhereWithoutTagsInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutTagsInput>
  }

  export type ReviewCreateWithoutTagsInput = {
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    game: GameCreateNestedOneWithoutReviewsInput
    comments?: ReviewCommentCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutTagsInput = {
    id?: number
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    gameId: number
    comments?: ReviewCommentUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutTagsInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutTagsInput, ReviewUncheckedCreateWithoutTagsInput>
  }

  export type UserCreateWithoutReviewTagsInput = {
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    profilePicture?: ImageCreateNestedOneWithoutUserInput
    emailChanges?: EmailChangeCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    playedGames?: GameCreateNestedManyWithoutUserInput
    favourites?: GameCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipCreateNestedManyWithoutReceiverInput
    groups?: UserGroupCreateNestedManyWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    userTags?: UserTagCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockCreateNestedManyWithoutUserInput
    uploadedImages?: ImageCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentCreateNestedManyWithoutUserInput
    GameUser?: GameUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewTagsInput = {
    id?: number
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    profilePictureId?: number | null
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    emailChanges?: EmailChangeUncheckedCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    playedGames?: GameUncheckedCreateNestedManyWithoutUserInput
    favourites?: GameUncheckedCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutReceiverInput
    groups?: UserGroupUncheckedCreateNestedManyWithoutUsersInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    userTags?: UserTagUncheckedCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutUserInput
    uploadedImages?: ImageUncheckedCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    GameUser?: GameUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewTagsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewTagsInput, UserUncheckedCreateWithoutReviewTagsInput>
  }

  export type ReviewUpsertWithoutTagsInput = {
    update: XOR<ReviewUpdateWithoutTagsInput, ReviewUncheckedUpdateWithoutTagsInput>
    create: XOR<ReviewCreateWithoutTagsInput, ReviewUncheckedCreateWithoutTagsInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutTagsInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutTagsInput, ReviewUncheckedUpdateWithoutTagsInput>
  }

  export type ReviewUpdateWithoutTagsInput = {
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    game?: GameUpdateOneRequiredWithoutReviewsNestedInput
    comments?: ReviewCommentUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    comments?: ReviewCommentUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type UserUpsertWithoutReviewTagsInput = {
    update: XOR<UserUpdateWithoutReviewTagsInput, UserUncheckedUpdateWithoutReviewTagsInput>
    create: XOR<UserCreateWithoutReviewTagsInput, UserUncheckedCreateWithoutReviewTagsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewTagsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewTagsInput, UserUncheckedUpdateWithoutReviewTagsInput>
  }

  export type UserUpdateWithoutReviewTagsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: ImageUpdateOneWithoutUserNestedInput
    emailChanges?: EmailChangeUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    playedGames?: GameUpdateManyWithoutUserNestedInput
    favourites?: GameUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    userTags?: UserTagUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    profilePictureId?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    emailChanges?: EmailChangeUncheckedUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    playedGames?: GameUncheckedUpdateManyWithoutUserNestedInput
    favourites?: GameUncheckedUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUncheckedUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUncheckedUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    userTags?: UserTagUncheckedUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUncheckedUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GameCreateWithoutDevelopersInput = {
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImage?: ImageCreateNestedOneWithoutGamesInput
    reviews?: ReviewCreateNestedManyWithoutGameInput
    users?: GameUserCreateNestedManyWithoutGameInput
    favouritedBy?: UserCreateNestedManyWithoutFavouritesInput
    genres?: GenreCreateNestedManyWithoutGamesInput
    platforms?: PlatformCreateNestedManyWithoutGamesInput
    tags?: GameTagCreateNestedManyWithoutGamesInput
    statuses?: GameStatusCreateNestedManyWithoutGamesInput
    publishers?: PublisherCreateNestedManyWithoutGamesInput
    images?: GameImageCreateNestedManyWithoutGameInput
    achievements?: AchievementCreateNestedManyWithoutGameInput
    User?: UserCreateNestedOneWithoutPlayedGamesInput
  }

  export type GameUncheckedCreateWithoutDevelopersInput = {
    id?: number
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImageId?: number | null
    userId?: number | null
    reviews?: ReviewUncheckedCreateNestedManyWithoutGameInput
    users?: GameUserUncheckedCreateNestedManyWithoutGameInput
    favouritedBy?: UserUncheckedCreateNestedManyWithoutFavouritesInput
    genres?: GenreUncheckedCreateNestedManyWithoutGamesInput
    platforms?: PlatformUncheckedCreateNestedManyWithoutGamesInput
    tags?: GameTagUncheckedCreateNestedManyWithoutGamesInput
    statuses?: GameStatusUncheckedCreateNestedManyWithoutGamesInput
    publishers?: PublisherUncheckedCreateNestedManyWithoutGamesInput
    images?: GameImageUncheckedCreateNestedManyWithoutGameInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutDevelopersInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutDevelopersInput, GameUncheckedCreateWithoutDevelopersInput>
  }

  export type GameUpsertWithWhereUniqueWithoutDevelopersInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutDevelopersInput, GameUncheckedUpdateWithoutDevelopersInput>
    create: XOR<GameCreateWithoutDevelopersInput, GameUncheckedCreateWithoutDevelopersInput>
  }

  export type GameUpdateWithWhereUniqueWithoutDevelopersInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutDevelopersInput, GameUncheckedUpdateWithoutDevelopersInput>
  }

  export type GameUpdateManyWithWhereWithoutDevelopersInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutDevelopersInput>
  }

  export type GameCreateWithoutPublishersInput = {
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImage?: ImageCreateNestedOneWithoutGamesInput
    reviews?: ReviewCreateNestedManyWithoutGameInput
    users?: GameUserCreateNestedManyWithoutGameInput
    favouritedBy?: UserCreateNestedManyWithoutFavouritesInput
    genres?: GenreCreateNestedManyWithoutGamesInput
    platforms?: PlatformCreateNestedManyWithoutGamesInput
    tags?: GameTagCreateNestedManyWithoutGamesInput
    statuses?: GameStatusCreateNestedManyWithoutGamesInput
    developers?: DeveloperCreateNestedManyWithoutGamesInput
    images?: GameImageCreateNestedManyWithoutGameInput
    achievements?: AchievementCreateNestedManyWithoutGameInput
    User?: UserCreateNestedOneWithoutPlayedGamesInput
  }

  export type GameUncheckedCreateWithoutPublishersInput = {
    id?: number
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImageId?: number | null
    userId?: number | null
    reviews?: ReviewUncheckedCreateNestedManyWithoutGameInput
    users?: GameUserUncheckedCreateNestedManyWithoutGameInput
    favouritedBy?: UserUncheckedCreateNestedManyWithoutFavouritesInput
    genres?: GenreUncheckedCreateNestedManyWithoutGamesInput
    platforms?: PlatformUncheckedCreateNestedManyWithoutGamesInput
    tags?: GameTagUncheckedCreateNestedManyWithoutGamesInput
    statuses?: GameStatusUncheckedCreateNestedManyWithoutGamesInput
    developers?: DeveloperUncheckedCreateNestedManyWithoutGamesInput
    images?: GameImageUncheckedCreateNestedManyWithoutGameInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutPublishersInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutPublishersInput, GameUncheckedCreateWithoutPublishersInput>
  }

  export type GameUpsertWithWhereUniqueWithoutPublishersInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutPublishersInput, GameUncheckedUpdateWithoutPublishersInput>
    create: XOR<GameCreateWithoutPublishersInput, GameUncheckedCreateWithoutPublishersInput>
  }

  export type GameUpdateWithWhereUniqueWithoutPublishersInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutPublishersInput, GameUncheckedUpdateWithoutPublishersInput>
  }

  export type GameUpdateManyWithWhereWithoutPublishersInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutPublishersInput>
  }

  export type GameCreateWithoutImagesInput = {
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImage?: ImageCreateNestedOneWithoutGamesInput
    reviews?: ReviewCreateNestedManyWithoutGameInput
    users?: GameUserCreateNestedManyWithoutGameInput
    favouritedBy?: UserCreateNestedManyWithoutFavouritesInput
    genres?: GenreCreateNestedManyWithoutGamesInput
    platforms?: PlatformCreateNestedManyWithoutGamesInput
    tags?: GameTagCreateNestedManyWithoutGamesInput
    statuses?: GameStatusCreateNestedManyWithoutGamesInput
    developers?: DeveloperCreateNestedManyWithoutGamesInput
    publishers?: PublisherCreateNestedManyWithoutGamesInput
    achievements?: AchievementCreateNestedManyWithoutGameInput
    User?: UserCreateNestedOneWithoutPlayedGamesInput
  }

  export type GameUncheckedCreateWithoutImagesInput = {
    id?: number
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImageId?: number | null
    userId?: number | null
    reviews?: ReviewUncheckedCreateNestedManyWithoutGameInput
    users?: GameUserUncheckedCreateNestedManyWithoutGameInput
    favouritedBy?: UserUncheckedCreateNestedManyWithoutFavouritesInput
    genres?: GenreUncheckedCreateNestedManyWithoutGamesInput
    platforms?: PlatformUncheckedCreateNestedManyWithoutGamesInput
    tags?: GameTagUncheckedCreateNestedManyWithoutGamesInput
    statuses?: GameStatusUncheckedCreateNestedManyWithoutGamesInput
    developers?: DeveloperUncheckedCreateNestedManyWithoutGamesInput
    publishers?: PublisherUncheckedCreateNestedManyWithoutGamesInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutImagesInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutImagesInput, GameUncheckedCreateWithoutImagesInput>
  }

  export type GameUpsertWithoutImagesInput = {
    update: XOR<GameUpdateWithoutImagesInput, GameUncheckedUpdateWithoutImagesInput>
    create: XOR<GameCreateWithoutImagesInput, GameUncheckedCreateWithoutImagesInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutImagesInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutImagesInput, GameUncheckedUpdateWithoutImagesInput>
  }

  export type GameUpdateWithoutImagesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: ImageUpdateOneWithoutGamesNestedInput
    reviews?: ReviewUpdateManyWithoutGameNestedInput
    users?: GameUserUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUpdateManyWithoutGamesNestedInput
    tags?: GameTagUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUpdateManyWithoutGamesNestedInput
    achievements?: AchievementUpdateManyWithoutGameNestedInput
    User?: UserUpdateOneWithoutPlayedGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: ReviewUncheckedUpdateManyWithoutGameNestedInput
    users?: GameUserUncheckedUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUncheckedUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUncheckedUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUncheckedUpdateManyWithoutGamesNestedInput
    tags?: GameTagUncheckedUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUncheckedUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUncheckedUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUncheckedUpdateManyWithoutGamesNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameCreateWithoutAchievementsInput = {
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImage?: ImageCreateNestedOneWithoutGamesInput
    reviews?: ReviewCreateNestedManyWithoutGameInput
    users?: GameUserCreateNestedManyWithoutGameInput
    favouritedBy?: UserCreateNestedManyWithoutFavouritesInput
    genres?: GenreCreateNestedManyWithoutGamesInput
    platforms?: PlatformCreateNestedManyWithoutGamesInput
    tags?: GameTagCreateNestedManyWithoutGamesInput
    statuses?: GameStatusCreateNestedManyWithoutGamesInput
    developers?: DeveloperCreateNestedManyWithoutGamesInput
    publishers?: PublisherCreateNestedManyWithoutGamesInput
    images?: GameImageCreateNestedManyWithoutGameInput
    User?: UserCreateNestedOneWithoutPlayedGamesInput
  }

  export type GameUncheckedCreateWithoutAchievementsInput = {
    id?: number
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImageId?: number | null
    userId?: number | null
    reviews?: ReviewUncheckedCreateNestedManyWithoutGameInput
    users?: GameUserUncheckedCreateNestedManyWithoutGameInput
    favouritedBy?: UserUncheckedCreateNestedManyWithoutFavouritesInput
    genres?: GenreUncheckedCreateNestedManyWithoutGamesInput
    platforms?: PlatformUncheckedCreateNestedManyWithoutGamesInput
    tags?: GameTagUncheckedCreateNestedManyWithoutGamesInput
    statuses?: GameStatusUncheckedCreateNestedManyWithoutGamesInput
    developers?: DeveloperUncheckedCreateNestedManyWithoutGamesInput
    publishers?: PublisherUncheckedCreateNestedManyWithoutGamesInput
    images?: GameImageUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutAchievementsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutAchievementsInput, GameUncheckedCreateWithoutAchievementsInput>
  }

  export type AchievementUnlockCreateWithoutAchievementInput = {
    unlockedAt?: Date | string
    user: UserCreateNestedOneWithoutAchievementsInput
  }

  export type AchievementUnlockUncheckedCreateWithoutAchievementInput = {
    id?: number
    unlockedAt?: Date | string
    userId: number
  }

  export type AchievementUnlockCreateOrConnectWithoutAchievementInput = {
    where: AchievementUnlockWhereUniqueInput
    create: XOR<AchievementUnlockCreateWithoutAchievementInput, AchievementUnlockUncheckedCreateWithoutAchievementInput>
  }

  export type AchievementUnlockCreateManyAchievementInputEnvelope = {
    data: AchievementUnlockCreateManyAchievementInput | AchievementUnlockCreateManyAchievementInput[]
    skipDuplicates?: boolean
  }

  export type GameUpsertWithoutAchievementsInput = {
    update: XOR<GameUpdateWithoutAchievementsInput, GameUncheckedUpdateWithoutAchievementsInput>
    create: XOR<GameCreateWithoutAchievementsInput, GameUncheckedCreateWithoutAchievementsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutAchievementsInput, GameUncheckedUpdateWithoutAchievementsInput>
  }

  export type GameUpdateWithoutAchievementsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: ImageUpdateOneWithoutGamesNestedInput
    reviews?: ReviewUpdateManyWithoutGameNestedInput
    users?: GameUserUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUpdateManyWithoutGamesNestedInput
    tags?: GameTagUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUpdateManyWithoutGamesNestedInput
    images?: GameImageUpdateManyWithoutGameNestedInput
    User?: UserUpdateOneWithoutPlayedGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutAchievementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: ReviewUncheckedUpdateManyWithoutGameNestedInput
    users?: GameUserUncheckedUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUncheckedUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUncheckedUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUncheckedUpdateManyWithoutGamesNestedInput
    tags?: GameTagUncheckedUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUncheckedUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUncheckedUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUncheckedUpdateManyWithoutGamesNestedInput
    images?: GameImageUncheckedUpdateManyWithoutGameNestedInput
  }

  export type AchievementUnlockUpsertWithWhereUniqueWithoutAchievementInput = {
    where: AchievementUnlockWhereUniqueInput
    update: XOR<AchievementUnlockUpdateWithoutAchievementInput, AchievementUnlockUncheckedUpdateWithoutAchievementInput>
    create: XOR<AchievementUnlockCreateWithoutAchievementInput, AchievementUnlockUncheckedCreateWithoutAchievementInput>
  }

  export type AchievementUnlockUpdateWithWhereUniqueWithoutAchievementInput = {
    where: AchievementUnlockWhereUniqueInput
    data: XOR<AchievementUnlockUpdateWithoutAchievementInput, AchievementUnlockUncheckedUpdateWithoutAchievementInput>
  }

  export type AchievementUnlockUpdateManyWithWhereWithoutAchievementInput = {
    where: AchievementUnlockScalarWhereInput
    data: XOR<AchievementUnlockUpdateManyMutationInput, AchievementUnlockUncheckedUpdateManyWithoutAchievementInput>
  }

  export type UserCreateWithoutAchievementsInput = {
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    profilePicture?: ImageCreateNestedOneWithoutUserInput
    emailChanges?: EmailChangeCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    playedGames?: GameCreateNestedManyWithoutUserInput
    favourites?: GameCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipCreateNestedManyWithoutReceiverInput
    groups?: UserGroupCreateNestedManyWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagCreateNestedManyWithoutUserInput
    userTags?: UserTagCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusCreateNestedManyWithoutUserInput
    uploadedImages?: ImageCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentCreateNestedManyWithoutUserInput
    GameUser?: GameUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAchievementsInput = {
    id?: number
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    profilePictureId?: number | null
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    emailChanges?: EmailChangeUncheckedCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    playedGames?: GameUncheckedCreateNestedManyWithoutUserInput
    favourites?: GameUncheckedCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutReceiverInput
    groups?: UserGroupUncheckedCreateNestedManyWithoutUsersInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagUncheckedCreateNestedManyWithoutUserInput
    userTags?: UserTagUncheckedCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusUncheckedCreateNestedManyWithoutUserInput
    uploadedImages?: ImageUncheckedCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    GameUser?: GameUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAchievementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
  }

  export type AchievementCreateWithoutUnlocksInput = {
    title: string
    description?: string | null
    game: GameCreateNestedOneWithoutAchievementsInput
  }

  export type AchievementUncheckedCreateWithoutUnlocksInput = {
    id?: number
    title: string
    description?: string | null
    gameId: number
  }

  export type AchievementCreateOrConnectWithoutUnlocksInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutUnlocksInput, AchievementUncheckedCreateWithoutUnlocksInput>
  }

  export type UserUpsertWithoutAchievementsInput = {
    update: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserUpdateWithoutAchievementsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: ImageUpdateOneWithoutUserNestedInput
    emailChanges?: EmailChangeUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    playedGames?: GameUpdateManyWithoutUserNestedInput
    favourites?: GameUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUpdateManyWithoutUserNestedInput
    userTags?: UserTagUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAchievementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    profilePictureId?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    emailChanges?: EmailChangeUncheckedUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    playedGames?: GameUncheckedUpdateManyWithoutUserNestedInput
    favourites?: GameUncheckedUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUncheckedUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUncheckedUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUncheckedUpdateManyWithoutUserNestedInput
    userTags?: UserTagUncheckedUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUncheckedUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUncheckedUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AchievementUpsertWithoutUnlocksInput = {
    update: XOR<AchievementUpdateWithoutUnlocksInput, AchievementUncheckedUpdateWithoutUnlocksInput>
    create: XOR<AchievementCreateWithoutUnlocksInput, AchievementUncheckedCreateWithoutUnlocksInput>
    where?: AchievementWhereInput
  }

  export type AchievementUpdateToOneWithWhereWithoutUnlocksInput = {
    where?: AchievementWhereInput
    data: XOR<AchievementUpdateWithoutUnlocksInput, AchievementUncheckedUpdateWithoutUnlocksInput>
  }

  export type AchievementUpdateWithoutUnlocksInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    game?: GameUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type AchievementUncheckedUpdateWithoutUnlocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutEmailChangesInput = {
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    profilePicture?: ImageCreateNestedOneWithoutUserInput
    emailVerifications?: EmailVerificationCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    playedGames?: GameCreateNestedManyWithoutUserInput
    favourites?: GameCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipCreateNestedManyWithoutReceiverInput
    groups?: UserGroupCreateNestedManyWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagCreateNestedManyWithoutUserInput
    userTags?: UserTagCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockCreateNestedManyWithoutUserInput
    uploadedImages?: ImageCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentCreateNestedManyWithoutUserInput
    GameUser?: GameUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailChangesInput = {
    id?: number
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    profilePictureId?: number | null
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    emailVerifications?: EmailVerificationUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    playedGames?: GameUncheckedCreateNestedManyWithoutUserInput
    favourites?: GameUncheckedCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutReceiverInput
    groups?: UserGroupUncheckedCreateNestedManyWithoutUsersInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagUncheckedCreateNestedManyWithoutUserInput
    userTags?: UserTagUncheckedCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutUserInput
    uploadedImages?: ImageUncheckedCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    GameUser?: GameUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailChangesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailChangesInput, UserUncheckedCreateWithoutEmailChangesInput>
  }

  export type UserUpsertWithoutEmailChangesInput = {
    update: XOR<UserUpdateWithoutEmailChangesInput, UserUncheckedUpdateWithoutEmailChangesInput>
    create: XOR<UserCreateWithoutEmailChangesInput, UserUncheckedCreateWithoutEmailChangesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailChangesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailChangesInput, UserUncheckedUpdateWithoutEmailChangesInput>
  }

  export type UserUpdateWithoutEmailChangesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: ImageUpdateOneWithoutUserNestedInput
    emailVerifications?: EmailVerificationUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    playedGames?: GameUpdateManyWithoutUserNestedInput
    favourites?: GameUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUpdateManyWithoutUserNestedInput
    userTags?: UserTagUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailChangesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    profilePictureId?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifications?: EmailVerificationUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    playedGames?: GameUncheckedUpdateManyWithoutUserNestedInput
    favourites?: GameUncheckedUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUncheckedUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUncheckedUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUncheckedUpdateManyWithoutUserNestedInput
    userTags?: UserTagUncheckedUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUncheckedUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutEmailVerificationsInput = {
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    profilePicture?: ImageCreateNestedOneWithoutUserInput
    emailChanges?: EmailChangeCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    playedGames?: GameCreateNestedManyWithoutUserInput
    favourites?: GameCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipCreateNestedManyWithoutReceiverInput
    groups?: UserGroupCreateNestedManyWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagCreateNestedManyWithoutUserInput
    userTags?: UserTagCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockCreateNestedManyWithoutUserInput
    uploadedImages?: ImageCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentCreateNestedManyWithoutUserInput
    GameUser?: GameUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailVerificationsInput = {
    id?: number
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    profilePictureId?: number | null
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    emailChanges?: EmailChangeUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    playedGames?: GameUncheckedCreateNestedManyWithoutUserInput
    favourites?: GameUncheckedCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutReceiverInput
    groups?: UserGroupUncheckedCreateNestedManyWithoutUsersInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagUncheckedCreateNestedManyWithoutUserInput
    userTags?: UserTagUncheckedCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutUserInput
    uploadedImages?: ImageUncheckedCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    GameUser?: GameUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailVerificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailVerificationsInput, UserUncheckedCreateWithoutEmailVerificationsInput>
  }

  export type UserUpsertWithoutEmailVerificationsInput = {
    update: XOR<UserUpdateWithoutEmailVerificationsInput, UserUncheckedUpdateWithoutEmailVerificationsInput>
    create: XOR<UserCreateWithoutEmailVerificationsInput, UserUncheckedCreateWithoutEmailVerificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailVerificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailVerificationsInput, UserUncheckedUpdateWithoutEmailVerificationsInput>
  }

  export type UserUpdateWithoutEmailVerificationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: ImageUpdateOneWithoutUserNestedInput
    emailChanges?: EmailChangeUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    playedGames?: GameUpdateManyWithoutUserNestedInput
    favourites?: GameUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUpdateManyWithoutUserNestedInput
    userTags?: UserTagUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailVerificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    profilePictureId?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    emailChanges?: EmailChangeUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    playedGames?: GameUncheckedUpdateManyWithoutUserNestedInput
    favourites?: GameUncheckedUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUncheckedUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUncheckedUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUncheckedUpdateManyWithoutUserNestedInput
    userTags?: UserTagUncheckedUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUncheckedUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPasswordResetsInput = {
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    profilePicture?: ImageCreateNestedOneWithoutUserInput
    emailChanges?: EmailChangeCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationCreateNestedManyWithoutUserInput
    playedGames?: GameCreateNestedManyWithoutUserInput
    favourites?: GameCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipCreateNestedManyWithoutReceiverInput
    groups?: UserGroupCreateNestedManyWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagCreateNestedManyWithoutUserInput
    userTags?: UserTagCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockCreateNestedManyWithoutUserInput
    uploadedImages?: ImageCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentCreateNestedManyWithoutUserInput
    GameUser?: GameUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordResetsInput = {
    id?: number
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    profilePictureId?: number | null
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    emailChanges?: EmailChangeUncheckedCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationUncheckedCreateNestedManyWithoutUserInput
    playedGames?: GameUncheckedCreateNestedManyWithoutUserInput
    favourites?: GameUncheckedCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutReceiverInput
    groups?: UserGroupUncheckedCreateNestedManyWithoutUsersInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagUncheckedCreateNestedManyWithoutUserInput
    userTags?: UserTagUncheckedCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutUserInput
    uploadedImages?: ImageUncheckedCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    GameUser?: GameUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordResetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
  }

  export type UserUpsertWithoutPasswordResetsInput = {
    update: XOR<UserUpdateWithoutPasswordResetsInput, UserUncheckedUpdateWithoutPasswordResetsInput>
    create: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetsInput, UserUncheckedUpdateWithoutPasswordResetsInput>
  }

  export type UserUpdateWithoutPasswordResetsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: ImageUpdateOneWithoutUserNestedInput
    emailChanges?: EmailChangeUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUpdateManyWithoutUserNestedInput
    playedGames?: GameUpdateManyWithoutUserNestedInput
    favourites?: GameUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUpdateManyWithoutUserNestedInput
    userTags?: UserTagUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    profilePictureId?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    emailChanges?: EmailChangeUncheckedUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUncheckedUpdateManyWithoutUserNestedInput
    playedGames?: GameUncheckedUpdateManyWithoutUserNestedInput
    favourites?: GameUncheckedUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUncheckedUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUncheckedUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUncheckedUpdateManyWithoutUserNestedInput
    userTags?: UserTagUncheckedUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUncheckedUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSentFriendRequestsInput = {
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    profilePicture?: ImageCreateNestedOneWithoutUserInput
    emailChanges?: EmailChangeCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    playedGames?: GameCreateNestedManyWithoutUserInput
    favourites?: GameCreateNestedManyWithoutFavouritedByInput
    receivedFriendRequests?: FriendshipCreateNestedManyWithoutReceiverInput
    groups?: UserGroupCreateNestedManyWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagCreateNestedManyWithoutUserInput
    userTags?: UserTagCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockCreateNestedManyWithoutUserInput
    uploadedImages?: ImageCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentCreateNestedManyWithoutUserInput
    GameUser?: GameUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentFriendRequestsInput = {
    id?: number
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    profilePictureId?: number | null
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    emailChanges?: EmailChangeUncheckedCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    playedGames?: GameUncheckedCreateNestedManyWithoutUserInput
    favourites?: GameUncheckedCreateNestedManyWithoutFavouritedByInput
    receivedFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutReceiverInput
    groups?: UserGroupUncheckedCreateNestedManyWithoutUsersInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagUncheckedCreateNestedManyWithoutUserInput
    userTags?: UserTagUncheckedCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutUserInput
    uploadedImages?: ImageUncheckedCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    GameUser?: GameUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentFriendRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentFriendRequestsInput, UserUncheckedCreateWithoutSentFriendRequestsInput>
  }

  export type UserCreateWithoutReceivedFriendRequestsInput = {
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    profilePicture?: ImageCreateNestedOneWithoutUserInput
    emailChanges?: EmailChangeCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    playedGames?: GameCreateNestedManyWithoutUserInput
    favourites?: GameCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipCreateNestedManyWithoutSenderInput
    groups?: UserGroupCreateNestedManyWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagCreateNestedManyWithoutUserInput
    userTags?: UserTagCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockCreateNestedManyWithoutUserInput
    uploadedImages?: ImageCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentCreateNestedManyWithoutUserInput
    GameUser?: GameUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceivedFriendRequestsInput = {
    id?: number
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    profilePictureId?: number | null
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    emailChanges?: EmailChangeUncheckedCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    playedGames?: GameUncheckedCreateNestedManyWithoutUserInput
    favourites?: GameUncheckedCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutSenderInput
    groups?: UserGroupUncheckedCreateNestedManyWithoutUsersInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagUncheckedCreateNestedManyWithoutUserInput
    userTags?: UserTagUncheckedCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutUserInput
    uploadedImages?: ImageUncheckedCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    GameUser?: GameUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceivedFriendRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedFriendRequestsInput, UserUncheckedCreateWithoutReceivedFriendRequestsInput>
  }

  export type UserUpsertWithoutSentFriendRequestsInput = {
    update: XOR<UserUpdateWithoutSentFriendRequestsInput, UserUncheckedUpdateWithoutSentFriendRequestsInput>
    create: XOR<UserCreateWithoutSentFriendRequestsInput, UserUncheckedCreateWithoutSentFriendRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentFriendRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentFriendRequestsInput, UserUncheckedUpdateWithoutSentFriendRequestsInput>
  }

  export type UserUpdateWithoutSentFriendRequestsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: ImageUpdateOneWithoutUserNestedInput
    emailChanges?: EmailChangeUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    playedGames?: GameUpdateManyWithoutUserNestedInput
    favourites?: GameUpdateManyWithoutFavouritedByNestedInput
    receivedFriendRequests?: FriendshipUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUpdateManyWithoutUserNestedInput
    userTags?: UserTagUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentFriendRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    profilePictureId?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    emailChanges?: EmailChangeUncheckedUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    playedGames?: GameUncheckedUpdateManyWithoutUserNestedInput
    favourites?: GameUncheckedUpdateManyWithoutFavouritedByNestedInput
    receivedFriendRequests?: FriendshipUncheckedUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUncheckedUpdateManyWithoutUserNestedInput
    userTags?: UserTagUncheckedUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUncheckedUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReceivedFriendRequestsInput = {
    update: XOR<UserUpdateWithoutReceivedFriendRequestsInput, UserUncheckedUpdateWithoutReceivedFriendRequestsInput>
    create: XOR<UserCreateWithoutReceivedFriendRequestsInput, UserUncheckedCreateWithoutReceivedFriendRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedFriendRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedFriendRequestsInput, UserUncheckedUpdateWithoutReceivedFriendRequestsInput>
  }

  export type UserUpdateWithoutReceivedFriendRequestsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: ImageUpdateOneWithoutUserNestedInput
    emailChanges?: EmailChangeUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    playedGames?: GameUpdateManyWithoutUserNestedInput
    favourites?: GameUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUpdateManyWithoutSenderNestedInput
    groups?: UserGroupUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUpdateManyWithoutUserNestedInput
    userTags?: UserTagUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedFriendRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    profilePictureId?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    emailChanges?: EmailChangeUncheckedUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    playedGames?: GameUncheckedUpdateManyWithoutUserNestedInput
    favourites?: GameUncheckedUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUncheckedUpdateManyWithoutSenderNestedInput
    groups?: UserGroupUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUncheckedUpdateManyWithoutUserNestedInput
    userTags?: UserTagUncheckedUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUncheckedUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutGroupsInput = {
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    profilePicture?: ImageCreateNestedOneWithoutUserInput
    emailChanges?: EmailChangeCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    playedGames?: GameCreateNestedManyWithoutUserInput
    favourites?: GameCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipCreateNestedManyWithoutReceiverInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagCreateNestedManyWithoutUserInput
    userTags?: UserTagCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockCreateNestedManyWithoutUserInput
    uploadedImages?: ImageCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentCreateNestedManyWithoutUserInput
    GameUser?: GameUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGroupsInput = {
    id?: number
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    profilePictureId?: number | null
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
    emailChanges?: EmailChangeUncheckedCreateNestedManyWithoutUserInput
    emailVerifications?: EmailVerificationUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    playedGames?: GameUncheckedCreateNestedManyWithoutUserInput
    favourites?: GameUncheckedCreateNestedManyWithoutFavouritedByInput
    sentFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutSenderInput
    receivedFriendRequests?: FriendshipUncheckedCreateNestedManyWithoutReceiverInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewTags?: ReviewUserTagUncheckedCreateNestedManyWithoutUserInput
    userTags?: UserTagUncheckedCreateNestedManyWithoutUsersInput
    gameStatuses?: GameStatusUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutUserInput
    uploadedImages?: ImageUncheckedCreateNestedManyWithoutUploadedByInput
    ReviewComment?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    GameUser?: GameUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput>
  }

  export type UserUpsertWithWhereUniqueWithoutGroupsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutGroupsInput, UserUncheckedUpdateWithoutGroupsInput>
    create: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutGroupsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutGroupsInput, UserUncheckedUpdateWithoutGroupsInput>
  }

  export type UserUpdateManyWithWhereWithoutGroupsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutGroupsInput>
  }

  export type GameCreateWithoutGenresInput = {
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImage?: ImageCreateNestedOneWithoutGamesInput
    reviews?: ReviewCreateNestedManyWithoutGameInput
    users?: GameUserCreateNestedManyWithoutGameInput
    favouritedBy?: UserCreateNestedManyWithoutFavouritesInput
    platforms?: PlatformCreateNestedManyWithoutGamesInput
    tags?: GameTagCreateNestedManyWithoutGamesInput
    statuses?: GameStatusCreateNestedManyWithoutGamesInput
    developers?: DeveloperCreateNestedManyWithoutGamesInput
    publishers?: PublisherCreateNestedManyWithoutGamesInput
    images?: GameImageCreateNestedManyWithoutGameInput
    achievements?: AchievementCreateNestedManyWithoutGameInput
    User?: UserCreateNestedOneWithoutPlayedGamesInput
  }

  export type GameUncheckedCreateWithoutGenresInput = {
    id?: number
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImageId?: number | null
    userId?: number | null
    reviews?: ReviewUncheckedCreateNestedManyWithoutGameInput
    users?: GameUserUncheckedCreateNestedManyWithoutGameInput
    favouritedBy?: UserUncheckedCreateNestedManyWithoutFavouritesInput
    platforms?: PlatformUncheckedCreateNestedManyWithoutGamesInput
    tags?: GameTagUncheckedCreateNestedManyWithoutGamesInput
    statuses?: GameStatusUncheckedCreateNestedManyWithoutGamesInput
    developers?: DeveloperUncheckedCreateNestedManyWithoutGamesInput
    publishers?: PublisherUncheckedCreateNestedManyWithoutGamesInput
    images?: GameImageUncheckedCreateNestedManyWithoutGameInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutGenresInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutGenresInput, GameUncheckedCreateWithoutGenresInput>
  }

  export type GameUpsertWithWhereUniqueWithoutGenresInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutGenresInput, GameUncheckedUpdateWithoutGenresInput>
    create: XOR<GameCreateWithoutGenresInput, GameUncheckedCreateWithoutGenresInput>
  }

  export type GameUpdateWithWhereUniqueWithoutGenresInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutGenresInput, GameUncheckedUpdateWithoutGenresInput>
  }

  export type GameUpdateManyWithWhereWithoutGenresInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutGenresInput>
  }

  export type GameCreateWithoutPlatformsInput = {
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImage?: ImageCreateNestedOneWithoutGamesInput
    reviews?: ReviewCreateNestedManyWithoutGameInput
    users?: GameUserCreateNestedManyWithoutGameInput
    favouritedBy?: UserCreateNestedManyWithoutFavouritesInput
    genres?: GenreCreateNestedManyWithoutGamesInput
    tags?: GameTagCreateNestedManyWithoutGamesInput
    statuses?: GameStatusCreateNestedManyWithoutGamesInput
    developers?: DeveloperCreateNestedManyWithoutGamesInput
    publishers?: PublisherCreateNestedManyWithoutGamesInput
    images?: GameImageCreateNestedManyWithoutGameInput
    achievements?: AchievementCreateNestedManyWithoutGameInput
    User?: UserCreateNestedOneWithoutPlayedGamesInput
  }

  export type GameUncheckedCreateWithoutPlatformsInput = {
    id?: number
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImageId?: number | null
    userId?: number | null
    reviews?: ReviewUncheckedCreateNestedManyWithoutGameInput
    users?: GameUserUncheckedCreateNestedManyWithoutGameInput
    favouritedBy?: UserUncheckedCreateNestedManyWithoutFavouritesInput
    genres?: GenreUncheckedCreateNestedManyWithoutGamesInput
    tags?: GameTagUncheckedCreateNestedManyWithoutGamesInput
    statuses?: GameStatusUncheckedCreateNestedManyWithoutGamesInput
    developers?: DeveloperUncheckedCreateNestedManyWithoutGamesInput
    publishers?: PublisherUncheckedCreateNestedManyWithoutGamesInput
    images?: GameImageUncheckedCreateNestedManyWithoutGameInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutPlatformsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutPlatformsInput, GameUncheckedCreateWithoutPlatformsInput>
  }

  export type GameUpsertWithWhereUniqueWithoutPlatformsInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutPlatformsInput, GameUncheckedUpdateWithoutPlatformsInput>
    create: XOR<GameCreateWithoutPlatformsInput, GameUncheckedCreateWithoutPlatformsInput>
  }

  export type GameUpdateWithWhereUniqueWithoutPlatformsInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutPlatformsInput, GameUncheckedUpdateWithoutPlatformsInput>
  }

  export type GameUpdateManyWithWhereWithoutPlatformsInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutPlatformsInput>
  }

  export type EmailChangeCreateManyUserInput = {
    id?: number
    newEmail: string
    token: string
    createdAt?: Date | string
  }

  export type EmailVerificationCreateManyUserInput = {
    id?: number
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type PasswordResetCreateManyUserInput = {
    id?: number
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type GameCreateManyUserInput = {
    id?: number
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    coverImageId?: number | null
  }

  export type FriendshipCreateManySenderInput = {
    id?: number
    receiverId: number
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
  }

  export type FriendshipCreateManyReceiverInput = {
    id?: number
    senderId: number
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
  }

  export type ReviewCreateManyUserInput = {
    id?: number
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gameId: number
  }

  export type ReviewUserTagCreateManyUserInput = {
    id?: number
    label: string
    reviewId: number
  }

  export type GameStatusCreateManyUserInput = {
    id?: number
    type: $Enums.GameStatusType
  }

  export type AchievementUnlockCreateManyUserInput = {
    id?: number
    unlockedAt?: Date | string
    achievementId: number
  }

  export type ImageCreateManyUploadedByInput = {
    id?: number
    url: string
    checksum: string
    width?: number | null
    height?: number | null
    uploadedAt?: Date | string
  }

  export type ReviewCommentCreateManyUserInput = {
    id?: number
    content: string
    createdAt?: Date | string
    reviewId: number
  }

  export type GameUserCreateManyUserInput = {
    id?: number
    gameId: number
    progress?: $Enums.ProgressStatus
  }

  export type EmailChangeUpdateWithoutUserInput = {
    newEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailChangeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    newEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailChangeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    newEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: ImageUpdateOneWithoutGamesNestedInput
    reviews?: ReviewUpdateManyWithoutGameNestedInput
    users?: GameUserUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUpdateManyWithoutGamesNestedInput
    tags?: GameTagUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUpdateManyWithoutGamesNestedInput
    images?: GameImageUpdateManyWithoutGameNestedInput
    achievements?: AchievementUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: ReviewUncheckedUpdateManyWithoutGameNestedInput
    users?: GameUserUncheckedUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUncheckedUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUncheckedUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUncheckedUpdateManyWithoutGamesNestedInput
    tags?: GameTagUncheckedUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUncheckedUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUncheckedUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUncheckedUpdateManyWithoutGamesNestedInput
    images?: GameImageUncheckedUpdateManyWithoutGameNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GameUpdateWithoutFavouritedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: ImageUpdateOneWithoutGamesNestedInput
    reviews?: ReviewUpdateManyWithoutGameNestedInput
    users?: GameUserUpdateManyWithoutGameNestedInput
    genres?: GenreUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUpdateManyWithoutGamesNestedInput
    tags?: GameTagUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUpdateManyWithoutGamesNestedInput
    images?: GameImageUpdateManyWithoutGameNestedInput
    achievements?: AchievementUpdateManyWithoutGameNestedInput
    User?: UserUpdateOneWithoutPlayedGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutFavouritedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: ReviewUncheckedUpdateManyWithoutGameNestedInput
    users?: GameUserUncheckedUpdateManyWithoutGameNestedInput
    genres?: GenreUncheckedUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUncheckedUpdateManyWithoutGamesNestedInput
    tags?: GameTagUncheckedUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUncheckedUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUncheckedUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUncheckedUpdateManyWithoutGamesNestedInput
    images?: GameImageUncheckedUpdateManyWithoutGameNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateManyWithoutFavouritedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FriendshipUpdateWithoutSenderInput = {
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedFriendRequestsNestedInput
  }

  export type FriendshipUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUpdateWithoutReceiverInput = {
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentFriendRequestsNestedInput
  }

  export type FriendshipUncheckedUpdateWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUncheckedUpdateManyWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UserGroupUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UserGroupUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewUpdateWithoutUserInput = {
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutReviewsNestedInput
    tags?: ReviewUserTagUpdateManyWithoutReviewNestedInput
    comments?: ReviewCommentUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameId?: IntFieldUpdateOperationsInput | number
    tags?: ReviewUserTagUncheckedUpdateManyWithoutReviewNestedInput
    comments?: ReviewCommentUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameId?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewUserTagUpdateWithoutUserInput = {
    label?: StringFieldUpdateOperationsInput | string
    review?: ReviewUpdateOneRequiredWithoutTagsNestedInput
  }

  export type ReviewUserTagUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    reviewId?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewUserTagUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    reviewId?: IntFieldUpdateOperationsInput | number
  }

  export type UserTagUpdateWithoutUsersInput = {
    label?: StringFieldUpdateOperationsInput | string
  }

  export type UserTagUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
  }

  export type UserTagUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
  }

  export type GameStatusUpdateWithoutUserInput = {
    type?: EnumGameStatusTypeFieldUpdateOperationsInput | $Enums.GameStatusType
    games?: GameUpdateManyWithoutStatusesNestedInput
  }

  export type GameStatusUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumGameStatusTypeFieldUpdateOperationsInput | $Enums.GameStatusType
    games?: GameUncheckedUpdateManyWithoutStatusesNestedInput
  }

  export type GameStatusUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumGameStatusTypeFieldUpdateOperationsInput | $Enums.GameStatusType
  }

  export type AchievementUnlockUpdateWithoutUserInput = {
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: AchievementUpdateOneRequiredWithoutUnlocksNestedInput
  }

  export type AchievementUnlockUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievementId?: IntFieldUpdateOperationsInput | number
  }

  export type AchievementUnlockUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievementId?: IntFieldUpdateOperationsInput | number
  }

  export type ImageUpdateWithoutUploadedByInput = {
    url?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: GameUpdateManyWithoutCoverImageNestedInput
    User?: UserUpdateManyWithoutProfilePictureNestedInput
  }

  export type ImageUncheckedUpdateWithoutUploadedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: GameUncheckedUpdateManyWithoutCoverImageNestedInput
    User?: UserUncheckedUpdateManyWithoutProfilePictureNestedInput
  }

  export type ImageUncheckedUpdateManyWithoutUploadedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCommentUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ReviewCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewId?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewCommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewId?: IntFieldUpdateOperationsInput | number
  }

  export type GameUserUpdateWithoutUserInput = {
    progress?: EnumProgressStatusFieldUpdateOperationsInput | $Enums.ProgressStatus
    game?: GameUpdateOneRequiredWithoutUsersNestedInput
  }

  export type GameUserUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    progress?: EnumProgressStatusFieldUpdateOperationsInput | $Enums.ProgressStatus
  }

  export type GameUserUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    progress?: EnumProgressStatusFieldUpdateOperationsInput | $Enums.ProgressStatus
  }

  export type ReviewCreateManyGameInput = {
    id?: number
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
  }

  export type GameUserCreateManyGameInput = {
    id?: number
    userId: number
    progress?: $Enums.ProgressStatus
  }

  export type GameImageCreateManyGameInput = {
    id?: number
    url: string
  }

  export type AchievementCreateManyGameInput = {
    id?: number
    title: string
    description?: string | null
  }

  export type ReviewUpdateWithoutGameInput = {
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    tags?: ReviewUserTagUpdateManyWithoutReviewNestedInput
    comments?: ReviewCommentUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    tags?: ReviewUserTagUncheckedUpdateManyWithoutReviewNestedInput
    comments?: ReviewCommentUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateManyWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type GameUserUpdateWithoutGameInput = {
    progress?: EnumProgressStatusFieldUpdateOperationsInput | $Enums.ProgressStatus
    user?: UserUpdateOneRequiredWithoutGameUserNestedInput
  }

  export type GameUserUncheckedUpdateWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    progress?: EnumProgressStatusFieldUpdateOperationsInput | $Enums.ProgressStatus
  }

  export type GameUserUncheckedUpdateManyWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    progress?: EnumProgressStatusFieldUpdateOperationsInput | $Enums.ProgressStatus
  }

  export type UserUpdateWithoutFavouritesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: ImageUpdateOneWithoutUserNestedInput
    emailChanges?: EmailChangeUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    playedGames?: GameUpdateManyWithoutUserNestedInput
    sentFriendRequests?: FriendshipUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUpdateManyWithoutUserNestedInput
    userTags?: UserTagUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFavouritesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    profilePictureId?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    emailChanges?: EmailChangeUncheckedUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    playedGames?: GameUncheckedUpdateManyWithoutUserNestedInput
    sentFriendRequests?: FriendshipUncheckedUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUncheckedUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUncheckedUpdateManyWithoutUserNestedInput
    userTags?: UserTagUncheckedUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUncheckedUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutFavouritesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    profilePictureId?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GenreUpdateWithoutGamesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GenreUncheckedUpdateWithoutGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GenreUncheckedUpdateManyWithoutGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PlatformUpdateWithoutGamesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PlatformUncheckedUpdateWithoutGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PlatformUncheckedUpdateManyWithoutGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GameTagUpdateWithoutGamesInput = {
    label?: StringFieldUpdateOperationsInput | string
  }

  export type GameTagUncheckedUpdateWithoutGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
  }

  export type GameTagUncheckedUpdateManyWithoutGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
  }

  export type GameStatusUpdateWithoutGamesInput = {
    type?: EnumGameStatusTypeFieldUpdateOperationsInput | $Enums.GameStatusType
    user?: UserUpdateOneRequiredWithoutGameStatusesNestedInput
  }

  export type GameStatusUncheckedUpdateWithoutGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumGameStatusTypeFieldUpdateOperationsInput | $Enums.GameStatusType
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type GameStatusUncheckedUpdateManyWithoutGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumGameStatusTypeFieldUpdateOperationsInput | $Enums.GameStatusType
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type DeveloperUpdateWithoutGamesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeveloperUncheckedUpdateWithoutGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeveloperUncheckedUpdateManyWithoutGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PublisherUpdateWithoutGamesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PublisherUncheckedUpdateWithoutGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PublisherUncheckedUpdateManyWithoutGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GameImageUpdateWithoutGameInput = {
    url?: StringFieldUpdateOperationsInput | string
  }

  export type GameImageUncheckedUpdateWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type GameImageUncheckedUpdateManyWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type AchievementUpdateWithoutGameInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unlocks?: AchievementUnlockUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementUncheckedUpdateWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unlocks?: AchievementUnlockUncheckedUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementUncheckedUpdateManyWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GameCreateManyCoverImageInput = {
    id?: number
    title: string
    description?: string | null
    releaseDate?: Date | string | null
    userId?: number | null
  }

  export type UserCreateManyProfilePictureInput = {
    id?: number
    email: string
    passwordHash?: string | null
    googleId?: string | null
    displayName: string
    emailVerified?: boolean
    birthDate?: Date | string | null
    registrationDate?: Date | string
  }

  export type GameUpdateWithoutCoverImageInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviews?: ReviewUpdateManyWithoutGameNestedInput
    users?: GameUserUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUpdateManyWithoutGamesNestedInput
    tags?: GameTagUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUpdateManyWithoutGamesNestedInput
    images?: GameImageUpdateManyWithoutGameNestedInput
    achievements?: AchievementUpdateManyWithoutGameNestedInput
    User?: UserUpdateOneWithoutPlayedGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutCoverImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: ReviewUncheckedUpdateManyWithoutGameNestedInput
    users?: GameUserUncheckedUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUncheckedUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUncheckedUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUncheckedUpdateManyWithoutGamesNestedInput
    tags?: GameTagUncheckedUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUncheckedUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUncheckedUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUncheckedUpdateManyWithoutGamesNestedInput
    images?: GameImageUncheckedUpdateManyWithoutGameNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateManyWithoutCoverImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUpdateWithoutProfilePictureInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    emailChanges?: EmailChangeUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    playedGames?: GameUpdateManyWithoutUserNestedInput
    favourites?: GameUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUpdateManyWithoutUserNestedInput
    userTags?: UserTagUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfilePictureInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    emailChanges?: EmailChangeUncheckedUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    playedGames?: GameUncheckedUpdateManyWithoutUserNestedInput
    favourites?: GameUncheckedUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUncheckedUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUncheckedUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUncheckedUpdateManyWithoutUserNestedInput
    userTags?: UserTagUncheckedUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUncheckedUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutProfilePictureInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUserTagCreateManyReviewInput = {
    id?: number
    label: string
    userId: number
  }

  export type ReviewCommentCreateManyReviewInput = {
    id?: number
    content: string
    createdAt?: Date | string
    userId: number
  }

  export type ReviewUserTagUpdateWithoutReviewInput = {
    label?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutReviewTagsNestedInput
  }

  export type ReviewUserTagUncheckedUpdateWithoutReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewUserTagUncheckedUpdateManyWithoutReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewCommentUpdateWithoutReviewInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewCommentNestedInput
  }

  export type ReviewCommentUncheckedUpdateWithoutReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewCommentUncheckedUpdateManyWithoutReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type GameUpdateWithoutStatusesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: ImageUpdateOneWithoutGamesNestedInput
    reviews?: ReviewUpdateManyWithoutGameNestedInput
    users?: GameUserUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUpdateManyWithoutGamesNestedInput
    tags?: GameTagUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUpdateManyWithoutGamesNestedInput
    images?: GameImageUpdateManyWithoutGameNestedInput
    achievements?: AchievementUpdateManyWithoutGameNestedInput
    User?: UserUpdateOneWithoutPlayedGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutStatusesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: ReviewUncheckedUpdateManyWithoutGameNestedInput
    users?: GameUserUncheckedUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUncheckedUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUncheckedUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUncheckedUpdateManyWithoutGamesNestedInput
    tags?: GameTagUncheckedUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUncheckedUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUncheckedUpdateManyWithoutGamesNestedInput
    images?: GameImageUncheckedUpdateManyWithoutGameNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateManyWithoutStatusesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUpdateWithoutUserTagsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: ImageUpdateOneWithoutUserNestedInput
    emailChanges?: EmailChangeUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    playedGames?: GameUpdateManyWithoutUserNestedInput
    favourites?: GameUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUpdateManyWithoutUserNestedInput
    gameStatuses?: GameStatusUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    profilePictureId?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    emailChanges?: EmailChangeUncheckedUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    playedGames?: GameUncheckedUpdateManyWithoutUserNestedInput
    favourites?: GameUncheckedUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUncheckedUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUncheckedUpdateManyWithoutReceiverNestedInput
    groups?: UserGroupUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUncheckedUpdateManyWithoutUserNestedInput
    gameStatuses?: GameStatusUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUncheckedUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUserTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    profilePictureId?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUpdateWithoutTagsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: ImageUpdateOneWithoutGamesNestedInput
    reviews?: ReviewUpdateManyWithoutGameNestedInput
    users?: GameUserUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUpdateManyWithoutGamesNestedInput
    images?: GameImageUpdateManyWithoutGameNestedInput
    achievements?: AchievementUpdateManyWithoutGameNestedInput
    User?: UserUpdateOneWithoutPlayedGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: ReviewUncheckedUpdateManyWithoutGameNestedInput
    users?: GameUserUncheckedUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUncheckedUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUncheckedUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUncheckedUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUncheckedUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUncheckedUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUncheckedUpdateManyWithoutGamesNestedInput
    images?: GameImageUncheckedUpdateManyWithoutGameNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateManyWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GameUpdateWithoutDevelopersInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: ImageUpdateOneWithoutGamesNestedInput
    reviews?: ReviewUpdateManyWithoutGameNestedInput
    users?: GameUserUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUpdateManyWithoutGamesNestedInput
    tags?: GameTagUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUpdateManyWithoutGamesNestedInput
    images?: GameImageUpdateManyWithoutGameNestedInput
    achievements?: AchievementUpdateManyWithoutGameNestedInput
    User?: UserUpdateOneWithoutPlayedGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutDevelopersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: ReviewUncheckedUpdateManyWithoutGameNestedInput
    users?: GameUserUncheckedUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUncheckedUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUncheckedUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUncheckedUpdateManyWithoutGamesNestedInput
    tags?: GameTagUncheckedUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUncheckedUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUncheckedUpdateManyWithoutGamesNestedInput
    images?: GameImageUncheckedUpdateManyWithoutGameNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateManyWithoutDevelopersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GameUpdateWithoutPublishersInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: ImageUpdateOneWithoutGamesNestedInput
    reviews?: ReviewUpdateManyWithoutGameNestedInput
    users?: GameUserUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUpdateManyWithoutGamesNestedInput
    tags?: GameTagUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUpdateManyWithoutGamesNestedInput
    images?: GameImageUpdateManyWithoutGameNestedInput
    achievements?: AchievementUpdateManyWithoutGameNestedInput
    User?: UserUpdateOneWithoutPlayedGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutPublishersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: ReviewUncheckedUpdateManyWithoutGameNestedInput
    users?: GameUserUncheckedUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUncheckedUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUncheckedUpdateManyWithoutGamesNestedInput
    platforms?: PlatformUncheckedUpdateManyWithoutGamesNestedInput
    tags?: GameTagUncheckedUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUncheckedUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUncheckedUpdateManyWithoutGamesNestedInput
    images?: GameImageUncheckedUpdateManyWithoutGameNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateManyWithoutPublishersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AchievementUnlockCreateManyAchievementInput = {
    id?: number
    unlockedAt?: Date | string
    userId: number
  }

  export type AchievementUnlockUpdateWithoutAchievementInput = {
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type AchievementUnlockUncheckedUpdateWithoutAchievementInput = {
    id?: IntFieldUpdateOperationsInput | number
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type AchievementUnlockUncheckedUpdateManyWithoutAchievementInput = {
    id?: IntFieldUpdateOperationsInput | number
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpdateWithoutGroupsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: ImageUpdateOneWithoutUserNestedInput
    emailChanges?: EmailChangeUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    playedGames?: GameUpdateManyWithoutUserNestedInput
    favourites?: GameUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUpdateManyWithoutReceiverNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUpdateManyWithoutUserNestedInput
    userTags?: UserTagUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    profilePictureId?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    emailChanges?: EmailChangeUncheckedUpdateManyWithoutUserNestedInput
    emailVerifications?: EmailVerificationUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    playedGames?: GameUncheckedUpdateManyWithoutUserNestedInput
    favourites?: GameUncheckedUpdateManyWithoutFavouritedByNestedInput
    sentFriendRequests?: FriendshipUncheckedUpdateManyWithoutSenderNestedInput
    receivedFriendRequests?: FriendshipUncheckedUpdateManyWithoutReceiverNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewTags?: ReviewUserTagUncheckedUpdateManyWithoutUserNestedInput
    userTags?: UserTagUncheckedUpdateManyWithoutUsersNestedInput
    gameStatuses?: GameStatusUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutUserNestedInput
    uploadedImages?: ImageUncheckedUpdateManyWithoutUploadedByNestedInput
    ReviewComment?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    GameUser?: GameUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    profilePictureId?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUpdateWithoutGenresInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: ImageUpdateOneWithoutGamesNestedInput
    reviews?: ReviewUpdateManyWithoutGameNestedInput
    users?: GameUserUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUpdateManyWithoutFavouritesNestedInput
    platforms?: PlatformUpdateManyWithoutGamesNestedInput
    tags?: GameTagUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUpdateManyWithoutGamesNestedInput
    images?: GameImageUpdateManyWithoutGameNestedInput
    achievements?: AchievementUpdateManyWithoutGameNestedInput
    User?: UserUpdateOneWithoutPlayedGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutGenresInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: ReviewUncheckedUpdateManyWithoutGameNestedInput
    users?: GameUserUncheckedUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUncheckedUpdateManyWithoutFavouritesNestedInput
    platforms?: PlatformUncheckedUpdateManyWithoutGamesNestedInput
    tags?: GameTagUncheckedUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUncheckedUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUncheckedUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUncheckedUpdateManyWithoutGamesNestedInput
    images?: GameImageUncheckedUpdateManyWithoutGameNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateManyWithoutGenresInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GameUpdateWithoutPlatformsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: ImageUpdateOneWithoutGamesNestedInput
    reviews?: ReviewUpdateManyWithoutGameNestedInput
    users?: GameUserUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUpdateManyWithoutGamesNestedInput
    tags?: GameTagUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUpdateManyWithoutGamesNestedInput
    images?: GameImageUpdateManyWithoutGameNestedInput
    achievements?: AchievementUpdateManyWithoutGameNestedInput
    User?: UserUpdateOneWithoutPlayedGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutPlatformsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: ReviewUncheckedUpdateManyWithoutGameNestedInput
    users?: GameUserUncheckedUpdateManyWithoutGameNestedInput
    favouritedBy?: UserUncheckedUpdateManyWithoutFavouritesNestedInput
    genres?: GenreUncheckedUpdateManyWithoutGamesNestedInput
    tags?: GameTagUncheckedUpdateManyWithoutGamesNestedInput
    statuses?: GameStatusUncheckedUpdateManyWithoutGamesNestedInput
    developers?: DeveloperUncheckedUpdateManyWithoutGamesNestedInput
    publishers?: PublisherUncheckedUpdateManyWithoutGamesNestedInput
    images?: GameImageUncheckedUpdateManyWithoutGameNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateManyWithoutPlatformsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImageId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}